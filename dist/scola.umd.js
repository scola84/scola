(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('mysql'), require('marked'), require('messagebird'), require('nodemailer'), require('fs-extra'), require('bcrypt'), require('parse5'), require('net'), require('tls'), require('busboy'), require('shortid'), require('msgpack-lite'), require('fs'), require('http'), require('postal-codes-js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'mysql', 'marked', 'messagebird', 'nodemailer', 'fs-extra', 'bcrypt', 'parse5', 'net', 'tls', 'busboy', 'shortid', 'msgpack-lite', 'fs', 'http', 'postal-codes-js'], factory) :
  (global = global || self, factory(global.scola = global.scola || {}, global.mysql, global.marked$1, global.messagebird, global.nodemailer, global.fs, global.bcrypt, global.parser, global.net, global.tls, global.Busboy, global.shortid, global.msgpackLite, global.fs$1, global.http, global.postalcodes));
}(this, function (exports, mysql, marked$1, messagebird, nodemailer, fs, bcrypt, parser, net, tls, Busboy, shortid, msgpackLite, fs$1, http, postalcodes) { 'use strict';

  mysql = mysql && mysql.hasOwnProperty('default') ? mysql['default'] : mysql;
  marked$1 = marked$1 && marked$1.hasOwnProperty('default') ? marked$1['default'] : marked$1;
  messagebird = messagebird && messagebird.hasOwnProperty('default') ? messagebird['default'] : messagebird;
  nodemailer = nodemailer && nodemailer.hasOwnProperty('default') ? nodemailer['default'] : nodemailer;
  fs = fs && fs.hasOwnProperty('default') ? fs['default'] : fs;
  parser = parser && parser.hasOwnProperty('default') ? parser['default'] : parser;
  net = net && net.hasOwnProperty('default') ? net['default'] : net;
  tls = tls && tls.hasOwnProperty('default') ? tls['default'] : tls;
  Busboy = Busboy && Busboy.hasOwnProperty('default') ? Busboy['default'] : Busboy;
  shortid = shortid && shortid.hasOwnProperty('default') ? shortid['default'] : shortid;
  postalcodes = postalcodes && postalcodes.hasOwnProperty('default') ? postalcodes['default'] : postalcodes;

  var id = 0;
  var log = function () {};

  var Worker = function Worker(options) {
    if ( options === void 0 ) options = {};

    this._description = null;
    this._id = null;

    this._bypass = null;
    this._parent = null;
    this._worker = null;

    this._act = null;
    this._decide = null;
    this._err = null;
    this._filter = null;
    this._log = null;
    this._merge = null;
    this._wrap = null;

    this.setAct(options.act);
    this.setBypass(options.bypass);
    this.setDecide(options.decide);
    this.setDescription(options.description);
    this.setErr(options.err);
    this.setFilter(options.filter);
    this.setId(options.id);
    this.setLog(options.log);
    this.setMerge(options.merge);
    this.setParent(options.parent);
    this.setWrap(options.wrap);
    this.setWorker(options.worker);
  };

  Worker.getLog = function getLog () {
    return log;
  };

  Worker.setLog = function setLog (value) {
    log = value;
  };

  Worker.log = function log (name, worker, box, error) {
    if (name === 'fail' && error.logged !== true) {
      error.logged = true;
      console.error(new Date().toISOString(), error);
    }
  };

  Worker.prototype.getOptions = function getOptions () {
    return {
      act: this._act,
      decide: this._decide,
      description: this._description,
      err: this._err,
      filter: this._filter,
      log: this._log,
      merge: this._merge,
      wrap: this._wrap
    };
  };

  Worker.prototype.getAct = function getAct () {
    return this._act;
  };

  Worker.prototype.setAct = function setAct (value) {
      if ( value === void 0 ) value = null;

    this._act = value;
    return this;
  };

  Worker.prototype.getBypass = function getBypass () {
    return this._bypass;
  };

  Worker.prototype.setBypass = function setBypass (value) {
      if ( value === void 0 ) value = null;

    this._bypass = value;
    return this;
  };

  Worker.prototype.getDecide = function getDecide () {
    return this._decide;
  };

  Worker.prototype.setDecide = function setDecide (value) {
      if ( value === void 0 ) value = null;

    this._decide = value;
    return this;
  };

  Worker.prototype.getDescription = function getDescription () {
    return this._description;
  };

  Worker.prototype.setDescription = function setDescription (value) {
      if ( value === void 0 ) value = null;

    this._description = value;
    return this;
  };

  Worker.prototype.getErr = function getErr () {
    return this._err;
  };

  Worker.prototype.setErr = function setErr (value) {
      if ( value === void 0 ) value = null;

    this._err = value;
    return this;
  };

  Worker.prototype.getFilter = function getFilter () {
    return this._filter;
  };

  Worker.prototype.setFilter = function setFilter (value) {
      if ( value === void 0 ) value = null;

    this._filter = value;
    return this;
  };

  Worker.prototype.getId = function getId () {
    return this._id;
  };

  Worker.prototype.setId = function setId (value) {
      if ( value === void 0 ) value = ++id;

    this._id = value;
    return this;
  };

  Worker.prototype.getLog = function getLog () {
    return this._log;
  };

  Worker.prototype.setLog = function setLog (value) {
      if ( value === void 0 ) value = null;

    this._log = value;
    return this;
  };

  Worker.prototype.getMerge = function getMerge () {
    return this._merge;
  };

  Worker.prototype.setMerge = function setMerge (value) {
      if ( value === void 0 ) value = null;

    this._merge = value;
    return this;
  };

  Worker.prototype.getParent = function getParent () {
    return this._parent;
  };

  Worker.prototype.setParent = function setParent (value) {
      if ( value === void 0 ) value = null;

    this._parent = value;
    return this;
  };

  Worker.prototype.getWrap = function getWrap () {
    return this._wrap;
  };

  Worker.prototype.setWrap = function setWrap (value) {
      if ( value === void 0 ) value = false;

    this._wrap = value;
    return this;
  };

  Worker.prototype.getWorker = function getWorker () {
    return this._worker;
  };

  Worker.prototype.setWorker = function setWorker (value) {
      if ( value === void 0 ) value = null;

    this._worker = value;
    return this;
  };

  Worker.prototype.act = function act (box, data, callback) {
    data = this.filter(box, data);

    if (this._act) {
      this._act(box, data, callback);
      return;
    }

    data = this.merge(box, data);
    this.pass(box, data, callback);
  };

  Worker.prototype.bypass = function bypass (worker) {
      if ( worker === void 0 ) worker = null;

    if (worker === null) {
      return this;
    }

    this._bypass = worker;
    return this;
  };

  Worker.prototype.connect = function connect (worker) {
      if ( worker === void 0 ) worker = null;

    if (worker === null) {
      return this;
    }

    if (Array.isArray(worker)) {
      this.connect(worker[0]);
      return worker[1];
    }

    this._worker = worker.setParent(this);
    return worker;
  };

  Worker.prototype.decide = function decide (box, data, callback) {
    if (this._decide) {
      return this._decide(box, data, callback);
    }

    return true;
  };

  Worker.prototype.err = function err (box, error, callback) {
    if (this._err) {
      this._err(box, error, callback);
      return;
    }

    this.fail(box, error, callback);
  };

  Worker.prototype.fail = function fail (box, error, callback) {
    this.log('fail', box, error);

    try {
      if (this._bypass) {
        this._bypass.err(box, error, callback);
      } else if (this._worker) {
        this._worker.err(box, error, callback);
      }
    } catch (tryError) {
      console.error(tryError);
    }
  };

  Worker.prototype.filter = function filter (box, data) {
      var ref;

      var extra = [], len = arguments.length - 2;
      while ( len-- > 0 ) extra[ len ] = arguments[ len + 2 ];
    if (this._filter) {
      return (ref = this)._filter.apply(ref, [ box, data ].concat( extra ));
    }

    return data;
  };

  Worker.prototype.find = function find (compare) {
    if (compare(this) === true) {
      return this;
    }

    if (this._worker) {
      return this._worker.find(compare);
    }

    return null;
  };

  Worker.prototype.handle = function handle (box, data, callback) {
    var decision = this.decide(box, data, callback);

    if (decision === true) {
      this.act(box, data, callback);
    } else if (decision === false) {
      this.skip(box, data, callback);
    } else if (this._bypass) {
      this._bypass.handle(box, data, callback);
    }
  };

  Worker.prototype.log = function log$1 (type) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    (this._log || log).apply(void 0, [ type, this ].concat( args ));
  };

  Worker.prototype.merge = function merge (box, data) {
      var ref;

      var extra = [], len = arguments.length - 2;
      while ( len-- > 0 ) extra[ len ] = arguments[ len + 2 ];
    if (this._merge) {
      return (ref = this)._merge.apply(ref, [ box, data ].concat( extra ));
    }

    return data;
  };

  Worker.prototype.pass = function pass (box, data, callback) {
    this.log('pass', box, data);

    try {
      if (this._worker) {
        this._worker.handle(box, data, callback);
      }
    } catch (tryError) {
      this.fail(box, tryError, callback);
    }
  };

  Worker.prototype.prepend = function prepend (worker) {
    return this._parent
      .connect(worker)
      .connect(this);
  };

  Worker.prototype.skip = function skip (box, data, callback) {
    this.log('skip', box, data);

    if (this._worker) {
      this._worker.handle(box, data, callback);
    }
  };

  var Broadcaster = /*@__PURE__*/(function (Worker) {
    function Broadcaster(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._name = null;
      this._sync = null;
      this._unify = null;
      this._workers = [];

      this.setName(options.name);
      this.setSync(options.sync);
      this.setUnify(options.unify);
    }

    if ( Worker ) Broadcaster.__proto__ = Worker;
    Broadcaster.prototype = Object.create( Worker && Worker.prototype );
    Broadcaster.prototype.constructor = Broadcaster;

    Broadcaster.prototype.getOptions = function getOptions () {
      return Object.assign(Worker.prototype.getOptions.call(this), {
        name: this._name,
        sync: this._sync,
        unify: this._unify
      });
    };

    Broadcaster.prototype.getName = function getName () {
      return this._name;
    };

    Broadcaster.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = 'default';

      this._name = value;
      return this;
    };

    Broadcaster.prototype.getSync = function getSync () {
      return this._sync;
    };

    Broadcaster.prototype.setSync = function setSync (value) {
      if ( value === void 0 ) value = false;

      this._sync = value;
      return this;
    };

    Broadcaster.prototype.getUnify = function getUnify () {
      return this._unify;
    };

    Broadcaster.prototype.setUnify = function setUnify (value) {
      if ( value === void 0 ) value = true;

      this._unify = value;
      return this;
    };

    Broadcaster.prototype.connect = function connect (worker) {
      if ( worker === void 0 ) worker = null;

      if (worker === null) {
        return this;
      }

      if (Array.isArray(worker)) {
        this.connect(worker[0]);
        return worker[1];
      }

      this._workers.push(worker);
      return Worker.prototype.connect.call(this, worker);
    };

    Broadcaster.prototype.find = function find (compare, up) {
      if ( up === void 0 ) up = false;

      var found = Worker.prototype.find.call(this, compare, up);

      if (found !== null) {
        return found;
      }

      for (var i = 0; i < this._workers.length; i += 1) {
        found = this._workers[i].find(compare, up);

        if (found) {
          return found;
        }
      }

      return found;
    };

    Broadcaster.prototype.pass = function pass (box, data, callback) {
      if (this._wrap === true) {
        box = { box: box };
      }

      if (this._unify === true) {
        var unify = {
          count: 0,
          empty: false,
          total: this._workers.length
        };

        box.unify = box.unify || {};
        box.unify[this._name] = unify;

        this.log('info', box, data, box.unify);
      }

      if (this._sync) {
        this.passSync(box, data, callback);
        return;
      }

      this.passAsync(box, data, callback);
    };

    Broadcaster.prototype.passAsync = function passAsync (box, data, callback) {
      for (var i = 0; i < this._workers.length; i += 1) {
        this._workers[i].handle(box, data, callback);
      }
    };

    Broadcaster.prototype.passSync = function passSync (box, data, callback) {
      var this$1 = this;

      var unify = box.unify[this._name];

      var cb = unify.count === (unify.total - 1) ?
        callback :
        function () { return this$1.passSync(box, data, callback); };

      this._workers[unify.count].handle(box, data, cb);
    };

    return Broadcaster;
  }(Worker));

  var Builder = /*@__PURE__*/(function (Worker) {
    function Builder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) Builder.__proto__ = Worker;
    Builder.prototype = Object.create( Worker && Worker.prototype );
    Builder.prototype.constructor = Builder;

    Builder.attachFactories = function attachFactories (target, objects) {
      var groups = Object.keys(objects);

      var group = null;
      var names = null;

      for (var i = 0; i < groups.length; i += 1) {
        group = groups[i];
        names = Object.keys(objects[group]);

        for (var j = 0; j < names.length; j += 1) {
          Builder.attachFactory(target, objects, group, names[j]);
        }
      }
    };

    Builder.attachFactory = function attachFactory (target, objects, group, name) {
      var ref = objects[group][name];
      var object = ref.object;
      var options = ref.options;

      if (
        target.prototype[name] ||
        target.prototype.__proto__[name]
      ) {
        name = group + name;
      }

      target.prototype[name] = function create() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return new object(Object.assign({
          args: args,
          builder: this
        }, options));
      };
    };

    return Builder;
  }(Worker));

  var Manager = /*@__PURE__*/(function (Worker) {
    function Manager(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._names = null;
      this._pool = {};

      this.setNames(options.names);
    }

    if ( Worker ) Manager.__proto__ = Worker;
    Manager.prototype = Object.create( Worker && Worker.prototype );
    Manager.prototype.constructor = Manager;

    Manager.prototype.getOptions = function getOptions () {
      return Object.assign(Worker.prototype.getOptions.call(this), {
        names: this._names
      });
    };

    Manager.prototype.getNames = function getNames () {
      return this._names;
    };

    Manager.prototype.setNames = function setNames (value) {
      if ( value === void 0 ) value = null;

      this._names = value;
      return this;
    };

    Manager.prototype.act = function act (box, data, callback) {
      if (typeof box._names === 'undefined') {
        box = Object.assign({ _original: box }, box);
        box._names = this.names(box);
      }

      if (box._names.length === 0) {
        this.pass(box._original, data, callback);
        return;
      }

      var name = box._names.shift();
      var worker = this._pool[name];

      this.log('info', box, data, name);

      if (worker) {
        worker.handle(box, data, callback);
        return;
      }

      this.handle(box, data, callback);
    };

    Manager.prototype.fail = function fail (box, error, callback) {
      Worker.prototype.fail.call(this, box._original || box, error, callback);
    };

    Manager.prototype.manage = function manage (name, worker) {
      this._pool[name] = worker;
      return worker.connect(this);
    };

    Manager.prototype.names = function names (box) {
      if (this._names) {
        return this._names(box);
      }

      return [];
    };

    return Manager;
  }(Worker));

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? _strictIndexOf(array, value, fromIndex)
      : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  var isArray_1 = isArray;

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  var noop_1 = noop;

  var onlyOnce_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = onlyOnce;
  function onlyOnce(fn) {
      return function () {
          if (fn === null) { throw new Error("Callback was already called."); }
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
      };
  }
  module.exports = exports["default"];
  });

  unwrapExports(onlyOnce_1);

  var slice_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = slice;
  function slice(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
          newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
  }
  module.exports = exports["default"];
  });

  unwrapExports(slice_1);

  var setImmediate_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.hasNextTick = exports.hasSetImmediate = undefined;
  exports.fallback = fallback;
  exports.wrap = wrap;



  var _slice2 = _interopRequireDefault(slice_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
  var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

  function fallback(fn) {
      setTimeout(fn, 0);
  }

  function wrap(defer) {
      return function (fn /*, ...args*/) {
          var args = (0, _slice2.default)(arguments, 1);
          defer(function () {
              fn.apply(null, args);
          });
      };
  }

  var _defer;

  if (hasSetImmediate) {
      _defer = setImmediate;
  } else if (hasNextTick) {
      _defer = process.nextTick;
  } else {
      _defer = fallback;
  }

  exports.default = wrap(_defer);
  });

  unwrapExports(setImmediate_1);
  var setImmediate_2 = setImmediate_1.hasNextTick;
  var setImmediate_3 = setImmediate_1.hasSetImmediate;
  var setImmediate_4 = setImmediate_1.fallback;
  var setImmediate_5 = setImmediate_1.wrap;

  var DoublyLinkedList = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = DLL;
  // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
  // used for queues. This implementation assumes that the node provided by the user can be modified
  // to adjust the next and last properties. We implement only the minimal functionality
  // for queue support.
  function DLL() {
      this.head = this.tail = null;
      this.length = 0;
  }

  function setInitial(dll, node) {
      dll.length = 1;
      dll.head = dll.tail = node;
  }

  DLL.prototype.removeLink = function (node) {
      if (node.prev) { node.prev.next = node.next; }else { this.head = node.next; }
      if (node.next) { node.next.prev = node.prev; }else { this.tail = node.prev; }

      node.prev = node.next = null;
      this.length -= 1;
      return node;
  };

  DLL.prototype.empty = function () {
      while (this.head) { this.shift(); }
      return this;
  };

  DLL.prototype.insertAfter = function (node, newNode) {
      newNode.prev = node;
      newNode.next = node.next;
      if (node.next) { node.next.prev = newNode; }else { this.tail = newNode; }
      node.next = newNode;
      this.length += 1;
  };

  DLL.prototype.insertBefore = function (node, newNode) {
      newNode.prev = node.prev;
      newNode.next = node;
      if (node.prev) { node.prev.next = newNode; }else { this.head = newNode; }
      node.prev = newNode;
      this.length += 1;
  };

  DLL.prototype.unshift = function (node) {
      if (this.head) { this.insertBefore(this.head, node); }else { setInitial(this, node); }
  };

  DLL.prototype.push = function (node) {
      if (this.tail) { this.insertAfter(this.tail, node); }else { setInitial(this, node); }
  };

  DLL.prototype.shift = function () {
      return this.head && this.removeLink(this.head);
  };

  DLL.prototype.pop = function () {
      return this.tail && this.removeLink(this.tail);
  };

  DLL.prototype.toArray = function () {
      var arr = Array(this.length);
      var curr = this.head;
      for (var idx = 0; idx < this.length; idx++) {
          arr[idx] = curr.data;
          curr = curr.next;
      }
      return arr;
  };

  DLL.prototype.remove = function (testFn) {
      var curr = this.head;
      while (!!curr) {
          var next = curr.next;
          if (testFn(curr)) {
              this.removeLink(curr);
          }
          curr = next;
      }
      return this;
  };
  module.exports = exports["default"];
  });

  unwrapExports(DoublyLinkedList);

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  var initialParams = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  exports.default = function (fn) {
      return function () /*...args, callback*/{
          var args = (0, _slice2.default)(arguments);
          var callback = args.pop();
          fn.call(this, args, callback);
      };
  };



  var _slice2 = _interopRequireDefault(slice_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  module.exports = exports['default'];
  });

  unwrapExports(initialParams);

  var asyncify_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = asyncify;



  var _isObject2 = _interopRequireDefault(isObject_1);



  var _initialParams2 = _interopRequireDefault(initialParams);



  var _setImmediate2 = _interopRequireDefault(setImmediate_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Take a sync function and make it async, passing its return value to a
   * callback. This is useful for plugging sync functions into a waterfall,
   * series, or other async functions. Any arguments passed to the generated
   * function will be passed to the wrapped function (except for the final
   * callback argument). Errors thrown will be passed to the callback.
   *
   * If the function passed to `asyncify` returns a Promise, that promises's
   * resolved/rejected state will be used to call the callback, rather than simply
   * the synchronous return value.
   *
   * This also means you can asyncify ES2017 `async` functions.
   *
   * @name asyncify
   * @static
   * @memberOf module:Utils
   * @method
   * @alias wrapSync
   * @category Util
   * @param {Function} func - The synchronous function, or Promise-returning
   * function to convert to an {@link AsyncFunction}.
   * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
   * invoked with `(args..., callback)`.
   * @example
   *
   * // passing a regular synchronous function
   * async.waterfall([
   *     async.apply(fs.readFile, filename, "utf8"),
   *     async.asyncify(JSON.parse),
   *     function (data, next) {
   *         // data is the result of parsing the text.
   *         // If there was a parsing error, it would have been caught.
   *     }
   * ], callback);
   *
   * // passing a function returning a promise
   * async.waterfall([
   *     async.apply(fs.readFile, filename, "utf8"),
   *     async.asyncify(function (contents) {
   *         return db.model.create(contents);
   *     }),
   *     function (model, next) {
   *         // `model` is the instantiated model object.
   *         // If there was an error, this function would be skipped.
   *     }
   * ], callback);
   *
   * // es2017 example, though `asyncify` is not needed if your JS environment
   * // supports async functions out of the box
   * var q = async.queue(async.asyncify(async function(file) {
   *     var intermediateStep = await processFile(file);
   *     return await somePromise(intermediateStep)
   * }));
   *
   * q.push(files);
   */
  function asyncify(func) {
      return (0, _initialParams2.default)(function (args, callback) {
          var result;
          try {
              result = func.apply(this, args);
          } catch (e) {
              return callback(e);
          }
          // if result is Promise object
          if ((0, _isObject2.default)(result) && typeof result.then === 'function') {
              result.then(function (value) {
                  invokeCallback(callback, null, value);
              }, function (err) {
                  invokeCallback(callback, err.message ? err : new Error(err));
              });
          } else {
              callback(null, result);
          }
      });
  }

  function invokeCallback(callback, error, value) {
      try {
          callback(error, value);
      } catch (e) {
          (0, _setImmediate2.default)(rethrow, e);
      }
  }

  function rethrow(error) {
      throw error;
  }
  module.exports = exports['default'];
  });

  unwrapExports(asyncify_1);

  var wrapAsync_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.isAsync = undefined;



  var _asyncify2 = _interopRequireDefault(asyncify_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var supportsSymbol = typeof Symbol === 'function';

  function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
  }

  function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  }

  exports.default = wrapAsync;
  exports.isAsync = isAsync;
  });

  unwrapExports(wrapAsync_1);
  var wrapAsync_2 = wrapAsync_1.isAsync;

  var queue_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = queue;



  var _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);



  var _isArray2 = _interopRequireDefault(isArray_1);



  var _noop2 = _interopRequireDefault(noop_1);



  var _onlyOnce2 = _interopRequireDefault(onlyOnce_1);



  var _setImmediate2 = _interopRequireDefault(setImmediate_1);



  var _DoublyLinkedList2 = _interopRequireDefault(DoublyLinkedList);



  var _wrapAsync2 = _interopRequireDefault(wrapAsync_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function queue(worker, concurrency, payload) {
      if (concurrency == null) {
          concurrency = 1;
      } else if (concurrency === 0) {
          throw new Error('Concurrency must not be zero');
      }

      var _worker = (0, _wrapAsync2.default)(worker);
      var numRunning = 0;
      var workersList = [];

      var processingScheduled = false;
      function _insert(data, insertAtFront, callback) {
          if (callback != null && typeof callback !== 'function') {
              throw new Error('task callback must be a function');
          }
          q.started = true;
          if (!(0, _isArray2.default)(data)) {
              data = [data];
          }
          if (data.length === 0 && q.idle()) {
              // call drain immediately if there are no tasks
              return (0, _setImmediate2.default)(function () {
                  q.drain();
              });
          }

          for (var i = 0, l = data.length; i < l; i++) {
              var item = {
                  data: data[i],
                  callback: callback || _noop2.default
              };

              if (insertAtFront) {
                  q._tasks.unshift(item);
              } else {
                  q._tasks.push(item);
              }
          }

          if (!processingScheduled) {
              processingScheduled = true;
              (0, _setImmediate2.default)(function () {
                  processingScheduled = false;
                  q.process();
              });
          }
      }

      function _next(tasks) {
          return function (err) {
              var arguments$1 = arguments;

              numRunning -= 1;

              for (var i = 0, l = tasks.length; i < l; i++) {
                  var task = tasks[i];

                  var index = (0, _baseIndexOf2.default)(workersList, task, 0);
                  if (index === 0) {
                      workersList.shift();
                  } else if (index > 0) {
                      workersList.splice(index, 1);
                  }

                  task.callback.apply(task, arguments$1);

                  if (err != null) {
                      q.error(err, task.data);
                  }
              }

              if (numRunning <= q.concurrency - q.buffer) {
                  q.unsaturated();
              }

              if (q.idle()) {
                  q.drain();
              }
              q.process();
          };
      }

      var isProcessing = false;
      var q = {
          _tasks: new _DoublyLinkedList2.default(),
          concurrency: concurrency,
          payload: payload,
          saturated: _noop2.default,
          unsaturated: _noop2.default,
          buffer: concurrency / 4,
          empty: _noop2.default,
          drain: _noop2.default,
          error: _noop2.default,
          started: false,
          paused: false,
          push: function (data, callback) {
              _insert(data, false, callback);
          },
          kill: function () {
              q.drain = _noop2.default;
              q._tasks.empty();
          },
          unshift: function (data, callback) {
              _insert(data, true, callback);
          },
          remove: function (testFn) {
              q._tasks.remove(testFn);
          },
          process: function () {
              // Avoid trying to start too many processing operations. This can occur
              // when callbacks resolve synchronously (#1267).
              if (isProcessing) {
                  return;
              }
              isProcessing = true;
              while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
                  var tasks = [],
                      data = [];
                  var l = q._tasks.length;
                  if (q.payload) { l = Math.min(l, q.payload); }
                  for (var i = 0; i < l; i++) {
                      var node = q._tasks.shift();
                      tasks.push(node);
                      workersList.push(node);
                      data.push(node.data);
                  }

                  numRunning += 1;

                  if (q._tasks.length === 0) {
                      q.empty();
                  }

                  if (numRunning === q.concurrency) {
                      q.saturated();
                  }

                  var cb = (0, _onlyOnce2.default)(_next(tasks));
                  _worker(data, cb);
              }
              isProcessing = false;
          },
          length: function () {
              return q._tasks.length;
          },
          running: function () {
              return numRunning;
          },
          workersList: function () {
              return workersList;
          },
          idle: function () {
              return q._tasks.length + numRunning === 0;
          },
          pause: function () {
              q.paused = true;
          },
          resume: function () {
              if (q.paused === false) {
                  return;
              }
              q.paused = false;
              (0, _setImmediate2.default)(q.process);
          }
      };
      return q;
  }
  module.exports = exports['default'];
  });

  unwrapExports(queue_1);

  var queue = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (worker, concurrency) {
    var _worker = (0, _wrapAsync2.default)(worker);
    return (0, _queue2.default)(function (items, cb) {
      _worker(items[0], cb);
    }, concurrency, 1);
  };



  var _queue2 = _interopRequireDefault(queue_1);



  var _wrapAsync2 = _interopRequireDefault(wrapAsync_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  module.exports = exports['default'];

  /**
   * A queue of tasks for the worker function to complete.
   * @typedef {Object} QueueObject
   * @memberOf module:ControlFlow
   * @property {Function} length - a function returning the number of items
   * waiting to be processed. Invoke with `queue.length()`.
   * @property {boolean} started - a boolean indicating whether or not any
   * items have been pushed and processed by the queue.
   * @property {Function} running - a function returning the number of items
   * currently being processed. Invoke with `queue.running()`.
   * @property {Function} workersList - a function returning the array of items
   * currently being processed. Invoke with `queue.workersList()`.
   * @property {Function} idle - a function returning false if there are items
   * waiting or being processed, or true if not. Invoke with `queue.idle()`.
   * @property {number} concurrency - an integer for determining how many `worker`
   * functions should be run in parallel. This property can be changed after a
   * `queue` is created to alter the concurrency on-the-fly.
   * @property {Function} push - add a new task to the `queue`. Calls `callback`
   * once the `worker` has finished processing the task. Instead of a single task,
   * a `tasks` array can be submitted. The respective callback is used for every
   * task in the list. Invoke with `queue.push(task, [callback])`,
   * @property {Function} unshift - add a new task to the front of the `queue`.
   * Invoke with `queue.unshift(task, [callback])`.
   * @property {Function} remove - remove items from the queue that match a test
   * function.  The test function will be passed an object with a `data` property,
   * and a `priority` property, if this is a
   * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
   * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
   * `function ({data, priority}) {}` and returns a Boolean.
   * @property {Function} saturated - a callback that is called when the number of
   * running workers hits the `concurrency` limit, and further tasks will be
   * queued.
   * @property {Function} unsaturated - a callback that is called when the number
   * of running workers is less than the `concurrency` & `buffer` limits, and
   * further tasks will not be queued.
   * @property {number} buffer - A minimum threshold buffer in order to say that
   * the `queue` is `unsaturated`.
   * @property {Function} empty - a callback that is called when the last item
   * from the `queue` is given to a `worker`.
   * @property {Function} drain - a callback that is called when the last item
   * from the `queue` has returned from the `worker`.
   * @property {Function} error - a callback that is called when a task errors.
   * Has the signature `function(error, task)`.
   * @property {boolean} paused - a boolean for determining whether the queue is
   * in a paused state.
   * @property {Function} pause - a function that pauses the processing of tasks
   * until `resume()` is called. Invoke with `queue.pause()`.
   * @property {Function} resume - a function that resumes the processing of
   * queued tasks when the queue is paused. Invoke with `queue.resume()`.
   * @property {Function} kill - a function that removes the `drain` callback and
   * empties remaining tasks from the queue forcing it to go idle. No more tasks
   * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
   */

  /**
   * Creates a `queue` object with the specified `concurrency`. Tasks added to the
   * `queue` are processed in parallel (up to the `concurrency` limit). If all
   * `worker`s are in progress, the task is queued until one becomes available.
   * Once a `worker` completes a `task`, that `task`'s callback is called.
   *
   * @name queue
   * @static
   * @memberOf module:ControlFlow
   * @method
   * @category Control Flow
   * @param {AsyncFunction} worker - An async function for processing a queued task.
   * If you want to handle errors from an individual task, pass a callback to
   * `q.push()`. Invoked with (task, callback).
   * @param {number} [concurrency=1] - An `integer` for determining how many
   * `worker` functions should be run in parallel.  If omitted, the concurrency
   * defaults to `1`.  If the concurrency is `0`, an error is thrown.
   * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
   * attached as certain properties to listen for specific events during the
   * lifecycle of the queue.
   * @example
   *
   * // create a queue object with concurrency 2
   * var q = async.queue(function(task, callback) {
   *     console.log('hello ' + task.name);
   *     callback();
   * }, 2);
   *
   * // assign a callback
   * q.drain = function() {
   *     console.log('all items have been processed');
   * };
   *
   * // add some items to the queue
   * q.push({name: 'foo'}, function(err) {
   *     console.log('finished processing foo');
   * });
   * q.push({name: 'bar'}, function (err) {
   *     console.log('finished processing bar');
   * });
   *
   * // add some items to the queue (batch-wise)
   * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
   *     console.log('finished processing item');
   * });
   *
   * // add some items to the front of the queue
   * q.unshift({name: 'bar'}, function (err) {
   *     console.log('finished processing bar');
   * });
   */
  });

  var createQueue = unwrapExports(queue);

  var queues = {};

  var Queuer = /*@__PURE__*/(function (Worker) {
    function Queuer(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._concurrency = null;
      this._drain = null;
      this._handler = null;
      this._name = null;
      this._queue = null;
      this._queuer = null;
      this._saturated = null;
      this._unsaturated = null;

      this.setConcurrency(options.concurrency);
      this.setDrain(options.drain);
      this.setName(options.name);
      this.setQueue(options.queue);
      this.setSaturated(options.saturated);
      this.setUnsaturated(options.unsaturated);

      if (options.handler) {
        this.setHandler(options.handler);
        this.startHandler();
      }

      if (options.queuer) {
        this.setQueuer(options.queuer);
        this.startQueuer();
      }
    }

    if ( Worker ) Queuer.__proto__ = Worker;
    Queuer.prototype = Object.create( Worker && Worker.prototype );
    Queuer.prototype.constructor = Queuer;

    Queuer.createQueue = function createQueue$1 (concurrency, name) {
      if ( name === void 0 ) name = null;

      if (queues[name]) {
        return queues[name];
      }

      var queue = createQueue(function (fn, callback) {
        fn(callback);
      }, concurrency);

      if (name !== null) {
        queues[name] = queue;
      }

      return queue;
    };

    Queuer.prototype.getOptions = function getOptions () {
      return Object.assign(Worker.prototype.getOptions.call(this), {
        concurrency: this._concurrency,
        drain: this._drain,
        handler: this._handler,
        name: this._name,
        queuer: this._queuer,
        saturated: this._saturated,
        unsaturated: this._unsaturated
      });
    };

    Queuer.prototype.getConcurrency = function getConcurrency () {
      return this._concurrency;
    };

    Queuer.prototype.setConcurrency = function setConcurrency (value) {
      if ( value === void 0 ) value = 1;

      this._concurrency = value;
      return this;
    };

    Queuer.prototype.getDrain = function getDrain () {
      return this._drain;
    };

    Queuer.prototype.setDrain = function setDrain (value) {
      if ( value === void 0 ) value = function () {};

      this._drain = value;
      return this;
    };

    Queuer.prototype.getHandler = function getHandler () {
      return this._handler;
    };

    Queuer.prototype.setHandler = function setHandler (value) {
      if ( value === void 0 ) value = null;

      this._handler = value;
      return this;
    };

    Queuer.prototype.getName = function getName () {
      return this._name;
    };

    Queuer.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = null;

      this._name = value;
      return this;
    };

    Queuer.prototype.getQueue = function getQueue () {
      return this._queue;
    };

    Queuer.prototype.setQueue = function setQueue (value) {
      if ( value === void 0 ) value = null;

      this._queue = value;
      return this;
    };

    Queuer.prototype.getQueuer = function getQueuer () {
      return this._queuer;
    };

    Queuer.prototype.setQueuer = function setQueuer (value) {
      if ( value === void 0 ) value = null;

      this._queuer = value;
      return this;
    };

    Queuer.prototype.getSaturated = function getSaturated () {
      return this._saturated;
    };

    Queuer.prototype.setSaturated = function setSaturated (value) {
      if ( value === void 0 ) value = function () {};

      this._saturated = value;
      return this;
    };

    Queuer.prototype.getUnsaturated = function getUnsaturated () {
      return this._unsaturated;
    };

    Queuer.prototype.setUnsaturated = function setUnsaturated (value) {
      if ( value === void 0 ) value = function () {};

      this._unsaturated = value;
      return this;
    };

    Queuer.prototype.act = function act (box, data) {
      if (this._queuer !== null) {
        this.pushToRemote(box, data);
      } else if (this._handler === null) {
        this.pushToLocal(box, data);
      }
    };

    Queuer.prototype.createQueue = function createQueue (box) {
      var this$1 = this;

      this._queue = Queuer.createQueue(
        this._concurrency,
        this._name
      );

      this._queue.saturated = function () {
        this$1._saturated(box);
      };

      this._queue.unsaturated = function () {
        this$1._unsaturated(box);
      };

      this._queue.drain = function () {
        this$1._drain(box);
      };
    };

    Queuer.prototype.handleRemote = function handleRemote (callback) {
      var this$1 = this;

      this._handler.rpop(this._name, function (error, data) {
        if (error) {
          callback();
          this$1.log('fail', null, error);
          return;
        }

        if (data === null) {
          callback();
          this$1._queue.unsaturated = function () {};
          return;
        }

        try {
          data = JSON.parse(data);
        } catch (jsonError) {
          callback();
          this$1.log('fail', null, jsonError);
          return;
        }

        this$1.pass({}, data, callback);
      });
    };

    Queuer.prototype.pushFromRemote = function pushFromRemote () {
      var this$1 = this;

      if (this._queue === null) {
        this.createQueue();
      }

      if (this._queue.length() === this._concurrency) {
        return;
      }

      this._queue.unsaturated = function () {
        this$1.pushFromRemote();
      };

      this._queue.push(function (callback) {
        this$1.handleRemote(callback);
      });
    };

    Queuer.prototype.pushToLocal = function pushToLocal (box, data) {
      var this$1 = this;

      if (this._queue === null) {
        this.createQueue(box);
      }

      if (this._queue.length() === this._concurrency) {
        this._queue.saturated();
      }

      this._queue.push(function (callback) {
        this$1.pass(box, data, callback);
      });
    };

    Queuer.prototype.pushToRemote = function pushToRemote (box, data) {
      var this$1 = this;

      try {
        data = JSON.stringify(data);
      } catch (error) {
        this.log('fail', box, error);
        return;
      }

      this._queuer.lpush(this._name, data, function (error) {
        if (error) {
          this$1.log('fail', box, error);
          return;
        }

        this$1._pub.publish(this$1._name, 1);
      });
    };

    Queuer.prototype.startHandler = function startHandler () {
      var this$1 = this;

      this._sub = this._handler.duplicate();

      this._sub.on('error', function (error) {
        this$1.log('fail', null, error);
      });

      this._sub.on('message', function () {
        this$1.pushFromRemote();
      });

      this._sub.subscribe(this._name);
    };

    Queuer.prototype.startQueuer = function startQueuer () {
      var this$1 = this;

      this._pub = this._queuer.duplicate();

      this._pub.on('error', function (error) {
        this$1.log('fail', null, error);
      });
    };

    return Queuer;
  }(Worker));

  var Router = /*@__PURE__*/(function (Worker) {
    function Router(options) {
      Worker.call(this, options);
      this._workers = {};
    }

    if ( Worker ) Router.__proto__ = Worker;
    Router.prototype = Object.create( Worker && Worker.prototype );
    Router.prototype.constructor = Router;

    Router.prototype.act = function act (box, data, callback) {
      if (this._act) {
        this._act(box, data, callback);
        return;
      }

      var name = this.filter(box, data);
      this.pass(name, box, data, callback);
    };

    Router.prototype.connect = function connect (name, worker) {
      if ( worker === void 0 ) worker = null;

      if (worker === null) {
        return this;
      }

      if (Array.isArray(worker)) {
        this.connect(name, worker[0]);
        return worker[1];
      }

      this._workers[name] = worker;
      return Worker.prototype.connect.call(this, worker);
    };

    Router.prototype.filter = function filter (box, data, context) {
      if (this._filter) {
        return this._filter(box, data, context);
      }

      return box.name;
    };

    Router.prototype.find = function find (compare, up) {
      if ( up === void 0 ) up = false;

      var found = Worker.prototype.find.call(this, compare, up);

      if (found !== null) {
        return found;
      }

      var names = Object.keys(this._workers);

      for (var i = 0; i < names.length; i += 1) {
        found = this._workers[names[i]].find(compare, up);

        if (found) {
          return found;
        }
      }

      return found;
    };

    Router.prototype.pass = function pass (name, box, data, callback) {
      this.log('info', box, data, name);

      if (this._workers[name]) {
        this._workers[name].handle(box, data, callback);
      } else if (this._bypass) {
        this._bypass.handle(box, data, callback);
      }
    };

    return Router;
  }(Worker));

  var Slicer = /*@__PURE__*/(function (Worker) {
    function Slicer(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._count = null;
      this._name = null;
      this._unify = null;

      this.setCount(options.count);
      this.setName(options.name);
      this.setUnify(options.unify);
    }

    if ( Worker ) Slicer.__proto__ = Worker;
    Slicer.prototype = Object.create( Worker && Worker.prototype );
    Slicer.prototype.constructor = Slicer;

    Slicer.prototype.getOptions = function getOptions () {
      return Object.assign(Worker.prototype.getOptions.call(this), {
        count: this._count,
        name: this._name,
        unify: this._unify
      });
    };

    Slicer.prototype.getCount = function getCount () {
      return this._count;
    };

    Slicer.prototype.setCount = function setCount (value) {
      if ( value === void 0 ) value = 1;

      this._count = value;
      return this;
    };

    Slicer.prototype.getName = function getName () {
      return this._name;
    };

    Slicer.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = 'default';

      this._name = value;
      return this;
    };

    Slicer.prototype.getUnify = function getUnify () {
      return this._unify;
    };

    Slicer.prototype.setUnify = function setUnify (value) {
      if ( value === void 0 ) value = true;

      this._unify = value;
      return this;
    };

    Slicer.prototype.act = function act (box, data, callback) {
      var ref;

      var items = this.filter(box, data);

      if (this._wrap === true) {
        box = { box: box };
      }

      if (this._unify === true) {
        var unify = {
          count: 0,
          empty: items.length === 0,
          total: Math.ceil(items.length / this._count)
        };

        box.unify = box.unify || {};
        box.unify[this._name] = unify;

        this.log('info', box, data, box.unify);
      }

      if (items.length === 0) {
        if (this._bypass) {
          this._bypass.handle(box, data, callback);
        }
      }

      for (var i = 0; i < items.length; i += this._count) {
        (ref = this).pass.apply(
          ref, this.merge(box, data, items, i, i + this._count).concat( [callback] )
        );
      }
    };

    Slicer.prototype.merge = function merge (box, data, items, begin, end) {
      if (this._merge) {
        return this._merge(box, data, items, begin, end);
      }

      data = items.slice(begin, end);
      data = this._count === 1 ? data.pop() : data;

      return [box, data];
    };

    return Slicer;
  }(Worker));

  var Streamer = /*@__PURE__*/(function (Worker) {
    function Streamer(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._name = ['stream', this._id].join('_');

      this._data = null;
      this._end = null;
      this._stream = null;

      this.setData(options.data);
      this.setEnd(options.end);
      this.setStream(options.stream);
    }

    if ( Worker ) Streamer.__proto__ = Worker;
    Streamer.prototype = Object.create( Worker && Worker.prototype );
    Streamer.prototype.constructor = Streamer;

    Streamer.prototype.getOptions = function getOptions () {
      return Object.assign(Worker.prototype.getOptions.call(this), {
        data: this._data,
        end: this._end,
        stream: this._stream
      });
    };

    Streamer.prototype.getData = function getData () {
      return this._data;
    };

    Streamer.prototype.setData = function setData (value) {
      if ( value === void 0 ) value = null;

      this._data = value;
      return this;
    };

    Streamer.prototype.getEnd = function getEnd () {
      return this._end;
    };

    Streamer.prototype.setEnd = function setEnd (value) {
      if ( value === void 0 ) value = null;

      this._end = value;
      return this;
    };

    Streamer.prototype.getStream = function getStream () {
      return this._stream;
    };

    Streamer.prototype.setStream = function setStream (value) {
      if ( value === void 0 ) value = null;

      this._stream = value;
      return this;
    };

    Streamer.prototype.createReadStream = function createReadStream (box, data) {
      var this$1 = this;

      var streamer = this.createStream(box, data);

      if (streamer.read === true) {
        return streamer;
      }

      streamer.read = true;

      streamer.stream.on('data', function (d) {
        this$1.data(box, d);
      });

      streamer.stream.once('end', function () {
        this$1.end(box);
      });

      return streamer;
    };

    Streamer.prototype.createStream = function createStream (box, data) {
      var this$1 = this;

      var streamer = box[this._name];

      if (typeof streamer === 'undefined') {
        streamer = {
          data: [],
          paused: false,
          read: false,
          stream: this.stream(box, data),
          write: false
        };

        box[this._name] = streamer;

        if (streamer.stream.listenerCount('error') === 0) {
          streamer.stream.once('error', function (error) {
            this$1.fail(box, error);
          });
        }
      }

      return streamer;
    };

    Streamer.prototype.createWriteStream = function createWriteStream (box) {
      var streamer = this.createStream(box);

      if (streamer.write === true) {
        return streamer;
      }

      streamer.write = true;
      return streamer;
    };

    Streamer.prototype.data = function data (box, data$1) {
      var this$1 = this;

      this.log('info', box, data$1);

      if (this._data) {
        this._data(box, data$1);
        return;
      }

      this.pass(box, data$1, function (bx, resume) {
        this$1.throttle(box, resume);
      });
    };

    Streamer.prototype.end = function end (box) {
      if (this._end) {
        this._end(box);
        return;
      }

      this.pass(box, null);
    };

    Streamer.prototype.fail = function fail (box, error, callback) {
      this.throttle(box, false);
      Worker.prototype.fail.call(this, box, error, callback);
    };

    Streamer.prototype.pause = function pause (box, callback) {
      var this$1 = this;
      if ( callback === void 0 ) callback = function () {};

      box[this._name].paused = true;
      callback(box, false);

      box[this._name].stream.once('drain', function () {
        callback(box, true);
        this$1.resume(box, callback);
      });
    };

    Streamer.prototype.read = function read (box, data) {
      this.createReadStream(box, data);
    };

    Streamer.prototype.resume = function resume (box, callback) {
      box[this._name].paused = false;

      if (box[this._name].data.length === 0) {
        return;
      }

      this.write(box, box[this._name].data.shift(), callback);
    };

    Streamer.prototype.stream = function stream (box, data) {
      return this._stream(box, data);
    };

    Streamer.prototype.throttle = function throttle (box, resume) {
      var streamer = box[this._name];

      if (typeof streamer === 'undefined') {
        return;
      }

      if (resume === false) {
        streamer.stream.pause();
        return;
      }

      streamer.stream.resume();
    };

    Streamer.prototype.write = function write (box, data, callback) {
      this.log('info', box, data);

      var streamer = this.createWriteStream(box, data);

      if (data === null) {
        streamer.stream.end();
        return;
      }

      if (streamer.paused === true) {
        streamer.data.push(data);
        return;
      }

      var write = streamer.stream.write(data);

      if (write === false) {
        this.pause(box, callback);
      } else if (streamer.data.length > 0) {
        this.resume(box, callback);
      }
    };

    return Streamer;
  }(Worker));

  var monthNamesConversion = (function () {
    var months = ['january','february','march','april','may','june','july',
      'august','september','october','november','december'];
    var shortMonths = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug',
      'sep', 'oct', 'nov', 'dec'];

    function convertMonthName(expression, items){
      for(var i = 0; i < items.length; i++){
        expression = expression.replace(new RegExp(items[i], 'gi'), parseInt(i, 10) + 1);
      }
      return expression;
    }

    function interprete(monthExpression){
      monthExpression = convertMonthName(monthExpression, months);
      monthExpression = convertMonthName(monthExpression, shortMonths);
      return monthExpression;
    }

    return interprete;
  })();

  var weekDayNamesConversion = (function () {
    var weekDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday',
    'friday', 'saturday'];
    var shortWeekDays = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];

    function convertWeekDayName(expression, items){
      for(var i = 0; i < items.length; i++){
        expression = expression.replace(new RegExp(items[i], 'gi'), parseInt(i, 10));
      }
      return expression;
    }
    
    function convertWeekDays(expression){
      expression = expression.replace('7', '0');
      expression = convertWeekDayName(expression, weekDays);
      return convertWeekDayName(expression, shortWeekDays);
    }

    return convertWeekDays;
  })();

  var asteriskToRangeConversion = (function () {
    function convertAsterisk(expression, replecement){
      if(expression.indexOf('*') !== -1){
        return expression.replace('*', replecement);
      }
      return expression;
    }

    function convertAsterisksToRanges(expressions){
      expressions[0] = convertAsterisk(expressions[0], '0-59');
      expressions[1] = convertAsterisk(expressions[1], '0-59');
      expressions[2] = convertAsterisk(expressions[2], '0-23');
      expressions[3] = convertAsterisk(expressions[3], '1-31');
      expressions[4] = convertAsterisk(expressions[4], '1-12');
      expressions[5] = convertAsterisk(expressions[5], '0-6');
      return expressions;
    }

    return convertAsterisksToRanges;
  })();

  var rangeConversion = ( function () {
    function replaceWithRange(expression, text, init, end) {

      var numbers = [];
      var last = parseInt(end);
      var first = parseInt(init);

      if(first > last){
        last = parseInt(init);
        first = parseInt(end);
      }

      for(var i = first; i <= last; i++) {
        numbers.push(i);
      }

      return expression.replace(new RegExp(text, 'gi'), numbers.join());
    }

    function convertRange(expression){
      var rangeRegEx = /(\d+)\-(\d+)/;
      var match = rangeRegEx.exec(expression);
      while(match !== null && match.length > 0){
        expression = replaceWithRange(expression, match[0], match[1], match[2]);
        match = rangeRegEx.exec(expression);
      }
      return expression;
    }

    function convertAllRanges(expressions){
      for(var i = 0; i < expressions.length; i++){
        expressions[i] = convertRange(expressions[i]);
      }
      return expressions;
    }

    return convertAllRanges;
  })();

  var stepValuesConversion = (function () {
    function convertSteps(expressions){
      var stepValuePattern = /^(.+)\/(\d+)$/;
      for(var i = 0; i < expressions.length; i++){
        var match = stepValuePattern.exec(expressions[i]);
        var isStepValue = match !== null && match.length > 0;
        if(isStepValue){
          var values = match[1].split(',');
          var setpValues = [];
          var divider = parseInt(match[2], 10);
          for(var j = 0; j <= values.length; j++){
            var value = parseInt(values[j], 10);
            if(value % divider === 0){
              setpValues.push(value);
            }
          }
          expressions[i] = setpValues.join(',');
        }
      }
      return expressions;
    }

    return convertSteps;
  })();

  var convertExpression = (function () {

    function appendSeccondExpression(expressions){
      if(expressions.length === 5){
        return ['0'].concat(expressions);
      }
      return expressions;
    }

    function removeSpaces(str) {
      return str.replace(/\s{2,}/g, ' ').trim();
    }

    // Function that takes care of normalization.
    function normalizeIntegers(expressions) {
      for (var i=0; i < expressions.length; i++){
        var numbers = expressions[i].split(',');
        for (var j=0; j<numbers.length; j++){
          numbers[j] = parseInt(numbers[j]);
        }
        expressions[i] = numbers;
      }
      return expressions;
    }

    /*
     * The node-cron core allows only numbers (including multiple numbers e.g 1,2).
     * This module is going to translate the month names, week day names and ranges
     * to integers relatives.
     *
     * Month names example:
     *  - expression 0 1 1 January,Sep *
     *  - Will be translated to 0 1 1 1,9 *
     *
     * Week day names example:
     *  - expression 0 1 1 2 Monday,Sat
     *  - Will be translated to 0 1 1 1,5 *
     *
     * Ranges example:
     *  - expression 1-5 * * * *
     *  - Will be translated to 1,2,3,4,5 * * * *
     */
    function interprete(expression){
      var expressions = removeSpaces(expression).split(' ');
      expressions = appendSeccondExpression(expressions);
      expressions[4] = monthNamesConversion(expressions[4]);
      expressions[5] = weekDayNamesConversion(expressions[5]);
      expressions = asteriskToRangeConversion(expressions);
      expressions = rangeConversion(expressions);
      expressions = stepValuesConversion(expressions);

      expressions = normalizeIntegers(expressions);

      return expressions.join(' ');
    }

    return interprete;
  })();

  var patternValidation = ( function () {
    function isValidExpression(expression, min, max){
      var options = expression.split(',');
      var regexValidation = /^\d+$|^\*$|^\*\/\d+$/;
      for(var i = 0; i < options.length; i++){
        var option = options[i];
        var optionAsInt = parseInt(options[i], 10);
        if(optionAsInt < min || optionAsInt > max || !regexValidation.test(option)) {
          return false;
        }
      }
      return true;
    }

    function isInvalidSecond(expression){
      return !isValidExpression(expression, 0, 59);
    }

    function isInvalidMinute(expression){
      return !isValidExpression(expression, 0, 59);
    }

    function isInvalidHour(expression){
      return !isValidExpression(expression, 0, 23);
    }

    function isInvalidDayOfMonth(expression){
      return !isValidExpression(expression, 1, 31);
    }

    function isInvalidMonth(expression){
      return !isValidExpression(expression, 1, 12);
    }

    function isInvalidWeekDay(expression){
      return !isValidExpression(expression, 0, 7);
    }

    function validateFields(patterns, executablePatterns){
      if (isInvalidSecond(executablePatterns[0])) {
        throw patterns[0] + ' is a invalid expression for second';
      }

      if (isInvalidMinute(executablePatterns[1])) {
        throw patterns[1] + ' is a invalid expression for minute';
      }

      if (isInvalidHour(executablePatterns[2])) {
        throw patterns[2] + ' is a invalid expression for hour';
      }

      if (isInvalidDayOfMonth(executablePatterns[3])) {
        throw patterns[3] + ' is a invalid expression for day of month';
      }

      if (isInvalidMonth(executablePatterns[4])) {
        throw patterns[4] + ' is a invalid expression for month';
      }

      if (isInvalidWeekDay(executablePatterns[5])) {
        throw patterns[5] + ' is a invalid expression for week day';
      }
    }

    function validate(pattern){
      if (typeof pattern !== 'string'){
        throw 'pattern must be a string!';
      }

      var patterns = pattern.split(' ');
      var executablePattern = convertExpression(pattern);
      var executablePatterns = executablePattern.split(' ');

      if(patterns.length === 5){
        patterns = ['0'].concat(patterns);
      }

      validateFields(patterns, executablePatterns);
    }

    return validate;
  })();

  var domain;

  // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).
  function EventHandlers() {}
  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }

  // nodejs oddity
  // require('events') === require('events').EventEmitter
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.usingDomains = false;

  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function() {
    this.domain = null;
    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active && !(this instanceof domain.Domain)) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n))
      { throw new TypeError('"n" argument must be a positive number'); }
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined)
      { return EventEmitter.defaultMaxListeners; }
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };

  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn)
      { handler.call(self); }
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        { listeners[i].call(self); }
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn)
      { handler.call(self, arg1); }
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        { listeners[i].call(self, arg1); }
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn)
      { handler.call(self, arg1, arg2); }
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        { listeners[i].call(self, arg1, arg2); }
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn)
      { handler.call(self, arg1, arg2, arg3); }
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        { listeners[i].call(self, arg1, arg2, arg3); }
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn)
      { handler.apply(self, args); }
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        { listeners[i].apply(self, args); }
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var arguments$1 = arguments;

    var er, handler, len, args, i, events, domain;
    var doError = (type === 'error');

    events = this._events;
    if (events)
      { doError = (doError && events.error == null); }
    else if (!doError)
      { return false; }

    domain = this.domain;

    // If there is no 'error' event listener then throw.
    if (doError) {
      er = arguments[1];
      if (domain) {
        if (!er)
          { er = new Error('Uncaught, unspecified "error" event'); }
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }

    handler = events[type];

    if (!handler)
      { return false; }

    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          { args[i - 1] = arguments$1[i]; }
        emitMany(handler, isFn, this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    if (typeof listener !== 'function')
      { throw new TypeError('"listener" argument must be a function'); }

    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type,
                    listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] :
                                            [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }

      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + type + ' listeners added. ' +
                              'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }
  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function')
      { throw new TypeError('"listener" argument must be a function'); }
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        if (typeof listener !== 'function')
          { throw new TypeError('"listener" argument must be a function'); }
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        if (typeof listener !== 'function')
          { throw new TypeError('"listener" argument must be a function'); }

        events = this._events;
        if (!events)
          { return this; }

        list = events[type];
        if (!list)
          { return this; }

        if (list === listener || (list.listener && list.listener === listener)) {
          if (--this._eventsCount === 0)
            { this._events = new EventHandlers(); }
          else {
            delete events[type];
            if (events.removeListener)
              { this.emit('removeListener', type, list.listener || listener); }
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length; i-- > 0;) {
            if (list[i] === listener ||
                (list[i].listener && list[i].listener === listener)) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            { return this; }

          if (list.length === 1) {
            list[0] = undefined;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type];
            }
          } else {
            spliceOne(list, position);
          }

          if (events.removeListener)
            { this.emit('removeListener', type, originalListener || listener); }
        }

        return this;
      };

  EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events;

        events = this._events;
        if (!events)
          { return this; }

        // not listening for removeListener, no need to emit
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              { this._events = new EventHandlers(); }
            else
              { delete events[type]; }
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          for (var i = 0, key; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') { continue; }
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          do {
            this.removeListener(type, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }

        return this;
      };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;

    if (!events)
      { ret = []; }
    else {
      evlistener = events[type];
      if (!evlistener)
        { ret = []; }
      else if (typeof evlistener === 'function')
        { ret = [evlistener.listener || evlistener]; }
      else
        { ret = unwrapListeners(evlistener); }
    }

    return ret;
  };

  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };

  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      { list[i] = list[k]; }
    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);
    while (i--)
      { copy[i] = arr[i]; }
    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  function matchPattern(pattern, value){
    if( pattern.indexOf(',') !== -1 ){
      var patterns = pattern.split(',');
      return patterns.indexOf(value.toString()) !== -1;
    }
    return pattern === value.toString();
  }

  function mustRun(task, date){
    var runInSecond = matchPattern(task.expressions[0], date.getSeconds());
    var runOnMinute = matchPattern(task.expressions[1], date.getMinutes());
    var runOnHour = matchPattern(task.expressions[2], date.getHours());
    var runOnDayOfMonth = matchPattern(task.expressions[3], date.getDate());
    var runOnMonth = matchPattern(task.expressions[4], date.getMonth() + 1);
    var runOnDayOfWeek = matchPattern(task.expressions[5], date.getDay());
    
    var runOnDay = false;
    var delta = task.initialPattern.length === 6 ? 0 : -1;
    
    if (task.initialPattern[3 + delta] === '*') {
      runOnDay = runOnDayOfWeek;
    } else if (task.initialPattern[5 + delta] === '*') {
      runOnDay = runOnDayOfMonth;
    } else {
      runOnDay = runOnDayOfMonth || runOnDayOfWeek;
    }
    
    return runInSecond && runOnMinute && runOnHour && runOnDay && runOnMonth;
  }

  function Task(pattern, execution){
    var this$1 = this;

    patternValidation(pattern);
    this.initialPattern = pattern.split(' ');
    this.pattern = convertExpression(pattern);
    this.execution = execution;
    this.expressions = this.pattern.split(' ');
    
    EventEmitter.EventEmitter.call(this);
    
    this.update = function (date) {
      if(mustRun(this$1, date)){
        new Promise(function (resolve, reject) {
          this$1.emit('started', this$1);
          var ex = this$1.execution();
          if(ex instanceof Promise){
            ex.then(resolve).catch(reject);
          } else {
            resolve();
          }
        }).then(function () {
          this$1.emit('done', this$1);
        }).catch(function (error) {
          console.error(error);
          this$1.emit('failed', error);
        }); 
      }
    };
  }

  Task.prototype = EventEmitter.EventEmitter.prototype;
  var task = Task;

  var offsets = {
  	"Etc/GMT+12": 720,
  	"Pacific/Pago_Pago": 660,
  	"Pacific/Midway": 660,
  	"Pacific/Honolulu": 600,
  	"America/Juneau": 540,
  	"America/Los_Angeles": 480,
  	"America/Tijuana": 480,
  	"America/Phoenix": 420,
  	"America/Chihuahua": 420,
  	"America/Mazatlan": 420,
  	"America/Denver": 420,
  	"America/Guatemala": 360,
  	"America/Chicago": 360,
  	"America/Mexico_City": 360,
  	"America/Monterrey": 360,
  	"America/Regina": 360,
  	"America/Bogota": 300,
  	"America/New_York": 300,
  	"America/Indiana/Indianapolis": 300,
  	"America/Lima": 300,
  	"America/Halifax": 240,
  	"America/Caracas": 240,
  	"America/Guyana": 240,
  	"America/La_Paz": 240,
  	"America/Puerto_Rico": 240,
  	"America/Santiago": 240,
  	"America/St_Johns": 210,
  	"America/Sao_Paulo": 180,
  	"America/Argentina/Buenos_Aires": 180,
  	"America/Godthab": 180,
  	"America/Montevideo": 180,
  	"Atlantic/South_Georgia": 120,
  	"Atlantic/Azores": 60,
  	"Atlantic/Cape_Verde": 60,
  	"Africa/Casablanca": 0,
  	"Europe/London": 0,
  	"Europe/Lisbon": 0,
  	"Africa/Monrovia": 0,
  	"Etc/UTC": 0,
  	"Europe/Amsterdam": -60,
  	"Europe/Belgrade": -60,
  	"Europe/Berlin": -60,
  	"Europe/Zurich": -60,
  	"Europe/Bratislava": -60,
  	"Europe/Brussels": -60,
  	"Europe/Budapest": -60,
  	"Europe/Copenhagen": -60,
  	"Europe/Dublin": -60,
  	"Europe/Ljubljana": -60,
  	"Europe/Madrid": -60,
  	"Europe/Paris": -60,
  	"Europe/Prague": -60,
  	"Europe/Rome": -60,
  	"Europe/Sarajevo": -60,
  	"Europe/Skopje": -60,
  	"Europe/Stockholm": -60,
  	"Europe/Vienna": -60,
  	"Europe/Warsaw": -60,
  	"Africa/Algiers": -60,
  	"Europe/Zagreb": -60,
  	"Europe/Athens": -120,
  	"Europe/Bucharest": -120,
  	"Africa/Cairo": -120,
  	"Africa/Harare": -120,
  	"Europe/Helsinki": -120,
  	"Asia/Jerusalem": -120,
  	"Europe/Kaliningrad": -120,
  	"Europe/Kiev": -120,
  	"Africa/Johannesburg": -120,
  	"Europe/Riga": -120,
  	"Europe/Sofia": -120,
  	"Europe/Tallinn": -120,
  	"Europe/Vilnius": -120,
  	"Asia/Baghdad": -180,
  	"Europe/Istanbul": -180,
  	"Asia/Kuwait": -180,
  	"Europe/Minsk": -180,
  	"Europe/Moscow": -180,
  	"Africa/Nairobi": -180,
  	"Asia/Riyadh": -180,
  	"Europe/Volgograd": -180,
  	"Asia/Tehran": -210,
  	"Asia/Muscat": -240,
  	"Asia/Baku": -240,
  	"Europe/Samara": -240,
  	"Asia/Tbilisi": -240,
  	"Asia/Yerevan": -240,
  	"Asia/Kabul": -270,
  	"Asia/Yekaterinburg": -300,
  	"Asia/Karachi": -300,
  	"Asia/Tashkent": -300,
  	"Asia/Kolkata": -330,
  	"Asia/Colombo": -330,
  	"Asia/Kathmandu": -345,
  	"Asia/Almaty": -360,
  	"Asia/Dhaka": -360,
  	"Asia/Urumqi": -360,
  	"Asia/Rangoon": -390,
  	"Asia/Bangkok": -420,
  	"Asia/Jakarta": -420,
  	"Asia/Krasnoyarsk": -420,
  	"Asia/Novosibirsk": -420,
  	"Asia/Shanghai": -480,
  	"Asia/Chongqing": -480,
  	"Asia/Hong_Kong": -480,
  	"Asia/Irkutsk": -480,
  	"Asia/Kuala_Lumpur": -480,
  	"Australia/Perth": -480,
  	"Asia/Singapore": -480,
  	"Asia/Taipei": -480,
  	"Asia/Ulaanbaatar": -480,
  	"Asia/Tokyo": -540,
  	"Asia/Seoul": -540,
  	"Asia/Yakutsk": -540,
  	"Australia/Adelaide": -570,
  	"Australia/Darwin": -570,
  	"Australia/Brisbane": -600,
  	"Australia/Melbourne": -600,
  	"Pacific/Guam": -600,
  	"Australia/Hobart": -600,
  	"Pacific/Port_Moresby": -600,
  	"Australia/Sydney": -600,
  	"Asia/Vladivostok": -600,
  	"Asia/Magadan": -660,
  	"Pacific/Noumea": -660,
  	"Pacific/Guadalcanal": -660,
  	"Asia/Srednekolymsk": -660,
  	"Pacific/Auckland": -720,
  	"Pacific/Fiji": -720,
  	"Asia/Kamchatka": -720,
  	"Pacific/Majuro": -720,
  	"Pacific/Chatham": -765,
  	"Pacific/Tongatapu": -780,
  	"Pacific/Apia": -780,
  	"Pacific/Fakaofo": -780
  };

  var offsets$1 = /*#__PURE__*/Object.freeze({
    'default': offsets
  });

  var offsets$2 = getCjsExportFromNamespace(offsets$1);

  var tzOffset = (function() {
      
      function offsetOf(timezone){
          var offset = offsets$2[timezone];
          if(offset != undefined && offset != null){
              return offset;
          } else {
              throw Error("Invalid timezone "+ timezone);
          }
      }

      function removeOffset(date){
          var currentOffset = date.getTimezoneOffset() * -60000;
          return date.getTime() - currentOffset;
      }

      function timeAt(date, timezone){
          var timeUtc = removeOffset(date);
          var offset = offsetOf(timezone) * -60000;
          return new Date(timeUtc + offset);
      }

      return {
          offsetOf: offsetOf,
          removeOffset: removeOffset,
          timeAt: timeAt
      };
  })();

  /**
  * Creates a new scheduled task.
  *
  * @param {Task} task - task to schedule.
  * @param {*} options - task options.
  */
  function ScheduledTask(task, options) {
    var this$1 = this;

    var timezone = options.timezone;
    
    /**
    * Starts updating the task.
    *
    * @returns {ScheduledTask} instance of this task.
    */
    this.start = function () {
      this$1.status = 'scheduled';
      if (this$1.task && !this$1.tick) {
        this$1.tick = setTimeout(this$1.task, 1000 - new Date().getMilliseconds() + 1);
      }
      
      return this$1;
    };
    
    /**
    * Stops updating the task.
    *
    * @returns {ScheduledTask} instance of this task.
    */
    this.stop = function () {
      this$1.status = 'stoped';
      if (this$1.tick) {
        clearTimeout(this$1.tick);
        this$1.tick = null;
      }
      
      return this$1;
    };
    
    /**
    * Returns the current task status.
    *
    * @returns {string} current task status.
    * The return may be:
    * - scheduled: when a task is scheduled and waiting to be executed.
    * - running: the task status while the task is executing. 
    * - stoped: when the task is stoped.
    * - destroyed: whe the task is destroyed, in that status the task cannot be re-started.
    * - failed: a task is maker as failed when the previous execution fails.
    */
    this.getStatus = function () {
      return this$1.status;
    };
    
    /**
    * Destroys the scheduled task.
    */
    this.destroy = function () {
      this$1.stop();
      this$1.status = 'destroyed';
      
      this$1.task = null;
    };
    
    task.on('started', function () {
      this$1.status = 'running';
    });
    
    task.on('done', function () {
      this$1.status = 'scheduled';
    });
    
    task.on('failed', function () {
      this$1.status = 'failed';
    });
    
    this.task = function () {
      var date = new Date();
      if(timezone){
        date = tzOffset.timeAt(date, timezone);
      }
      this$1.tick = setTimeout(this$1.task, 1000 - date.getMilliseconds() + 1);
      task.update(date);
    };
    
    this.tick = null;
    
    if (options.scheduled !== false) {
      this.start();
    }
  }

  var scheduledTask = ScheduledTask;

  var nodeCron = (function () {

    /**
     * Creates a new task to execute given function when the cron
     *  expression ticks.
     *
     * @param {string} expression - cron expression.
     * @param {Function} func - task to be executed.
     * @param {Object} options - a set of options for the scheduled task:
     *    - scheduled <boolean>: if a schaduled task is ready and running to be 
     *      performed when the time mach with the cron excpression.
     *    - timezone <string>: the tiemzone to execute the tasks.
     * 
     *    Example: 
     *    {
     *      "scheduled": true,
     *      "timezone": "America/Sao_Paulo"
     *    } 
     * 
     * @returns {ScheduledTask} update function.
     */
    function createTask(expression, func, options) {
      // Added for immediateStart depreciation
      if(typeof options === 'boolean'){
        console.warn('DEPRECIATION: imediateStart is deprecated and will be removed soon in favor of the options param.');
        options = {
          scheduled: options
        };
      }
      
      if(!options){
        options = {
          scheduled: true
        };
      }

      var task$1 = new task(expression, func);
      return new scheduledTask(task$1, options);
    }

    function validate(expression) {
      try {
        patternValidation(expression);
      } catch(e) {
        return false;
      }

      return true;
    }

    return {
      schedule: createTask,
      validate: validate
    };
  })();

  var Timer = /*@__PURE__*/(function (Worker) {
    function Timer(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._interval = null;
      this._schedule = null;

      this.setInterval(options.interval);
      this.setSchedule(options.schedule);
    }

    if ( Worker ) Timer.__proto__ = Worker;
    Timer.prototype = Object.create( Worker && Worker.prototype );
    Timer.prototype.constructor = Timer;

    Timer.prototype.getOptions = function getOptions () {
      return Object.assign(Worker.prototype.getOptions.call(this), {
        interval: this._interval,
        schedule: this._schedule
      });
    };

    Timer.prototype.getInterval = function getInterval () {
      return this._interval;
    };

    Timer.prototype.setInterval = function setInterval (value) {
      if ( value === void 0 ) value = null;

      this._interval = value;
      return this;
    };

    Timer.prototype.getSchedule = function getSchedule () {
      return this._schedule;
    };

    Timer.prototype.setSchedule = function setSchedule (value) {
      if ( value === void 0 ) value = null;

      this._schedule = value;
      return this;
    };

    Timer.prototype.start = function start (mode) {
      if ( mode === void 0 ) mode = 1;

      if ((mode & 1) === 0) {
        return;
      }

      if (this._schedule !== null) {
        this.executeSchedule();
      }

      if (this._interval !== null) {
        this.executeInterval();
      }

      if ((mode & 2) === 2) {
        this.execute({
          immediate: true
        });
      }
    };

    Timer.prototype.execute = function execute (box) {
      var data = this.filter(box);
      this.handle(box, data);
    };

    Timer.prototype.executeInterval = function executeInterval () {
      var interval = typeof this._interval === 'number' ?
        ({ default: this._interval }) :
        this._interval;

      var names = Object.keys(interval);
      var name = null;

      for (var i = 0; i < names.length; i += 1) {
        name = names[i];
        this.makeInterval(name, interval[name]);
      }
    };

    Timer.prototype.executeSchedule = function executeSchedule () {
      var schedule = typeof this._schedule === 'string' ?
        ({ default: this._schedule }) :
        this._schedule;

      var names = Object.keys(schedule);
      var name = null;

      for (var i = 0; i < names.length; i += 1) {
        name = names[i];
        this.makeSchedule(name, schedule[name]);
      }
    };

    Timer.prototype.makeInterval = function makeInterval (name, interval) {
      var this$1 = this;

      setInterval(function () {
        this$1.log('info', 'interval', name, interval);

        this$1.execute({
          interval: name
        });
      }, interval);
    };

    Timer.prototype.makeSchedule = function makeSchedule (name, schedule) {
      var this$1 = this;

      nodeCron.schedule(schedule, function () {
        this$1.log('info', 'schedule', name, schedule);

        this$1.execute({
          schedule: name
        });
      });
    };

    return Timer;
  }(Worker));

  var Unifier = /*@__PURE__*/(function (Worker) {
    function Unifier(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._collect = null;
      this._name = null;
      this._sync = null;

      this.setCollect(options.collect);
      this.setName(options.name);
      this.setSync(options.sync);
    }

    if ( Worker ) Unifier.__proto__ = Worker;
    Unifier.prototype = Object.create( Worker && Worker.prototype );
    Unifier.prototype.constructor = Unifier;

    Unifier.prototype.getOptions = function getOptions () {
      return Object.assign(Worker.prototype.getOptions.call(this), {
        collect: this._collect,
        name: this._name
      });
    };

    Unifier.prototype.getCollect = function getCollect () {
      return this._collect;
    };

    Unifier.prototype.setCollect = function setCollect (value) {
      if ( value === void 0 ) value = false;

      this._collect = value;
      return this;
    };

    Unifier.prototype.getName = function getName () {
      return this._name;
    };

    Unifier.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = 'default';

      this._name = value;
      return this;
    };

    Unifier.prototype.getSync = function getSync () {
      return this._sync;
    };

    Unifier.prototype.setSync = function setSync (value) {
      if ( value === void 0 ) value = false;

      this._sync = value;
      return this;
    };

    Unifier.prototype.act = function act (box, data, callback) {
      var unify = box.unify[this._name];
      unify.count += 1;

      if (this._collect === true) {
        unify.data = unify.data || [];

        if (unify.empty === false) {
          var index = typeof data.index === 'undefined' ?
            unify.data.length : data.index;

          unify.data[index] = data;
        }
      }

      var pass = unify.empty === true ||
        unify.count % unify.total === 0;

      this.log('info', box, data, unify);

      if (pass === false) {
        if (this._sync) {
          callback();
        }
      } else if (pass === true) {
        if (this._collect === true) {
          data = unify.data;
          delete unify.data;
        }

        if (this._wrap === true) {
          box = box.box;
        }

        this.pass(box, data, callback);
      }
    };

    Unifier.prototype.decide = function decide (box, data) {
      if (this._decide) {
        return this._decide(box, data);
      }

      return typeof box.unify !== 'undefined';
    };

    Unifier.prototype.err = function err (box, error, callback) {
      this.act(box, error, callback);
    };

    return Unifier;
  }(Worker));



  var index = /*#__PURE__*/Object.freeze({
    Broadcaster: Broadcaster,
    Builder: Builder,
    Manager: Manager,
    Queuer: Queuer,
    Router: Router,
    Slicer: Slicer,
    Streamer: Streamer,
    Timer: Timer,
    Unifier: Unifier,
    Worker: Worker
  });

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */
  var Symbol$1 = root.Symbol;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$1 = Array.isArray;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$1.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag$1 && symToStringTag$1 in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : baseSlice(array, start, end);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsZWJ = '\\u200d';

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = '\\ud800-\\udfff',
      rsComboMarksRange$1 = '\\u0300-\\u036f',
      reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange$1 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo = '[' + rsComboRange$1 + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$1 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);

      var strSymbols = hasUnicode(string)
        ? stringToArray(string)
        : undefined;

      var chr = strSymbols
        ? strSymbols[0]
        : string.charAt(0);

      var trailing = strSymbols
        ? castSlice(strSymbols, 1).join('')
        : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = createCaseFirst('toUpperCase');

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsComboMarksRange$2 = '\\u0300-\\u036f',
      reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
      rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;

  /** Used to compose unicode capture groups. */
  var rsCombo$1 = '[' + rsComboRange$2 + ']';

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo$1, 'g');

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
  }

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$2 = '\\ud800-\\udfff',
      rsComboMarksRange$3 = '\\u0300-\\u036f',
      reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
      rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange$2 = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo$2 = '[' + rsComboRange$3 + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
      rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
      rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
      rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ$2 = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod$1 = rsModifier$1 + '?',
      rsOptVar$1 = '[' + rsVarRange$2 + ']?',
      rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
      rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }

  /** Used to compose unicode capture groups. */
  var rsApos$1 = "['\u2019]";

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos$1, 'g');

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
  }

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });

  var SqlString_1 = createCommonjsModule(function (module, exports) {
  var SqlString  = exports;

  var ID_GLOBAL_REGEXP    = /`/g;
  var QUAL_GLOBAL_REGEXP  = /\./g;
  var CHARS_GLOBAL_REGEXP = /[\0\b\t\n\r\x1a\"\'\\]/g; // eslint-disable-line no-control-regex
  var CHARS_ESCAPE_MAP    = {
    '\0'   : '\\0',
    '\b'   : '\\b',
    '\t'   : '\\t',
    '\n'   : '\\n',
    '\r'   : '\\r',
    '\x1a' : '\\Z',
    '"'    : '\\"',
    '\''   : '\\\'',
    '\\'   : '\\\\'
  };

  SqlString.escapeId = function escapeId(val, forbidQualified) {
    if (Array.isArray(val)) {
      var sql = '';

      for (var i = 0; i < val.length; i++) {
        sql += (i === 0 ? '' : ', ') + SqlString.escapeId(val[i], forbidQualified);
      }

      return sql;
    } else if (forbidQualified) {
      return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``') + '`';
    } else {
      return '`' + String(val).replace(ID_GLOBAL_REGEXP, '``').replace(QUAL_GLOBAL_REGEXP, '`.`') + '`';
    }
  };

  SqlString.escape = function escape(val, stringifyObjects, timeZone) {
    if (val === undefined || val === null) {
      return 'NULL';
    }

    switch (typeof val) {
      case 'boolean': return (val) ? 'true' : 'false';
      case 'number': return val + '';
      case 'object':
        if (val instanceof Date) {
          return SqlString.dateToString(val, timeZone || 'local');
        } else if (Array.isArray(val)) {
          return SqlString.arrayToList(val, timeZone);
        } else if (Buffer.isBuffer(val)) {
          return SqlString.bufferToString(val);
        } else if (typeof val.toSqlString === 'function') {
          return String(val.toSqlString());
        } else if (stringifyObjects) {
          return escapeString(val.toString());
        } else {
          return SqlString.objectToValues(val, timeZone);
        }
      default: return escapeString(val);
    }
  };

  SqlString.arrayToList = function arrayToList(array, timeZone) {
    var sql = '';

    for (var i = 0; i < array.length; i++) {
      var val = array[i];

      if (Array.isArray(val)) {
        sql += (i === 0 ? '' : ', ') + '(' + SqlString.arrayToList(val, timeZone) + ')';
      } else {
        sql += (i === 0 ? '' : ', ') + SqlString.escape(val, true, timeZone);
      }
    }

    return sql;
  };

  SqlString.format = function format(sql, values, stringifyObjects, timeZone) {
    if (values == null) {
      return sql;
    }

    if (!(values instanceof Array || Array.isArray(values))) {
      values = [values];
    }

    var chunkIndex        = 0;
    var placeholdersRegex = /\?+/g;
    var result            = '';
    var valuesIndex       = 0;
    var match;

    while (valuesIndex < values.length && (match = placeholdersRegex.exec(sql))) {
      var len = match[0].length;

      if (len > 2) {
        continue;
      }

      var value = len === 2
        ? SqlString.escapeId(values[valuesIndex])
        : SqlString.escape(values[valuesIndex], stringifyObjects, timeZone);

      result += sql.slice(chunkIndex, match.index) + value;
      chunkIndex = placeholdersRegex.lastIndex;
      valuesIndex++;
    }

    if (chunkIndex === 0) {
      // Nothing was replaced
      return sql;
    }

    if (chunkIndex < sql.length) {
      return result + sql.slice(chunkIndex);
    }

    return result;
  };

  SqlString.dateToString = function dateToString(date, timeZone) {
    var dt = new Date(date);

    if (isNaN(dt.getTime())) {
      return 'NULL';
    }

    var year;
    var month;
    var day;
    var hour;
    var minute;
    var second;
    var millisecond;

    if (timeZone === 'local') {
      year        = dt.getFullYear();
      month       = dt.getMonth() + 1;
      day         = dt.getDate();
      hour        = dt.getHours();
      minute      = dt.getMinutes();
      second      = dt.getSeconds();
      millisecond = dt.getMilliseconds();
    } else {
      var tz = convertTimezone(timeZone);

      if (tz !== false && tz !== 0) {
        dt.setTime(dt.getTime() + (tz * 60000));
      }

      year       = dt.getUTCFullYear();
      month       = dt.getUTCMonth() + 1;
      day         = dt.getUTCDate();
      hour        = dt.getUTCHours();
      minute      = dt.getUTCMinutes();
      second      = dt.getUTCSeconds();
      millisecond = dt.getUTCMilliseconds();
    }

    // YYYY-MM-DD HH:mm:ss.mmm
    var str = zeroPad(year, 4) + '-' + zeroPad(month, 2) + '-' + zeroPad(day, 2) + ' ' +
      zeroPad(hour, 2) + ':' + zeroPad(minute, 2) + ':' + zeroPad(second, 2) + '.' +
      zeroPad(millisecond, 3);

    return escapeString(str);
  };

  SqlString.bufferToString = function bufferToString(buffer) {
    return 'X' + escapeString(buffer.toString('hex'));
  };

  SqlString.objectToValues = function objectToValues(object, timeZone) {
    var sql = '';

    for (var key in object) {
      var val = object[key];

      if (typeof val === 'function') {
        continue;
      }

      sql += (sql.length === 0 ? '' : ', ') + SqlString.escapeId(key) + ' = ' + SqlString.escape(val, true, timeZone);
    }

    return sql;
  };

  SqlString.raw = function raw(sql) {
    if (typeof sql !== 'string') {
      throw new TypeError('argument sql must be a string');
    }

    return {
      toSqlString: function toSqlString() { return sql; }
    };
  };

  function escapeString(val) {
    var chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex = 0;
    var escapedVal = '';
    var match;

    while ((match = CHARS_GLOBAL_REGEXP.exec(val))) {
      escapedVal += val.slice(chunkIndex, match.index) + CHARS_ESCAPE_MAP[match[0]];
      chunkIndex = CHARS_GLOBAL_REGEXP.lastIndex;
    }

    if (chunkIndex === 0) {
      // Nothing was escaped
      return "'" + val + "'";
    }

    if (chunkIndex < val.length) {
      return "'" + escapedVal + val.slice(chunkIndex) + "'";
    }

    return "'" + escapedVal + "'";
  }

  function zeroPad(number, length) {
    number = number.toString();
    while (number.length < length) {
      number = '0' + number;
    }

    return number;
  }

  function convertTimezone(tz) {
    if (tz === 'Z') {
      return 0;
    }

    var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
    if (m) {
      return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;
    }
    return false;
  }
  });

  var sqlstring = SqlString_1;

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject$1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /** Used for built-in method references. */
  var funcProto = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root, 'Map');

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map$1 || ListCache),
      'string': new Hash
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
  }

  /**
   * Converts `value` to a property path array.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Util
   * @param {*} value The value to convert.
   * @returns {Array} Returns the new property path array.
   * @example
   *
   * _.toPath('a.b.c');
   * // => ['a', 'b', 'c']
   *
   * _.toPath('a[0].b.c');
   * // => ['a', '0', 'b', 'c']
   */
  function toPath(value) {
    if (isArray$1(value)) {
      return arrayMap(value, toKey);
    }
    return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
  }

  var id$1 = 0;

  var Snippet = function Snippet(options) {
    if ( options === void 0 ) options = {};

    this._allow = null;
    this._args = null;
    this._builder = null;
    this._escape = null;
    this._id = null;
    this._infix = null;
    this._name = null;
    this._parens = null;
    this._postfix = null;
    this._prefix = null;

    this.setAllow(options.allow);
    this.setArgs(options.args);
    this.setBuilder(options.builder);
    this.setEscape(options.escape);
    this.setId(options.id);
    this.setInfix(options.infix);
    this.setName(options.name);
    this.setParens(options.parens);
    this.setPostfix(options.postfix);
    this.setPrefix(options.prefix);
  };

  Snippet.prototype.clone = function clone () {
    var options = this.getOptions();

    options.args = options.args.map(function (snippet) {
      return snippet instanceof Snippet ?
        snippet.clone() : snippet;
    });

    return new this.constructor(options);
  };

  Snippet.prototype.getOptions = function getOptions () {
    return {
      allow: this._allow,
      args: this._args,
      builder: this._builder,
      escape: this._escape,
      id: this._id,
      infix: this._infix,
      name: this._name,
      parens: this._parens,
      postfix: this._postfix,
      prefix: this._prefix
    };
  };

  Snippet.prototype.getAllow = function getAllow () {
    return this._allow;
  };

  Snippet.prototype.setAllow = function setAllow (value) {
      if ( value === void 0 ) value = null;

    this._allow = value;
    return this;
  };

  Snippet.prototype.getArg = function getArg (index) {
    return this._args[index];
  };

  Snippet.prototype.setArg = function setArg (index, value) {
    this.args[index] = value;
    return this;
  };

  Snippet.prototype.getArgs = function getArgs () {
    return this._args;
  };

  Snippet.prototype.setArgs = function setArgs (value) {
      if ( value === void 0 ) value = [];

    this._args = value;
    return this;
  };

  Snippet.prototype.getBuilder = function getBuilder () {
    return this._builder;
  };

  Snippet.prototype.setBuilder = function setBuilder (value) {
      if ( value === void 0 ) value = null;

    this._builder = value;
    return this;
  };

  Snippet.prototype.getEscape = function getEscape () {
    return this._escape;
  };

  Snippet.prototype.setEscape = function setEscape (value) {
      if ( value === void 0 ) value = '';

    this._escape = value;
    return this;
  };

  Snippet.prototype.getId = function getId () {
    return this._id;
  };

  Snippet.prototype.setId = function setId (value) {
      if ( value === void 0 ) value = ++id$1;

    this._id = value;
    return this;
  };

  Snippet.prototype.getInfix = function getInfix () {
    return this._infix;
  };

  Snippet.prototype.setInfix = function setInfix (value) {
      if ( value === void 0 ) value = ', ';

    this._infix = value;
    return this;
  };

  Snippet.prototype.getName = function getName () {
    return this._name;
  };

  Snippet.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = null;

    this._name = value;
    return this;
  };

  Snippet.prototype.getParens = function getParens () {
    return this._parens;
  };

  Snippet.prototype.setParens = function setParens (value) {
      if ( value === void 0 ) value = false;

    this._parens = value;
    return this;
  };

  Snippet.prototype.getPostfix = function getPostfix () {
    return this._postfix;
  };

  Snippet.prototype.setPostfix = function setPostfix (value) {
      if ( value === void 0 ) value = '';

    this._postfix = value;
    return this;
  };

  Snippet.prototype.getPrefix = function getPrefix () {
    return this._prefix;
  };

  Snippet.prototype.setPrefix = function setPrefix (value) {
      if ( value === void 0 ) value = '';

    this._prefix = value;
    return this;
  };

  Snippet.prototype.allow = function allow (value) {
    return this.setAllow(value);
  };

  Snippet.prototype.escape = function escape () {
    return this.setEscape('value');
  };

  Snippet.prototype.escapeId = function escapeId () {
    return this.setEscape('id');
  };

  Snippet.prototype.parens = function parens () {
    return this.setParens(true);
  };

  Snippet.prototype.concat = function concat (left, right) {
    var hasDouble = left[left.length - 1] === ' ' && right[0] === ' ';
    return left + (hasDouble ? right.slice(1) : right);
  };

  Snippet.prototype.find = function find (compare) {
    var result = [];

    if (compare(this) === true) {
      result[result.length] = this;
    }

    return this.findRecursive(result, this._args, compare);
  };

  Snippet.prototype.findRecursive = function findRecursive (result, args, compare) {
    var snippet = null;

    for (var i = 0; i < args.length; i += 1) {
      snippet = args[i];

      if (snippet instanceof Snippet) {
        result = result.concat(snippet.find(compare));
      }
    }

    return result;
  };

  Snippet.prototype.isAllowed = function isAllowed (box, data) {
    return this.resolveValue(box, data, this._allow);
  };

  Snippet.prototype.resolve = function resolve (box, data) {
    var isAllowed = this.isAllowed(box, data);

    if (isAllowed === false) {
      return null;
    }

    var string = '';

    string = this.concat(string, this._prefix);
    string = this.concat(string, this.resolveInner(box, data));
    string = this.concat(string, this._postfix);

    return string;
  };

  Snippet.prototype.resolveEscape = function resolveEscape (value, type) {
    if (type === 'value') {
      return sqlstring.escape(value);
    }

    if (type === 'id') {
      return sqlstring.escapeId(value);
    }

    return value;
  };

  Snippet.prototype.resolveInner = function resolveInner (box, data) {
    var string = '';

    var count = 0;
    var value = null;

    for (var i = 0; i < this._args.length; i += 1) {
      value = this.resolveValue(box, data, this._args[i]);

      if (value === null) {
        continue;
      }

      if (count > 0) {
        string = this.concat(string, this._infix);
      }

      string = this.concat(string, value);

      count += 1;
    }

    return this.resolveParens(string, this._parens);
  };

  Snippet.prototype.resolveParens = function resolveParens (value, parens) {
    return parens && value ? ("(" + value + ")") : value;
  };

  Snippet.prototype.resolveValue = function resolveValue (box, data, value) {
    if (value === null || typeof value === 'undefined') {
      return value;
    }

    if (typeof value === 'function') {
      return this.resolveValue(box, data, value(box, data));
    }

    if (typeof value === 'string') {
      return this.resolveEscape(value, this._escape);
    }

    if (value instanceof Snippet) {
      return this.resolveValue(box, data, value.resolve(box, data));
    }

    return value;
  };

  Snippet.prototype.selector = function selector (path, index) {
    path = toPath(path);

    var result = [];

    if (
      path[0] === this._name ||
      path[0] === index ||
      path[0] === '*'
    ) {
      if (path.length === 1) {
        result[result.length] = this;
      } else {
        result = result.concat(this.selector(path.slice(1)));
      }

      return result;
    }

    return this.selectorRecursive(result, this._args, path);
  };

  Snippet.prototype.selectorRecursive = function selectorRecursive (result, list, path) {
    var snippet = null;

    for (var i = 0; i < list.length; i += 1) {
      snippet = list[i];

      if (snippet instanceof Snippet) {
        result = result.concat(snippet.selector(path, String(i)));
      }
    }

    return result;
  };

  Snippet.prototype.set = function set (path, index, value) {
    var list = this.selector(path);

    for (var i = 0; i < list.length; i += 1) {
      list[i].setItem(index, value);
    }

    return list;
  };

  /*
  SELECT DISTINCT
      CONCAT(IF(LOCATE(' ', name) = 0,
                  name,
                  LEFT(name, LOCATE(' ', name) - 1)),
              ',') AS name
  FROM
      help_topic
  WHERE
      REGEXP_LIKE(name, '^[a-z0-9\\s_]+$')
          AND (REGEXP_LIKE(description, '^Syntax:\n+[a-z0-9_]+\\(')
          OR REGEXP_LIKE(description, '^[a-z0-9_]+\\('))
  ORDER BY name;
  */

  var funcBase = [
    'ABS',
    'ACOS',
    'ADDDATE',
    'ADDTIME',
    'AES_DECRYPT',
    'AES_ENCRYPT',
    'ANY_VALUE',
    'AREA',
    'ASBINARY',
    'ASCII',
    'ASIN',
    'ASTEXT',
    'ASYMMETRIC_DECRYPT',
    'ASYMMETRIC_DERIVE',
    'ASYMMETRIC_ENCRYPT',
    'ASYMMETRIC_SIGN',
    'ASYMMETRIC_VERIFY',
    'ATAN',
    'ATAN2',
    'AVG',
    'BENCHMARK',
    'BIN',
    'BINARY',
    'BIT_AND',
    'BIT_COUNT',
    'BIT_LENGTH',
    'BIT_OR',
    'BIT_XOR',
    'BUFFER',
    'CAST',
    'CEIL',
    'CEILING',
    'CENTROID',
    'CHAR',
    'CHARACTER_LENGTH',
    'CHARSET',
    'CHAR_LENGTH',
    'COALESCE',
    'COERCIBILITY',
    'COLLATION',
    'COMPRESS',
    'CONCAT',
    'CONCAT_WS',
    'CONNECTION_ID',
    'CONTAINS',
    'CONV',
    'CONVERT',
    'CONVERT_TZ',
    'CONVEXHULL',
    'COS',
    'COT',
    'COUNT',
    'CRC32',
    'CREATE_ASYMMETRIC_PRIV_KEY',
    'CREATE_ASYMMETRIC_PUB_KEY',
    'CREATE_DH_PARAMETERS',
    'CREATE_DIGEST',
    'CROSSES',
    'CURDATE',
    'CURTIME',
    'DATABASE',
    'DATE',
    'DATEDIFF',
    'DATE_ADD',
    'DATE_FORMAT',
    'DATE_SUB',
    'DAY',
    'DAYNAME',
    'DAYOFMONTH',
    'DAYOFWEEK',
    'DAYOFYEAR',
    'DECODE',
    'DEFAULT',
    'DEGREES',
    'DES_DECRYPT',
    'DES_ENCRYPT',
    'DIMENSION',
    'DISJOINT',
    'DISTANCE',
    'ELT',
    'ENCODE',
    'ENCRYPT',
    'ENDPOINT',
    'ENUM',
    'ENVELOPE',
    'EQUALS',
    'EXP',
    'EXPORT_SET',
    'EXTERIORRING',
    'EXTRACT',
    'EXTRACTVALUE',
    'FIELD',
    'FIND_IN_SET',
    'FLOOR',
    'FORMAT',
    'FOUND_ROWS',
    'FROM_BASE64',
    'FROM_DAYS',
    'FROM_UNIXTIME',
    'GEOMCOLLFROMTEXT',
    'GEOMCOLLFROMWKB',
    'GEOMETRYCOLLECTION',
    'GEOMETRYN',
    'GEOMETRYTYPE',
    'GEOMFROMTEXT',
    'GEOMFROMWKB',
    'GET_FORMAT',
    'GET_LOCK',
    'GLENGTH',
    'GREATEST',
    'GROUP_CONCAT',
    'GTID_SUBSET',
    'GTID_SUBTRACT',
    'HEX',
    'HOUR',
    'IF',
    'IFNULL',
    'INET6_ATON',
    'INET6_NTOA',
    'INET_ATON',
    'INET_NTOA',
    'INSERT',
    'INSTR',
    'INTERIORRINGN',
    'INTERSECTS',
    'INTERVAL',
    'ISCLOSED',
    'ISEMPTY',
    'ISNULL',
    'ISSIMPLE',
    'IS_FREE_LOCK',
    'IS_IPV4',
    'IS_IPV4_COMPAT',
    'IS_IPV4_MAPPED',
    'IS_IPV6',
    'IS_USED_LOCK',
    'JSON_APPEND',
    'JSON_ARRAY',
    'JSON_ARRAY_APPEND',
    'JSON_ARRAY_INSERT',
    'JSON_CONTAINS',
    'JSON_CONTAINS_PATH',
    'JSON_DEPTH',
    'JSON_EXTRACT',
    'JSON_INSERT',
    'JSON_KEYS',
    'JSON_LENGTH',
    'JSON_MERGE',
    'JSON_OBJECT',
    'JSON_QUOTE',
    'JSON_REMOVE',
    'JSON_REPLACE',
    'JSON_SEARCH',
    'JSON_SET',
    'JSON_TYPE',
    'JSON_UNQUOTE',
    'JSON_VALID',
    'LAST_DAY',
    'LAST_INSERT_ID',
    'LCASE',
    'LEAST',
    'LEFT',
    'LENGTH',
    'LINEFROMTEXT',
    'LINEFROMWKB',
    'LINESTRING',
    'LN',
    'LOAD_FILE',
    'LOCATE',
    'LOG',
    'LOG10',
    'LOG2',
    'LOWER',
    'LPAD',
    'LTRIM',
    'MAKEDATE',
    'MAKETIME',
    'MAKE_SET',
    'MASTER_POS_WAIT',
    'MAX',
    'MBRCONTAINS',
    'MBRCOVEREDBY',
    'MBRCOVERS',
    'MBRDISJOINT',
    'MBREQUAL',
    'MBREQUALS',
    'MBRINTERSECTS',
    'MBROVERLAPS',
    'MBRTOUCHES',
    'MBRWITHIN',
    'MD5',
    'MICROSECOND',
    'MID',
    'MIN',
    'MINUTE',
    'MLINEFROMTEXT',
    'MLINEFROMWKB',
    'MOD',
    'MONTH',
    'MONTHNAME',
    'MPOINTFROMTEXT',
    'MPOINTFROMWKB',
    'MPOLYFROMTEXT',
    'MPOLYFROMWKB',
    'MULTILINESTRING',
    'MULTIPOINT',
    'MULTIPOLYGON',
    'NAME_CONST',
    'NOW',
    'NULLIF',
    'NUMGEOMETRIES',
    'NUMINTERIORRINGS',
    'NUMPOINTS',
    'OCT',
    'OCTET_LENGTH',
    'OLD_PASSWORD',
    'ORD',
    'OVERLAPS',
    'PASSWORD',
    'PERIOD_ADD',
    'PERIOD_DIFF',
    'PI',
    'POINT',
    'POINTFROMTEXT',
    'POINTFROMWKB',
    'POINTN',
    'POLYFROMTEXT',
    'POLYFROMWKB',
    'POLYGON',
    'POSITION',
    'POW',
    'POWER',
    'PROCEDURE',
    'QUARTER',
    'QUOTE',
    'RADIANS',
    'RAND',
    'RANDOM_BYTES',
    'RELEASE_ALL_LOCKS',
    'RELEASE_LOCK',
    'REPEAT',
    'REPLACE',
    'REVERSE',
    'RIGHT',
    'ROUND',
    'ROW_COUNT',
    'RPAD',
    'RTRIM',
    'SCHEMA',
    'SECOND',
    'SEC_TO_TIME',
    'SESSION_USER',
    'SET',
    'SHA1',
    'SHA2',
    'SIGN',
    'SIN',
    'SLEEP',
    'SOUNDEX',
    'SPACE',
    'SQRT',
    'SRID',
    'STARTPOINT',
    'STD',
    'STDDEV',
    'STDDEV_POP',
    'STDDEV_SAMP',
    'STRCMP',
    'STR_TO_DATE',
    'ST_AREA',
    'ST_ASBINARY',
    'ST_ASGEOJSON',
    'ST_ASTEXT',
    'ST_BUFFER',
    'ST_BUFFER_STRATEGY',
    'ST_CENTROID',
    'ST_CONTAINS',
    'ST_CONVEXHULL',
    'ST_CROSSES',
    'ST_DIFFERENCE',
    'ST_DIMENSION',
    'ST_DISJOINT',
    'ST_DISTANCE',
    'ST_DISTANCE_SPHERE',
    'ST_ENDPOINT',
    'ST_ENVELOPE',
    'ST_EQUALS',
    'ST_EXTERIORRING',
    'ST_GEOHASH',
    'ST_GEOMCOLLFROMTEXT',
    'ST_GEOMCOLLFROMWKB',
    'ST_GEOMETRYN',
    'ST_GEOMETRYTYPE',
    'ST_GEOMFROMGEOJSON',
    'ST_GEOMFROMTEXT',
    'ST_GEOMFROMWKB',
    'ST_INTERIORRINGN',
    'ST_INTERSECTION',
    'ST_INTERSECTS',
    'ST_ISCLOSED',
    'ST_ISEMPTY',
    'ST_ISSIMPLE',
    'ST_ISVALID',
    'ST_LATFROMGEOHASH',
    'ST_LENGTH',
    'ST_LINEFROMTEXT',
    'ST_LINEFROMWKB',
    'ST_LONGFROMGEOHASH',
    'ST_MAKEENVELOPE',
    'ST_MLINEFROMTEXT',
    'ST_MLINEFROMWKB',
    'ST_MPOINTFROMTEXT',
    'ST_MPOINTFROMWKB',
    'ST_MPOLYFROMTEXT',
    'ST_MPOLYFROMWKB',
    'ST_NUMGEOMETRIES',
    'ST_NUMINTERIORRINGS',
    'ST_NUMPOINTS',
    'ST_OVERLAPS',
    'ST_POINTFROMGEOHASH',
    'ST_POINTFROMTEXT',
    'ST_POINTFROMWKB',
    'ST_POINTN',
    'ST_POLYFROMTEXT',
    'ST_POLYFROMWKB',
    'ST_SIMPLIFY',
    'ST_SRID',
    'ST_STARTPOINT',
    'ST_SYMDIFFERENCE',
    'ST_TOUCHES',
    'ST_UNION',
    'ST_VALIDATE',
    'ST_WITHIN',
    'ST_X',
    'ST_Y',
    'SUBDATE',
    'SUBSTR',
    'SUBSTRING',
    'SUBSTRING_INDEX',
    'SUBTIME',
    'SUM',
    'SYSDATE',
    'SYSTEM_USER',
    'TAN',
    'TIME',
    'TIMEDIFF',
    'TIMESTAMP',
    'TIMESTAMPADD',
    'TIMESTAMPDIFF',
    'TIME_FORMAT',
    'TIME_TO_SEC',
    'TOUCHES',
    'TO_BASE64',
    'TO_DAYS',
    'TO_SECONDS',
    'TRIM',
    'TRUNCATE',
    'UCASE',
    'UNCOMPRESS',
    'UNCOMPRESSED_LENGTH',
    'UNHEX',
    'UNIX_TIMESTAMP',
    'UPDATEXML',
    'UPPER',
    'USER',
    'UUID',
    'UUID_SHORT',
    'VALIDATE_PASSWORD_STRENGTH',
    'VALUES',
    'VARBINARY',
    'VARIANCE',
    'VAR_POP',
    'VAR_SAMP',
    'VERSION',
    'WAIT_FOR_EXECUTED_GTID_SET',
    'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS',
    'WEEK',
    'WEEKDAY',
    'WEEKOFYEAR',
    'WEIGHT_STRING',
    'WITHIN',
    'X',
    'Y',
    'YEAR',
    'YEARWEEK',

    'CUME_DIST',
    'DENSE_RANK',
    'FIRST_VALUE',
    'LAG',
    'LAST_VALUE',
    'LEAD',
    'NTH_VALUE',
    'NTILE',
    'PERCENT_RANK',
    'RANK',
    'ROW_NUMBER'
  ];

  /*
  SELECT
      CONCAT(help_topic.name, ',')
  FROM
      help_topic
  WHERE
      help_category_id IN (3, 15 , 19, 20, 38)
          AND NOT ((REGEXP_LIKE(description, '^Syntax:\n+[a-z0-9_]+\\(')
          OR REGEXP_LIKE(description, '^[a-z0-9_]+\\(')))
  ORDER BY name;
  */

  var alias = {
    '!=': 'notEq',
    '&': 'bitAnd',
    '*': 'multiply',
    '+': 'plus',
    '-': 'minus',
    '/': 'divide',
    '<': 'lt',
    '<<': 'bitLeft',
    '<=': 'ltEq',
    '<=>': 'safeEq',
    '=': 'eq',
    '>': 'gt',
    '>=': 'gtEq',
    '>>': 'bitRight',
    '^': 'bitXor',
    '|': 'bitOr',
    '~': 'bitInv',
  };

  var list = [
    '!=',
    '&',
    '*',
    '+',
    '-',
    '/',
    '<',
    '<<',
    '<=',
    '<=>',
    '=',
    '>',
    '>=',
    '>>',
    '^',
    '|',
    '~',

    'AND',
    'BETWEEN',
    'DIV',
    'IN',
    'IS',
    'LIKE',
    'MATCH AGAINST',
    'NOT',
    'OR',
    'REGEXP',
    'RLIKE',
    'SOUNDS LIKE',
    'XOR',

    'AS',
    'OVER',
    'UNION'
  ];

  var infixBase = list.map(function (token) {
    return {
      name: alias[token] || token,
      token: token
    };
  });

  var postfixBase = [
    'ASC',
    'DESC',

    'CURRENT ROW',
    'FOLLOWING',
    'PRECEDING',
    'RANGE',
    'ROWS',
    'UNBOUNDED FOLLOWING',
    'UNBOUNDED PRECEDING',

    'BINARY',
    'CHAR',
    'DATE',
    'DATETIME',
    'DECIMAL',
    'JSON',
    'NCHAR',
    'SIGNED',
    'TIME',
    'UNSIGNED'
  ];

  var prefixBase = [
    'DELETE',
    'INSERT',
    'REPLACE',
    'SELECT',
    'UPDATE',
    'WITH',

    'ALL',
    'DISTINCT',
    'DISTINCTROW',
    'DELAYED',
    'HIGH_PRIORITY',
    'IGNORE',
    'LOW_PRIORITY',
    'QUICK',
    'RECURSIVE',
    'STRAIGHT_JOIN',
    'SQL_CALC_FOUND_ROWS',
    'SQL_BIG_RESULT',
    'SQL_BUFFER_RESULT',
    'SQL_NO_CACHE',
    'SQL_SMALL_RESULT',

    'INTO',
    'PARTITION',
    'SET',

    'CROSS',
    'GROUP BY',
    'HAVING',
    'INNER',
    'JOIN',
    'LEFT',
    'LIMIT',
    'NATURAL',
    'ON',
    'ORDER BY',
    'OUTER',
    'PARTITION BY',
    'RIGHT',
    'USING',
    'WINDOW',
    'WHERE' ];

  var Order = /*@__PURE__*/(function (Snippet) {
    function Order(options) {
      if ( options === void 0 ) options = {};

      Snippet.call(this, options);

      this._by = null;
      this._columns = null;
      this._default = null;
      this._order = null;

      this.setBy(options.by);
      this.setColumns(options.columns);
      this.setDefault(options.default);
      this.setOrder(options.order);
    }

    if ( Snippet ) Order.__proto__ = Snippet;
    Order.prototype = Object.create( Snippet && Snippet.prototype );
    Order.prototype.constructor = Order;

    Order.prototype.getBy = function getBy () {
      return this._by;
    };

    Order.prototype.setBy = function setBy (value) {
      if ( value === void 0 ) value = null;

      this._by = value;
      return this;
    };

    Order.prototype.getColumns = function getColumns () {
      return this._columns;
    };

    Order.prototype.setColumns = function setColumns (value) {
      if ( value === void 0 ) value = [];

      this._columns = value;
      return this;
    };

    Order.prototype.getDefault = function getDefault () {
      return this._default;
    };

    Order.prototype.setDefault = function setDefault (value) {
      if ( value === void 0 ) value = '1';

      this._default = value;
      return this;
    };

    Order.prototype.getOrder = function getOrder () {
      return this._order;
    };

    Order.prototype.setOrder = function setOrder (value) {
      if ( value === void 0 ) value = null;

      this._order = value;
      return this;
    };

    Order.prototype.by = function by (value) {
      return this.setBy(value);
    };

    Order.prototype.columns = function columns (value) {
      return this.setColumns(value);
    };

    Order.prototype.default = function default$1 (value) {
      return this.setDefault(value);
    };

    Order.prototype.order = function order (value) {
      return this.setOrder(value);
    };

    Order.prototype.resolveInner = function resolveInner (box, data) {
      var columns = this.resolveValue(box, data, this._columns);
      var directions = ['ASC', 'DESC'];

      var order = this.resolveValue(box, data, this._order);
      var by = this.resolveValue(box, data, this._by);

      order = Array.isArray(order) ? order : [order];
      by = Array.isArray(by) ? by : [by];

      var column = null;
      var direction = null;
      var string = '';

      for (var i = 0; i < order.length; i += 1) {
        column = order[i];
        direction = by[i] || 'ASC';

        if (columns.indexOf(column) === -1) {
          continue;
        }

        if (directions.indexOf(direction) === -1) {
          continue;
        }

        string += string.length ? ', ' : '';
        string += column;
        string += ' ';
        string += direction;
      }

      if (string.length === 0) {
        string = this.resolveValue(box, data, this._default);
      }

      return this.resolveParens(string, this._parens);
    };

    return Order;
  }(Snippet));

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN$1(value) {
    return value !== value;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf$1(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf$1(array, value, fromIndex) {
    return value === value
      ? strictIndexOf$1(array, value, fromIndex)
      : baseFindIndex$1(array, baseIsNaN$1, fromIndex);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf$1(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf$1(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /**
   * Removes leading and trailing whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trim('  abc  ');
   * // => 'abc'
   *
   * _.trim('-_-abc-_-', '_-');
   * // => 'abc'
   *
   * _.map(['  foo  ', '  bar  '], _.trim);
   * // => ['foo', 'bar']
   */
  function trim(string, chars, guard) {
    string = toString(string);
    if (string && (guard || chars === undefined)) {
      return string.replace(reTrim, '');
    }
    if (!string || !(chars = baseToString(chars))) {
      return string;
    }
    var strSymbols = stringToArray(string),
        chrSymbols = stringToArray(chars),
        start = charsStartIndex(strSymbols, chrSymbols),
        end = charsEndIndex(strSymbols, chrSymbols) + 1;

    return castSlice(strSymbols, start, end).join('');
  }

  var Search = /*@__PURE__*/(function (Snippet) {
    function Search(options) {
      if ( options === void 0 ) options = {};

      Snippet.call(this, options);

      this._columns = null;
      this._inner = null;
      this._outer = null;
      this._search = null;
      this._wildcard = null;

      this.setColumns(options.columns);
      this.setInner(options.inner);
      this.setOuter(options.outer);
      this.setSearch(options.search);
      this.setWildcard(options.wildcard);
    }

    if ( Snippet ) Search.__proto__ = Snippet;
    Search.prototype = Object.create( Snippet && Snippet.prototype );
    Search.prototype.constructor = Search;

    Search.prototype.getColumns = function getColumns () {
      return this._columns;
    };

    Search.prototype.setColumns = function setColumns (value) {
      if ( value === void 0 ) value = [];

      this._columns = value;
      return this;
    };

    Search.prototype.getInner = function getInner () {
      return this._inner;
    };

    Search.prototype.setInner = function setInner (value) {
      if ( value === void 0 ) value = 'AND';

      this._inner = value;
      return this;
    };

    Search.prototype.getOuter = function getOuter () {
      return this._outer;
    };

    Search.prototype.setOuter = function setOuter (value) {
      if ( value === void 0 ) value = 'OR';

      this._outer = value;
      return this;
    };

    Search.prototype.setParens = function setParens (value) {
      if ( value === void 0 ) value = true;

      return Snippet.prototype.setParens.call(this, value);
    };

    Search.prototype.getSearch = function getSearch () {
      return this._search;
    };

    Search.prototype.setSearch = function setSearch (value) {
      if ( value === void 0 ) value = '';

      this._search = value;
      return this;
    };

    Search.prototype.getWildcard = function getWildcard () {
      return this._wildcard;
    };

    Search.prototype.setWildcard = function setWildcard (value) {
      if ( value === void 0 ) value = /\*/g;

      this._wildcard = value;
      return this;
    };

    Search.prototype.columns = function columns (value) {
      return this.setColumns(value);
    };

    Search.prototype.inner = function inner (value) {
      return this.setInner(value);
    };

    Search.prototype.outer = function outer (value) {
      return this.setOuter(value);
    };

    Search.prototype.search = function search (value) {
      return this.setSearch(value);
    };

    Search.prototype.wildcard = function wildcard (value) {
      return this.setWildcard(value);
    };

    Search.prototype.resolveInner = function resolveInner (box, data) {
      var columns = this.resolveValue(box, data, this._columns);
      var inner = this.resolveValue(box, data, this._inner);
      var outer = this.resolveValue(box, data, this._outer);
      var search = this.resolveValue(box, data, this._search);
      var wildcard = this.resolveValue(box, data, this._wildcard);

      var match = [];
      var string = '';

      if (typeof search === 'string') {
        match = search.match(/[^"\s]+|"[^"]+"/g) || [];
      }

      for (var i = 0; i < columns.length; i += 1) {
        string += i === 0 ? '(' : (" " + outer + " (");
        string += match.length === 0 ? '1' : '';

        for (var j = 0; j < match.length; j += 1) {
          string += j === 0 ? '' : (" " + inner + " ");
          string += this.resolveValue(box, data, columns[i]);
          string += ' LIKE ';
          string += this.resolveEscape(
            trim(match[j].replace(wildcard, '%')),
            'value'
          );
        }

        string += ')';
      }

      return this.resolveParens(string, this._parens);
    };

    return Search;
  }(Snippet));

  var Slice = /*@__PURE__*/(function (Snippet) {
    function Slice(options) {
      if ( options === void 0 ) options = {};

      Snippet.call(this, options);

      this._count = null;
      this._default = null;
      this._offset = null;

      this.setCount(options.count);
      this.setDefault(options.default);
      this.setOffset(options.offset);
    }

    if ( Snippet ) Slice.__proto__ = Snippet;
    Slice.prototype = Object.create( Snippet && Snippet.prototype );
    Slice.prototype.constructor = Slice;

    Slice.prototype.getCount = function getCount () {
      return this._count;
    };

    Slice.prototype.setCount = function setCount (value) {
      if ( value === void 0 ) value = null;

      this._count = value;
      return this;
    };

    Slice.prototype.getDefault = function getDefault () {
      return this._default;
    };

    Slice.prototype.setDefault = function setDefault (value) {
      if ( value === void 0 ) value = '10 OFFSET 0';

      this._default = value;
      return this;
    };

    Slice.prototype.getOffset = function getOffset () {
      return this._offset;
    };

    Slice.prototype.setOffset = function setOffset (value) {
      if ( value === void 0 ) value = null;

      this._offset = value;
      return this;
    };

    Slice.prototype.count = function count (value) {
      return this.setCount(value);
    };

    Slice.prototype.default = function default$1 (value) {
      return this.setDefault(value);
    };

    Slice.prototype.offset = function offset (value) {
      return this.setOffset(value);
    };

    Slice.prototype.resolveInner = function resolveInner (box, data) {
      var count = this.resolveValue(box, data, this._count);
      var offset = this.resolveValue(box, data, this._offset);

      var string = '';

      if (
        Number.isInteger(parseFloat(count)) === false ||
        Number.isInteger(parseFloat(offset)) === false
      ) {
        string = this.resolveValue(box, data, this._default);
      } else {
        string = count + " OFFSET " + offset;
      }

      return this.resolveParens(string, this._parens);
    };

    return Slice;
  }(Snippet));



  var snippet = /*#__PURE__*/Object.freeze({
    Order: Order,
    Search: Search,
    Slice: Slice
  });

  var snippetBase = {
    snippet: snippet
  };

  var custom = {
    from: {
      object: Snippet,
      options: {
        infix: '',
        name: 'from',
        prefix: 'FROM '
      }
    },
    string: {
      object: Snippet,
      options: {
        escape: 'value',
        infix: ' ',
        name: 'string'
      }
    },
    query: {
      object: Snippet,
      options: {
        infix: ' ',
        name: 'query'
      }
    }
  };

  var func = funcBase.reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase(name)] = {
        object: Snippet,
        options: {
          name: name,
          parens: true,
          prefix: name
        }
      }, obj ));
  }, {});

  var infix = infixBase.reduce(function (object, ref) {
    var obj;

    var name = ref.name;
    var token = ref.token;
    return Object.assign(object, ( obj = {}, obj[camelCase(name)] = {
        object: Snippet,
        options: {
          infix: (" " + token + " "),
          name: name
        }
      }, obj ));
  }, {});

  var postfix = postfixBase.reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase(name)] = {
        object: Snippet,
        options: {
          name: name,
          postfix: (" " + name)
        }
      }, obj ));
  }, {});

  var prefix = prefixBase.reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase(name)] = {
        object: Snippet,
        options: {
          name: name,
          prefix: (name + " ")
        }
      }, obj ));
  }, {});

  var snippet$1 = Object.keys(snippetBase).reduce(function (master, group) {
    return Object.keys(snippetBase[group]).reduce(function (object, name) {
      var obj;

      return Object.assign(object, ( obj = {}, obj[camelCase(name)] = {
          object: snippetBase[group][name]
        }, obj ));
    }, master);
  }, {});

  var map = /*#__PURE__*/Object.freeze({
    custom: custom,
    snippet: snippet$1,
    infix: infix,
    postfix: postfix,
    prefix: prefix,
    func: func
  });

  var hosts = {};
  var pools = {};

  var MysqlBuilder = /*@__PURE__*/(function (Builder) {
    function MysqlBuilder(options) {
      if ( options === void 0 ) options = {};

      Builder.call(this, options);

      this._connection = null;
      this._host = null;
      this._key = null;
      this._nest = null;
      this._query = null;
      this._stream = null;
      this._timeout = null;
      this._type = null;

      this.setConnection(options.connection);
      this.setHost(options.host);
      this.setKey(options.key);
      this.setNest(options.nest);
      this.setQuery(options.query);
      this.setStream(options.stream);
      this.setTimeout(options.timeout);
      this.setType(options.type);
    }

    if ( Builder ) MysqlBuilder.__proto__ = Builder;
    MysqlBuilder.prototype = Object.create( Builder && Builder.prototype );
    MysqlBuilder.prototype.constructor = MysqlBuilder;

    MysqlBuilder.setup = function setup () {
      MysqlBuilder.attachFactories(MysqlBuilder, map);
    };

    MysqlBuilder.getHosts = function getHosts () {
      return hosts;
    };

    MysqlBuilder.setHosts = function setHosts (value) {
      hosts = value;
    };

    MysqlBuilder.prototype.getOptions = function getOptions () {
      return Object.assign(Builder.prototype.getOptions.call(this), {
        connection: this._connection,
        host: this._host,
        key: this._key,
        nest: this._nest,
        query: this._query,
        stream: this._stream,
        timeout: this._timeout,
        type: this._type
      });
    };

    MysqlBuilder.prototype.getConnection = function getConnection () {
      return this._connection;
    };

    MysqlBuilder.prototype.setConnection = function setConnection (value) {
      if ( value === void 0 ) value = null;

      this._connection = value;
      return this;
    };

    MysqlBuilder.prototype.getHost = function getHost () {
      return this._host;
    };

    MysqlBuilder.prototype.setHost = function setHost (value) {
      if ( value === void 0 ) value = 'default';

      this._host = value;
      return this;
    };

    MysqlBuilder.prototype.getKey = function getKey () {
      return this._key;
    };

    MysqlBuilder.prototype.setKey = function setKey (value) {
      if ( value === void 0 ) value = null;

      this._key = value;
      return this;
    };

    MysqlBuilder.prototype.getNest = function getNest () {
      return this._nest;
    };

    MysqlBuilder.prototype.setNest = function setNest (value) {
      if ( value === void 0 ) value = false;

      this._nest = value;
      return this;
    };

    MysqlBuilder.prototype.getQuery = function getQuery () {
      return this._query;
    };

    MysqlBuilder.prototype.setQuery = function setQuery (query) {
      if ( query === void 0 ) query = null;

      this._query = query;
      return this;
    };

    MysqlBuilder.prototype.getStream = function getStream () {
      return this._stream;
    };

    MysqlBuilder.prototype.setStream = function setStream (value) {
      if ( value === void 0 ) value = null;

      this._stream = value;
      return this;
    };

    MysqlBuilder.prototype.getTimeout = function getTimeout () {
      return this._timeout;
    };

    MysqlBuilder.prototype.setTimeout = function setTimeout (value) {
      if ( value === void 0 ) value = null;

      this._timeout = value;
      return this;
    };

    MysqlBuilder.prototype.getType = function getType () {
      return this._type;
    };

    MysqlBuilder.prototype.setType = function setType (value) {
      if ( value === void 0 ) value = null;

      this._type = value;
      return this;
    };

    MysqlBuilder.prototype.act = function act (box, data, callback) {
      var this$1 = this;

      data = this.filter(box, data);

      var query = {
        nestTables: this._nest,
        sql: this._query.resolve(box, data),
        timeout: this._timeout
      };

      this.log('info', box, data, query);

      this.open(box, data, function (error, connection, release) {
        if ( release === void 0 ) release = true;

        if (error) {
          this$1.handleError(box, data, callback, error);
          return;
        }

        if (this$1._stream === true) {
          this$1.streamData(box, data, callback, connection, query, release);
        } else {
          this$1.queryData(box, data, callback, connection, query, release);
        }
      });
    };

    MysqlBuilder.prototype.build = function build (query) {
      return this.setQuery(query);
    };

    MysqlBuilder.prototype.createPool = function createPool () {
      if (typeof pools[this._host] === 'undefined') {
        pools[this._host] = mysql.createPool(
          this.mapHost(this._host)
        );
      }

      return pools[this._host];
    };

    MysqlBuilder.prototype.handleError = function handleError (box, data, callback, error) {
      if (error.code === 'ER_DUP_ENTRY') {
        error = this.handleErrorDuplicate(error);
      }

      error.data = data;

      this.fail(box, error, callback);
    };

    MysqlBuilder.prototype.handleErrorDuplicate = function handleErrorDuplicate (error) {
      var reason = 'duplicate_' +
        (error.message.match(/key '(.+)'/) || ['key']).pop();

      error = new Error('409 Object already exists');
      error.reason = reason.toLowerCase();

      return error;
    };

    MysqlBuilder.prototype.handleQuery = function handleQuery (box, data, callback, query, result) {
      try {
        data = this.merge(box, data, {
          key: this._key,
          query: query,
          result: result
        });

        this.pass(box, data, callback);
      } catch (error) {
        this.handleError(box, data, callback, error);
      }
    };

    MysqlBuilder.prototype.mapHost = function mapHost (name) {
      return hosts[name];
    };

    MysqlBuilder.prototype.merge = function merge (box, data, ref) {
      var key = ref.key;
      var query = ref.query;
      var result = ref.result;

      if (this._merge) {
        return this._merge(box, data, { key: key, query: query, result: result });
      }

      if (this._type === 'list') {
        return { data: result };
      }

      if (this._type === 'object') {
        return { data: result[0] };
      }

      return result;
    };

    MysqlBuilder.prototype.open = function open (box, data, callback) {
      var pool = this.createPool(box, data);

      if (this._connection) {
        this._connection(box, data, pool, callback);
        return;
      }

      if (box.connection) {
        callback(null, box.connection, false);
        return;
      }

      pool.getConnection(callback);
    };

    MysqlBuilder.prototype.queryData = function queryData (box, data, callback, connection, query, release) {
      var this$1 = this;

      connection.query(query, function (error, result) {
        if (release) {
          connection.release();
        }

        if (error) {
          this$1.handleError(box, data, callback, error);
          return;
        }

        this$1.handleQuery(box, data, callback, query, result);
      });
    };

    MysqlBuilder.prototype.selector = function selector () {
      var ref;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
      return (ref = this._query).selector.apply(ref, args);
    };

    MysqlBuilder.prototype.streamData = function streamData (box, data, callback, connection, query, release) {
      var this$1 = this;

      var stream = connection.query(query);

      stream.on('error', function (error) {
        stream.removeAllListeners();
        this$1.handleError(box, data, callback, error);
      });

      stream.on('result', function (row) {
        this$1.pass(box, row, function (bx, resume) {
          if (resume === false) {
            connection.pause();
          } else {
            connection.resume();
          }
        });
      });

      stream.on('end', function () {
        stream.removeAllListeners();

        if (release) {
          connection.release();
        }
      });
    };

    return MysqlBuilder;
  }(Builder));

  var sprintf = createCommonjsModule(function (module, exports) {
  /* global window, exports, define */

  !function() {

      var re = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[+-]/
      };

      function sprintf(key) {
          // `arguments` is not an array, but should be fine for this call
          return sprintf_format(sprintf_parse(key), arguments)
      }

      function vsprintf(fmt, argv) {
          return sprintf.apply(null, [fmt].concat(argv || []))
      }

      function sprintf_format(parse_tree, argv) {
          var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;
          for (i = 0; i < tree_length; i++) {
              if (typeof parse_tree[i] === 'string') {
                  output += parse_tree[i];
              }
              else if (typeof parse_tree[i] === 'object') {
                  ph = parse_tree[i]; // convenience purposes only
                  if (ph.keys) { // keyword argument
                      arg = argv[cursor];
                      for (k = 0; k < ph.keys.length; k++) {
                          if (arg == undefined) {
                              throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                          }
                          arg = arg[ph.keys[k]];
                      }
                  }
                  else if (ph.param_no) { // positional argument (explicit)
                      arg = argv[ph.param_no];
                  }
                  else { // positional argument (implicit)
                      arg = argv[cursor++];
                  }

                  if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                      arg = arg();
                  }

                  if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                      throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                  }

                  if (re.number.test(ph.type)) {
                      is_positive = arg >= 0;
                  }

                  switch (ph.type) {
                      case 'b':
                          arg = parseInt(arg, 10).toString(2);
                          break
                      case 'c':
                          arg = String.fromCharCode(parseInt(arg, 10));
                          break
                      case 'd':
                      case 'i':
                          arg = parseInt(arg, 10);
                          break
                      case 'j':
                          arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                          break
                      case 'e':
                          arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                          break
                      case 'f':
                          arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                          break
                      case 'g':
                          arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                          break
                      case 'o':
                          arg = (parseInt(arg, 10) >>> 0).toString(8);
                          break
                      case 's':
                          arg = String(arg);
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 't':
                          arg = String(!!arg);
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 'T':
                          arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 'u':
                          arg = parseInt(arg, 10) >>> 0;
                          break
                      case 'v':
                          arg = arg.valueOf();
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 'x':
                          arg = (parseInt(arg, 10) >>> 0).toString(16);
                          break
                      case 'X':
                          arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                          break
                  }
                  if (re.json.test(ph.type)) {
                      output += arg;
                  }
                  else {
                      if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                          sign = is_positive ? '+' : '-';
                          arg = arg.toString().replace(re.sign, '');
                      }
                      else {
                          sign = '';
                      }
                      pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
                      pad_length = ph.width - (sign + arg).length;
                      pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';
                      output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);
                  }
              }
          }
          return output
      }

      var sprintf_cache = Object.create(null);

      function sprintf_parse(fmt) {
          if (sprintf_cache[fmt]) {
              return sprintf_cache[fmt]
          }

          var _fmt = fmt, match, parse_tree = [], arg_names = 0;
          while (_fmt) {
              if ((match = re.text.exec(_fmt)) !== null) {
                  parse_tree.push(match[0]);
              }
              else if ((match = re.modulo.exec(_fmt)) !== null) {
                  parse_tree.push('%');
              }
              else if ((match = re.placeholder.exec(_fmt)) !== null) {
                  if (match[2]) {
                      arg_names |= 1;
                      var field_list = [], replacement_field = match[2], field_match = [];
                      if ((field_match = re.key.exec(replacement_field)) !== null) {
                          field_list.push(field_match[1]);
                          while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                              if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                  field_list.push(field_match[1]);
                              }
                              else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                  field_list.push(field_match[1]);
                              }
                              else {
                                  throw new SyntaxError('[sprintf] failed to parse named argument key')
                              }
                          }
                      }
                      else {
                          throw new SyntaxError('[sprintf] failed to parse named argument key')
                      }
                      match[2] = field_list;
                  }
                  else {
                      arg_names |= 2;
                  }
                  if (arg_names === 3) {
                      throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                  }

                  parse_tree.push(
                      {
                          placeholder: match[0],
                          param_no:    match[1],
                          keys:        match[2],
                          sign:        match[3],
                          pad_char:    match[4],
                          align:       match[5],
                          width:       match[6],
                          precision:   match[7],
                          type:        match[8]
                      }
                  );
              }
              else {
                  throw new SyntaxError('[sprintf] unexpected placeholder')
              }
              _fmt = _fmt.substring(match[0].length);
          }
          return sprintf_cache[fmt] = parse_tree
      }

      /**
       * export to either browser or node.js
       */
      /* eslint-disable quote-props */
      {
          exports['sprintf'] = sprintf;
          exports['vsprintf'] = vsprintf;
      }
      if (typeof window !== 'undefined') {
          window['sprintf'] = sprintf;
          window['vsprintf'] = vsprintf;
      }
      /* eslint-enable quote-props */
  }(); // eslint-disable-line
  });

  var Transport = function Transport(options) {
    if ( options === void 0 ) options = {};

    this._builder = null;
    this._client = null;
    this._host = null;

    this.setBuilder(options.builder);
    this.setClient(options.client);
    this.setHost(options.host);
  };

  Transport.prototype.getBuilder = function getBuilder () {
    return this._builder;
  };

  Transport.prototype.setBuilder = function setBuilder (value) {
      if ( value === void 0 ) value = null;

    this._builder = value;
    return this;
  };

  Transport.prototype.getClient = function getClient () {
    return this._client;
  };

  Transport.prototype.setClient = function setClient (value) {
      if ( value === void 0 ) value = null;

    this._client = value;
    return this;
  };

  Transport.prototype.getHost = function getHost () {
    return this._host;
  };

  Transport.prototype.setHost = function setHost (value) {
      if ( value === void 0 ) value = null;

    this._host = value;
    return this;
  };

  Transport.prototype.host = function host (value) {
    return this.setHost(value);
  };

  Transport.prototype.send = function send () {};

  var Messagebird = /*@__PURE__*/(function (Transport) {
    function Messagebird () {
      Transport.apply(this, arguments);
    }

    if ( Transport ) Messagebird.__proto__ = Transport;
    Messagebird.prototype = Object.create( Transport && Transport.prototype );
    Messagebird.prototype.constructor = Messagebird;

    Messagebird.prototype.createClient = function createClient () {
      this.setClient(
        messagebird(
          this._builder.mapHost(this._host)
        )
      );
    };

    Messagebird.prototype.send = function send (message, callback) {
      if (this._client === null) {
        this.createClient();
      }

      this._client.messages.create({
        originator: message.from,
        recipients: [
          message.to
        ],
        body: message.text
      }, callback);
    };

    return Messagebird;
  }(Transport));

  var Nodemailer = /*@__PURE__*/(function (Transport) {
    function Nodemailer () {
      Transport.apply(this, arguments);
    }

    if ( Transport ) Nodemailer.__proto__ = Transport;
    Nodemailer.prototype = Object.create( Transport && Transport.prototype );
    Nodemailer.prototype.constructor = Nodemailer;

    Nodemailer.prototype.createClient = function createClient () {
      this.setClient(
        nodemailer.createTransport(
          this._builder.mapHost(this._host)
        )
      );
    };

    Nodemailer.prototype.send = function send (message, callback) {
      if (this._client === null) {
        this.createClient();
      }

      this._client.sendMail(message, callback);
    };

    return Nodemailer;
  }(Transport));



  var transport = /*#__PURE__*/Object.freeze({
    Messagebird: Messagebird,
    Nodemailer: Nodemailer
  });

  var map$1 = Object.keys(transport).reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase(name)] = {
        object: transport[name]
      }, obj ));
  }, {});

  var hosts$1 = {};

  var MessageSender = /*@__PURE__*/(function (Builder) {
    function MessageSender(options) {
      if ( options === void 0 ) options = {};

      Builder.call(this, options);

      this._transport = null;
      this.setTransport(options.transport);
    }

    if ( Builder ) MessageSender.__proto__ = Builder;
    MessageSender.prototype = Object.create( Builder && Builder.prototype );
    MessageSender.prototype.constructor = MessageSender;

    MessageSender.setup = function setup () {
      MessageSender.attachFactories(MessageSender, { map: map$1 });
    };

    MessageSender.getHosts = function getHosts () {
      return hosts$1;
    };

    MessageSender.setHosts = function setHosts (value) {
      hosts$1 = value;
    };

    MessageSender.prototype.getTransport = function getTransport () {
      return this._transport;
    };

    MessageSender.prototype.setTransport = function setTransport (value) {
      if ( value === void 0 ) value = null;

      this._transport = value;
      return this;
    };

    MessageSender.prototype.transport = function transport (value) {
      return this.setTransport(value);
    };

    MessageSender.prototype.mapHost = function mapHost (name) {
      return hosts$1[name];
    };

    MessageSender.prototype.act = function act (box, data, callback) {
      var this$1 = this;

      data = this.filter(box, data);
      data = this.sprintf(data);

      this._transport.send(data, function (error, result) {
        if (error) {
          this$1.handleError(box, data, callback, error);
          return;
        }

        this$1.handleSend(box, data, callback, result);
      });
    };

    MessageSender.prototype.handleError = function handleError (box, data, callback, error) {
      error.data = data;
      this.fail(box, error, callback);
    };

    MessageSender.prototype.handleSend = function handleSend (box, data, callback, result) {
      try {
        data = this.merge(box, data, { result: result });
        this.pass(box, data, callback);
      } catch (error) {
        this.handleError(box, data, callback, error);
      }
    };

    MessageSender.prototype.sprintf = function sprintf$1 (data) {
      data.subject = sprintf.sprintf(data.subject, data.data);
      data.text = sprintf.sprintf(data.text, data.data);

      if (typeof data.html !== 'undefined') {
        this.sprintfHtml(data);
      }

      return data;
    };

    MessageSender.prototype.sprintfHtml = function sprintfHtml (data) {
      var wrap = data.html.replace(/%([^s])/g, '%%$1');

      var html = marked$1(data.text, {
        breaks: true,
        sanitize: true
      });

      data.html = sprintf.sprintf(wrap, html);
    };

    return MessageSender;
  }(Builder));

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  // resolves . and .. elements in a path array with directory names there
  // must be no slashes, empty elements, or device names (c:\) in the array
  // (so also no leading and trailing slashes - it does not distinguish
  // relative and absolute paths)
  function normalizeArray(parts, allowAboveRoot) {
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift('..');
      }
    }

    return parts;
  }

  // Split a filename into [root, dir, basename, ext], unix version
  // 'root' is just a slash, or nothing.
  var splitPathRe =
      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  var splitPath = function(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  // path.resolve([from ...], to)
  // posix version
  function resolve() {
    var arguments$1 = arguments;

    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = (i >= 0) ? arguments$1[i] : '/';

      // Skip empty and invalid entries
      if (typeof path !== 'string') {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
      return !!p;
    }), !resolvedAbsolute).join('/');

    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
  }
  // path.normalize(path)
  // posix version
  function normalize(path) {
    var isPathAbsolute = isAbsolute(path),
        trailingSlash = substr(path, -1) === '/';

    // Normalize the path
    path = normalizeArray(filter(path.split('/'), function(p) {
      return !!p;
    }), !isPathAbsolute).join('/');

    if (!path && !isPathAbsolute) {
      path = '.';
    }
    if (path && trailingSlash) {
      path += '/';
    }

    return (isPathAbsolute ? '/' : '') + path;
  }
  // posix version
  function isAbsolute(path) {
    return path.charAt(0) === '/';
  }

  // posix version
  function join() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize(filter(paths, function(p, index) {
      if (typeof p !== 'string') {
        throw new TypeError('Arguments to path.join must be strings');
      }
      return p;
    }).join('/'));
  }


  // path.relative(from, to)
  // posix version
  function relative(from, to) {
    from = resolve(from).substr(1);
    to = resolve(to).substr(1);

    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') { break; }
      }

      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') { break; }
      }

      if (start > end) { return []; }
      return arr.slice(start, end - start + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));

    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));

    return outputParts.join('/');
  }

  var sep = '/';
  var delimiter = ':';

  function dirname(path) {
    var result = splitPath(path),
        root = result[0],
        dir = result[1];

    if (!root && !dir) {
      // No dirname whatsoever
      return '.';
    }

    if (dir) {
      // It has a dirname, strip trailing slash
      dir = dir.substr(0, dir.length - 1);
    }

    return root + dir;
  }

  function basename(path, ext) {
    var f = splitPath(path)[2];
    // TODO: make this comparison case-insensitive on windows?
    if (ext && f.substr(-1 * ext.length) === ext) {
      f = f.substr(0, f.length - ext.length);
    }
    return f;
  }


  function extname(path) {
    return splitPath(path)[3];
  }
  var path = {
    extname: extname,
    basename: basename,
    dirname: dirname,
    sep: sep,
    delimiter: delimiter,
    relative: relative,
    join: join,
    isAbsolute: isAbsolute,
    normalize: normalize,
    resolve: resolve
  };
  function filter (xs, f) {
      if (xs.filter) { return xs.filter(f); }
      var res = [];
      for (var i = 0; i < xs.length; i++) {
          if (f(xs[i], i, xs)) { res.push(xs[i]); }
      }
      return res;
  }

  // String.prototype.substr - negative index don't work in IE8
  var substr = 'ab'.substr(-1) === 'b' ?
      function (str, start, len) { return str.substr(start, len) } :
      function (str, start, len) {
          if (start < 0) { start = str.length + start; }
          return str.substr(start, len);
      }
  ;

  var FileWriter = /*@__PURE__*/(function (Worker) {
    function FileWriter () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) FileWriter.__proto__ = Worker;
    FileWriter.prototype = Object.create( Worker && Worker.prototype );
    FileWriter.prototype.constructor = FileWriter;

    FileWriter.prototype.act = function act (box, data, callback) {
      var this$1 = this;

      data = this.filter(box, data);

      fs.ensureDirSync(path.dirname(data.write));

      var reader = fs.createReadStream(data.read);

      reader.once('error', function (error) {
        this$1.removeListeners(reader);
        this$1.fail(box, error, callback);
      });

      reader.once('open', function () {
        this$1.handleOpen(box, data, callback, reader);
      });
    };

    FileWriter.prototype.handleOpen = function handleOpen (box, data, callback, reader) {
      var this$1 = this;

      var writer = fs.createWriteStream(data.write);

      writer.once('error', function (error) {
        this$1.removeListeners(reader, writer);
        this$1.fail(box, error, callback);
      });

      writer.once('finish', function () {
        this$1.removeListeners(reader, writer);
        data = this$1.merge(box, data);
        this$1.pass(box, data, callback);
      });

      reader.pipe(writer);
    };

    FileWriter.prototype.removeListeners = function removeListeners (reader, writer) {
      if (reader) {
        reader.removeAllListeners();
      }

      if (writer) {
        writer.removeAllListeners();
      }
    };

    return FileWriter;
  }(Worker));

  function setup() {
    Worker.setLog(Worker.log);

    MessageSender.setup();
    MysqlBuilder.setup();
  }



  var index$1 = /*#__PURE__*/Object.freeze({
    setup: setup,
    MysqlBuilder: MysqlBuilder,
    snippet: snippet,
    Snippet: Snippet,
    MessageSender: MessageSender,
    map: map$1,
    Messagebird: Messagebird,
    Nodemailer: Nodemailer,
    FileWriter: FileWriter
  });

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector(compare) {
    if (compare.length === 1) { compare = ascendingComparator(compare); }
    return {
      left: function(a, x, lo, hi) {
        if (lo == null) { lo = 0; }
        if (hi == null) { hi = a.length; }
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) { lo = mid + 1; }
          else { hi = mid; }
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (lo == null) { lo = 0; }
        if (hi == null) { hi = a.length; }
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) { hi = mid; }
          else { lo = mid + 1; }
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function(d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);

  var noop$1 = {value: function() {}};

  function dispatch() {
    var arguments$1 = arguments;

    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments$1[i] + "") || (t in _)) { throw new Error("illegal type: " + t); }
      _[t] = [];
    }
    return new Dispatch(_);
  }

  function Dispatch(_) {
    this._ = _;
  }

  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) { name = t.slice(i + 1), t = t.slice(0, i); }
      if (t && !types.hasOwnProperty(t)) { throw new Error("unknown type: " + t); }
      return {type: t, name: name};
    });
  }

  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._,
          T = parseTypenames(typename + "", _),
          t,
          i = -1,
          n = T.length;

      // If no callback was specified, return the callback of the given type and name.
      if (arguments.length < 2) {
        while (++i < n) { if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) { return t; } }
        return;
      }

      // If a type was specified, set the callback for the given type and name.
      // Otherwise, if a null callback was specified, remove callbacks of the given name.
      if (callback != null && typeof callback !== "function") { throw new Error("invalid callback: " + callback); }
      while (++i < n) {
        if (t = (typename = T[i]).type) { _[t] = set(_[t], typename.name, callback); }
        else if (callback == null) { for (t in _) { _[t] = set(_[t], typename.name, null); } }
      }

      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _) { copy[t] = _[t].slice(); }
      return new Dispatch(copy);
    },
    call: function(type, that) {
      var arguments$1 = arguments;

      if ((n = arguments.length - 2) > 0) { for (var args = new Array(n), i = 0, n, t; i < n; ++i) { args[i] = arguments$1[i + 2]; } }
      if (!this._.hasOwnProperty(type)) { throw new Error("unknown type: " + type); }
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) { t[i].value.apply(that, args); }
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) { throw new Error("unknown type: " + type); }
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) { t[i].value.apply(that, args); }
    }
  };

  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }

  function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) { type.push({name: name, value: callback}); }
    return type;
  }

  var xhtml = "http://www.w3.org/1999/xhtml";

  var namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  function namespace(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") { name = name.slice(i + 1); }
    return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
  }

  function creatorInherit(name) {
    return function() {
      var document = this.ownerDocument,
          uri = this.namespaceURI;
      return uri === xhtml && document.documentElement.namespaceURI === xhtml
          ? document.createElement(name)
          : document.createElementNS(uri, name);
    };
  }

  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }

  function creator(name) {
    var fullname = namespace(name);
    return (fullname.local
        ? creatorFixed
        : creatorInherit)(fullname);
  }

  function none() {}

  function selector(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  function selection_select(select) {
    if (typeof select !== "function") { select = selector(select); }

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) { subnode.__data__ = node.__data__; }
          subgroup[i] = subnode;
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function empty() {
    return [];
  }

  function selectorAll(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  function selection_selectAll(select) {
    if (typeof select !== "function") { select = selectorAll(select); }

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }

    return new Selection(subgroups, parents);
  }

  function matcher(selector) {
    return function() {
      return this.matches(selector);
    };
  }

  function selection_filter(match) {
    if (typeof match !== "function") { match = matcher(match); }

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Selection(subgroups, this._parents);
  }

  function sparse(update) {
    return new Array(update.length);
  }

  function selection_enter() {
    return new Selection(this._enter || this._groups.map(sparse), this._parents);
  }

  function EnterNode(parent, datum) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum;
  }

  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
    insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
    querySelector: function(selector) { return this._parent.querySelector(selector); },
    querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
  };

  function constant(x) {
    return function() {
      return x;
    };
  }

  var keyPrefix = "$"; // Protect against keys like “__proto__”.

  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0,
        node,
        groupLength = group.length,
        dataLength = data.length;

    // Put any non-null nodes that fit into update.
    // Put any null nodes into enter.
    // Put any remaining data into enter.
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Put any non-null nodes that don’t fit into exit.
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }

  function bindKey(parent, group, enter, update, exit, data, key) {
    var i,
        node,
        nodeByKeyValue = {},
        groupLength = group.length,
        dataLength = data.length,
        keyValues = new Array(groupLength),
        keyValue;

    // Compute the key for each node.
    // If multiple nodes have the same key, the duplicates are added to exit.
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
        if (keyValue in nodeByKeyValue) {
          exit[i] = node;
        } else {
          nodeByKeyValue[keyValue] = node;
        }
      }
    }

    // Compute the key for each datum.
    // If there a node associated with this key, join and add it to update.
    // If there is not (or the key is a duplicate), add it to enter.
    for (i = 0; i < dataLength; ++i) {
      keyValue = keyPrefix + key.call(parent, data[i], i, data);
      if (node = nodeByKeyValue[keyValue]) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue[keyValue] = null;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }

    // Add any remaining nodes that were not bound to data to exit.
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
        exit[i] = node;
      }
    }
  }

  function selection_data(value, key) {
    if (!value) {
      data = new Array(this.size()), j = -1;
      this.each(function(d) { data[++j] = d; });
      return data;
    }

    var bind = key ? bindKey : bindIndex,
        parents = this._parents,
        groups = this._groups;

    if (typeof value !== "function") { value = constant(value); }

    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j],
          group = groups[j],
          groupLength = group.length,
          data = value.call(parent, parent && parent.__data__, j, parents),
          dataLength = data.length,
          enterGroup = enter[j] = new Array(dataLength),
          updateGroup = update[j] = new Array(dataLength),
          exitGroup = exit[j] = new Array(groupLength);

      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

      // Now connect the enter nodes to their following update node, such that
      // appendChild can insert the materialized enter node before this node,
      // rather than at the end of the parent node.
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) { i1 = i0 + 1; }
          while (!(next = updateGroup[i1]) && ++i1 < dataLength){ }
          previous._next = next || null;
        }
      }
    }

    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }

  function selection_exit() {
    return new Selection(this._exit || this._groups.map(sparse), this._parents);
  }

  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
    if (onupdate != null) { update = onupdate(update); }
    if (onexit == null) { exit.remove(); } else { onexit(exit); }
    return enter && update ? enter.merge(update).order() : update;
  }

  function selection_merge(selection) {

    for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Selection(merges, this._parents);
  }

  function selection_order() {

    for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4) { next.parentNode.insertBefore(node, next); }
          next = node;
        }
      }
    }

    return this;
  }

  function selection_sort(compare) {
    if (!compare) { compare = ascending$1; }

    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }

    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }

    return new Selection(sortgroups, this._parents).order();
  }

  function ascending$1(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  function selection_nodes() {
    var nodes = new Array(this.size()), i = -1;
    this.each(function() { nodes[++i] = this; });
    return nodes;
  }

  function selection_node() {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node) { return node; }
      }
    }

    return null;
  }

  function selection_size() {
    var size = 0;
    this.each(function() { ++size; });
    return size;
  }

  function selection_empty() {
    return !this.node();
  }

  function selection_each(callback) {

    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i]) { callback.call(node, node.__data__, i, group); }
      }
    }

    return this;
  }

  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }

  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }

  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) { this.removeAttribute(name); }
      else { this.setAttribute(name, v); }
    };
  }

  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) { this.removeAttributeNS(fullname.space, fullname.local); }
      else { this.setAttributeNS(fullname.space, fullname.local, v); }
    };
  }

  function selection_attr(name, value) {
    var fullname = namespace(name);

    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local
          ? node.getAttributeNS(fullname.space, fullname.local)
          : node.getAttribute(fullname);
    }

    return this.each((value == null
        ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
        ? (fullname.local ? attrFunctionNS : attrFunction)
        : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
  }

  function defaultView(node) {
    return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
        || (node.document && node) // node is a Window
        || node.defaultView; // node is a Document
  }

  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }

  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) { this.style.removeProperty(name); }
      else { this.style.setProperty(name, v, priority); }
    };
  }

  function selection_style(name, value, priority) {
    return arguments.length > 1
        ? this.each((value == null
              ? styleRemove : typeof value === "function"
              ? styleFunction
              : styleConstant)(name, value, priority == null ? "" : priority))
        : styleValue(this.node(), name);
  }

  function styleValue(node, name) {
    return node.style.getPropertyValue(name)
        || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }

  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }

  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null) { delete this[name]; }
      else { this[name] = v; }
    };
  }

  function selection_property(name, value) {
    return arguments.length > 1
        ? this.each((value == null
            ? propertyRemove : typeof value === "function"
            ? propertyFunction
            : propertyConstant)(name, value))
        : this.node()[name];
  }

  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }

  function classList(node) {
    return node.classList || new ClassList(node);
  }

  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }

  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };

  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) { list.add(names[i]); }
  }

  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n) { list.remove(names[i]); }
  }

  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }

  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }

  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }

  function selection_classed(name, value) {
    var names = classArray(name + "");

    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n) { if (!list.contains(names[i])) { return false; } }
      return true;
    }

    return this.each((typeof value === "function"
        ? classedFunction : value
        ? classedTrue
        : classedFalse)(names, value));
  }

  function textRemove() {
    this.textContent = "";
  }

  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }

  function selection_text(value) {
    return arguments.length
        ? this.each(value == null
            ? textRemove : (typeof value === "function"
            ? textFunction
            : textConstant)(value))
        : this.node().textContent;
  }

  function htmlRemove() {
    this.innerHTML = "";
  }

  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }

  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }

  function selection_html(value) {
    return arguments.length
        ? this.each(value == null
            ? htmlRemove : (typeof value === "function"
            ? htmlFunction
            : htmlConstant)(value))
        : this.node().innerHTML;
  }

  function raise() {
    if (this.nextSibling) { this.parentNode.appendChild(this); }
  }

  function selection_raise() {
    return this.each(raise);
  }

  function lower() {
    if (this.previousSibling) { this.parentNode.insertBefore(this, this.parentNode.firstChild); }
  }

  function selection_lower() {
    return this.each(lower);
  }

  function selection_append(name) {
    var create = typeof name === "function" ? name : creator(name);
    return this.select(function() {
      return this.appendChild(create.apply(this, arguments));
    });
  }

  function constantNull() {
    return null;
  }

  function selection_insert(name, before) {
    var create = typeof name === "function" ? name : creator(name),
        select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  function remove() {
    var parent = this.parentNode;
    if (parent) { parent.removeChild(this); }
  }

  function selection_remove() {
    return this.each(remove);
  }

  function selection_cloneShallow() {
    return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
  }

  function selection_cloneDeep() {
    return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
  }

  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  function selection_datum(value) {
    return arguments.length
        ? this.property("__data__", value)
        : this.node().__data__;
  }

  var filterEvents = {};

  var event$1 = null;

  if (typeof document !== "undefined") {
    var element = document.documentElement;
    if (!("onmouseenter" in element)) {
      filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
    }
  }

  function filterContextListener(listener, index, group) {
    listener = contextListener(listener, index, group);
    return function(event) {
      var related = event.relatedTarget;
      if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
        listener.call(this, event);
      }
    };
  }

  function contextListener(listener, index, group) {
    return function(event1) {
      var event0 = event$1; // Events can be reentrant (e.g., focus).
      event$1 = event1;
      try {
        listener.call(this, this.__data__, index, group);
      } finally {
        event$1 = event0;
      }
    };
  }

  function parseTypenames$1(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) { name = t.slice(i + 1), t = t.slice(0, i); }
      return {type: t, name: name};
    });
  }

  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) { return; }
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
        } else {
          on[++i] = o;
        }
      }
      if (++i) { on.length = i; }
      else { delete this.__on; }
    };
  }

  function onAdd(typename, value, capture) {
    var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
    return function(d, i, group) {
      var on = this.__on, o, listener = wrap(value, i, group);
      if (on) { for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      } }
      this.addEventListener(typename.type, listener, capture);
      o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
      if (!on) { this.__on = [o]; }
      else { on.push(o); }
    };
  }

  function selection_on(typename, value, capture) {
    var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) { for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      } }
      return;
    }

    on = value ? onAdd : onRemove;
    if (capture == null) { capture = false; }
    for (i = 0; i < n; ++i) { this.each(on(typenames[i], value, capture)); }
    return this;
  }

  function dispatchEvent(node, type, params) {
    var window = defaultView(node),
        event = window.CustomEvent;

    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window.document.createEvent("Event");
      if (params) { event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail; }
      else { event.initEvent(type, false, false); }
    }

    node.dispatchEvent(event);
  }

  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }

  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }

  function selection_dispatch(type, params) {
    return this.each((typeof params === "function"
        ? dispatchFunction
        : dispatchConstant)(type, params));
  }

  var root$1 = [null];

  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }

  function selection() {
    return new Selection([[document.documentElement]], root$1);
  }

  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: selection_select,
    selectAll: selection_selectAll,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch
  };

  function select(selector) {
    return typeof selector === "string"
        ? new Selection([[document.querySelector(selector)]], [document.documentElement])
        : new Selection([[selector]], root$1);
  }

  function selectAll(selector) {
    return typeof selector === "string"
        ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
        : new Selection([selector == null ? [] : selector], root$1);
  }

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) { prototype[key] = definition[key]; }
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex3 = /^#([0-9a-f]{3})$/,
      reHex6 = /^#([0-9a-f]{6})$/,
      reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
      reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
      reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
      reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
      reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
      reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: function() {
      return this.rgb().hex();
    },
    toString: function() {
      return this.rgb() + "";
    }
  });

  function color(format) {
    var m;
    format = (format + "").trim().toLowerCase();
    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format])
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) { r = g = b = NaN; }
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) { o = color(o); }
    if (!o) { return new Rgb; }
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: function() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    },
    toString: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) { h = s = l = NaN; }
    else if (l <= 0 || l >= 1) { h = s = NaN; }
    else if (s <= 0) { h = NaN; }
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) { return new Hsl(o.h, o.s, o.l, o.opacity); }
    if (!(o instanceof Color)) { o = color(o); }
    if (!o) { return new Hsl; }
    if (o instanceof Hsl) { return o; }
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) { h = (g - b) / s + (g < b) * 6; }
      else if (g === max) { h = (b - r) / s + 2; }
      else { h = (r - g) / s + 4; }
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  var deg2rad = Math.PI / 180;
  var rad2deg = 180 / Math.PI;

  // https://observablehq.com/@mbostock/lab-and-rgb
  var K = 18,
      Xn = 0.96422,
      Yn = 1,
      Zn = 0.82521,
      t0 = 4 / 29,
      t1 = 6 / 29,
      t2 = 3 * t1 * t1,
      t3 = t1 * t1 * t1;

  function labConvert(o) {
    if (o instanceof Lab) { return new Lab(o.l, o.a, o.b, o.opacity); }
    if (o instanceof Hcl) { return hcl2lab(o); }
    if (!(o instanceof Rgb)) { o = rgbConvert(o); }
    var r = rgb2lrgb(o.r),
        g = rgb2lrgb(o.g),
        b = rgb2lrgb(o.b),
        y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
    if (r === g && g === b) { x = z = y; } else {
      x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
      z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
    }
    return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
  }

  function lab(l, a, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
  }

  function Lab(l, a, b, opacity) {
    this.l = +l;
    this.a = +a;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Lab, lab, extend(Color, {
    brighter: function(k) {
      return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    darker: function(k) {
      return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
    },
    rgb: function() {
      var y = (this.l + 16) / 116,
          x = isNaN(this.a) ? y : y + this.a / 500,
          z = isNaN(this.b) ? y : y - this.b / 200;
      x = Xn * lab2xyz(x);
      y = Yn * lab2xyz(y);
      z = Zn * lab2xyz(z);
      return new Rgb(
        lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
        lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
        lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
        this.opacity
      );
    }
  }));

  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
  }

  function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
  }

  function lrgb2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }

  function rgb2lrgb(x) {
    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  }

  function hclConvert(o) {
    if (o instanceof Hcl) { return new Hcl(o.h, o.c, o.l, o.opacity); }
    if (!(o instanceof Lab)) { o = labConvert(o); }
    if (o.a === 0 && o.b === 0) { return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity); }
    var h = Math.atan2(o.b, o.a) * rad2deg;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }

  function hcl(h, c, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
  }

  function Hcl(h, c, l, opacity) {
    this.h = +h;
    this.c = +c;
    this.l = +l;
    this.opacity = +opacity;
  }

  function hcl2lab(o) {
    if (isNaN(o.h)) { return new Lab(o.l, 0, 0, o.opacity); }
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }

  define(Hcl, hcl, extend(Color, {
    brighter: function(k) {
      return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
    },
    darker: function(k) {
      return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
    },
    rgb: function() {
      return hcl2lab(this).rgb();
    }
  }));

  var A = -0.14861,
      B = +1.78277,
      C = -0.29227,
      D = -0.90649,
      E = +1.97294,
      ED = E * D,
      EB = E * B,
      BC_DA = B * C - D * A;

  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) { return new Cubehelix(o.h, o.s, o.l, o.opacity); }
    if (!(o instanceof Rgb)) { o = rgbConvert(o); }
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
        bl = b - l,
        k = (E * (g - l) - C * bl) / D,
        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
  }

  function cubehelix(h, s, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
  }

  function Cubehelix(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Cubehelix, cubehelix, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
          l = +this.l,
          a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
          cosh = Math.cos(h),
          sinh = Math.sin(h);
      return new Rgb(
        255 * (l + a * (A * cosh + B * sinh)),
        255 * (l + a * (C * cosh + D * sinh)),
        255 * (l + a * (E * cosh)),
        this.opacity
      );
    }
  }));

  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0
        + (4 - 6 * t2 + 3 * t3) * v1
        + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
        + t3 * v3) / 6;
  }

  function basis$1(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
          v1 = values[i],
          v2 = values[i + 1],
          v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
          v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  function constant$1(x) {
    return function() {
      return x;
    };
  }

  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function hue(a, b) {
    var d = b - a;
    return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$1(isNaN(a) ? b : a);
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
  }

  var interpolateRgb = (function rgbGamma(y) {
    var color = gamma(y);

    function rgb$1(start, end) {
      var r = color((start = rgb(start)).r, (end = rgb(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb$1.gamma = rgbGamma;

    return rgb$1;
  })(1);

  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length,
          r = new Array(n),
          g = new Array(n),
          b = new Array(n),
          i, color;
      for (i = 0; i < n; ++i) {
        color = rgb(colors[i]);
        r[i] = color.r || 0;
        g[i] = color.g || 0;
        b[i] = color.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color.opacity = 1;
      return function(t) {
        color.r = r(t);
        color.g = g(t);
        color.b = b(t);
        return color + "";
      };
    };
  }

  var rgbBasis = rgbSpline(basis$1);

  function interpolateNumber(a, b) {
    return a = +a, b -= a, function(t) {
      return a + b * t;
    };
  }

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");

  function zero(b) {
    return function() {
      return b;
    };
  }

  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function interpolateString(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) { s[i] += bs; } // coalesce with previous string
        else { s[++i] = bs; }
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) { s[i] += bm; } // coalesce with previous string
        else { s[++i] = bm; }
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: interpolateNumber(am, bm)});
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) { s[i] += bs; } // coalesce with previous string
      else { s[++i] = bs; }
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) { s[(o = q[i]).i] = o.x(t); }
            return s.join("");
          });
  }

  var degrees = 180 / Math.PI;

  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };

  function decompose(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) { a /= scaleX, b /= scaleX; }
    if (skewX = a * c + b * d) { c -= a * skewX, d -= b * skewX; }
    if (scaleY = Math.sqrt(c * c + d * d)) { c /= scaleY, d /= scaleY, skewX /= scaleY; }
    if (a * d < b * c) { a = -a, b = -b, skewX = -skewX, scaleX = -scaleX; }
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var cssNode,
      cssRoot,
      cssView,
      svgNode;

  function parseCss(value) {
    if (value === "none") { return identity; }
    if (!cssNode) { cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView; }
    cssNode.style.transform = value;
    value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
    cssRoot.removeChild(cssNode);
    value = value.slice(7, -1).split(",");
    return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
  }

  function parseSvg(value) {
    if (value == null) { return identity; }
    if (!svgNode) { svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g"); }
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) { return identity; }
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  function interpolateTransform(parse, pxComma, pxParen, degParen) {

    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }

    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }

    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180) { b += 360; } else if (b - a > 180) { a += 360; } // shortest path
        q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }

    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }

    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }

    return function(a, b) {
      var s = [], // string constants and placeholders
          q = []; // number interpolators
      a = parse(a), b = parse(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null; // gc
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n) { s[(o = q[i]).i] = o.x(t); }
        return s.join("");
      };
    };
  }

  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  var rho = Math.SQRT2;

  function cubehelix$1(hue) {
    return (function cubehelixGamma(y) {
      y = +y;

      function cubehelix$1(start, end) {
        var h = hue((start = cubehelix(start)).h, (end = cubehelix(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(Math.pow(t, y));
          start.opacity = opacity(t);
          return start + "";
        };
      }

      cubehelix$1.gamma = cubehelixGamma;

      return cubehelix$1;
    })(1);
  }

  cubehelix$1(hue);
  var cubehelixLong = cubehelix$1(nogamma);

  var frame = 0, // is an animation frame pending?
      timeout = 0, // is a timeout pending?
      interval = 0, // are any timers active?
      pokeDelay = 1000, // how frequently we check for clock skew
      taskHead,
      taskTail,
      clockLast = 0,
      clockNow = 0,
      clockSkew = 0,
      clock = typeof performance === "object" && performance.now ? performance : Date,
      setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }

  function clearNow() {
    clockNow = 0;
  }

  function Timer$1() {
    this._call =
    this._time =
    this._next = null;
  }

  Timer$1.prototype = timer.prototype = {
    constructor: Timer$1,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") { throw new TypeError("callback is not a function"); }
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) { taskTail._next = this; }
        else { taskHead = this; }
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };

  function timer(callback, delay, time) {
    var t = new Timer$1;
    t.restart(callback, delay, time);
    return t;
  }

  function timerFlush() {
    now(); // Get the current time, if not already set.
    ++frame; // Pretend we’ve set an alarm, if we haven’t already.
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) { t._call.call(null, e); }
      t = t._next;
    }
    --frame;
  }

  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }

  function poke() {
    var now = clock.now(), delay = now - clockLast;
    if (delay > pokeDelay) { clockSkew -= delay, clockLast = now; }
  }

  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) { time = t1._time; }
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }

  function sleep(time) {
    if (frame) { return; } // Soonest alarm already set, or will be.
    if (timeout) { timeout = clearTimeout(timeout); }
    var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
    if (delay > 24) {
      if (time < Infinity) { timeout = setTimeout(wake, time - clock.now() - clockSkew); }
      if (interval) { interval = clearInterval(interval); }
    } else {
      if (!interval) { clockLast = clock.now(), interval = setInterval(poke, pokeDelay); }
      frame = 1, setFrame(wake);
    }
  }

  function timeout$1(callback, delay, time) {
    var t = new Timer$1;
    delay = delay == null ? 0 : +delay;
    t.restart(function(elapsed) {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }

  var emptyOn = dispatch("start", "end", "cancel", "interrupt");
  var emptyTween = [];

  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;

  function schedule(node, name, id, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules) { node.__transition = {}; }
    else if (id in schedules) { return; }
    create(node, id, {
      name: name,
      index: index, // For context during callback.
      group: group, // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }

  function init(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > CREATED) { throw new Error("too late; already scheduled"); }
    return schedule;
  }

  function set$1(node, id) {
    var schedule = get$1(node, id);
    if (schedule.state > STARTED) { throw new Error("too late; already running"); }
    return schedule;
  }

  function get$1(node, id) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id])) { throw new Error("transition not found"); }
    return schedule;
  }

  function create(node, id, self) {
    var schedules = node.__transition,
        tween;

    // Initialize the self timer when the transition is created.
    // Note the actual delay is not known until the first callback!
    schedules[id] = self;
    self.timer = timer(schedule, 0, self.time);

    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start, self.delay, self.time);

      // If the elapsed delay is less than our first sleep, start immediately.
      if (self.delay <= elapsed) { start(elapsed - self.delay); }
    }

    function start(elapsed) {
      var i, j, n, o;

      // If the state is not SCHEDULED, then we previously errored on start.
      if (self.state !== SCHEDULED) { return stop(); }

      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self.name) { continue; }

        // While this element already has a starting transition during this frame,
        // defer starting an interrupting transition until that transition has a
        // chance to tick (and possibly end); see d3/d3-transition#54!
        if (o.state === STARTED) { return timeout$1(start); }

        // Interrupt the active transition, if any.
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }

        // Cancel any pre-empted transitions.
        else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }

      // Defer the first tick to end of the current frame; see d3/d3#1576.
      // Note the transition may be canceled after start and before the first tick!
      // Note this must be scheduled before the start event; see d3/d3-transition#16!
      // Assuming this is successful, subsequent callbacks go straight to tick.
      timeout$1(function() {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });

      // Dispatch the start event.
      // Note this must be done before the tween are initialized.
      self.state = STARTING;
      self.on.call("start", node, node.__data__, self.index, self.group);
      if (self.state !== STARTING) { return; } // interrupted
      self.state = STARTED;

      // Initialize the tween, deleting null tween.
      tween = new Array(n = self.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }

    function tick(elapsed) {
      var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
          i = -1,
          n = tween.length;

      while (++i < n) {
        tween[i].call(node, t);
      }

      // Dispatch the end event.
      if (self.state === ENDING) {
        self.on.call("end", node, node.__data__, self.index, self.group);
        stop();
      }
    }

    function stop() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id];
      for (var i in schedules) { return; } // eslint-disable-line no-unused-vars
      delete node.__transition;
    }
  }

  function interrupt(node, name) {
    var schedules = node.__transition,
        schedule,
        active,
        empty = true,
        i;

    if (!schedules) { return; }

    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }

    if (empty) { delete node.__transition; }
  }

  function selection_interrupt(name) {
    return this.each(function() {
      interrupt(this, name);
    });
  }

  function tweenRemove(id, name) {
    var tween0, tween1;
    return function() {
      var schedule = set$1(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }

      schedule.tween = tween1;
    };
  }

  function tweenFunction(id, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") { throw new Error; }
    return function() {
      var schedule = set$1(this, id),
          tween = schedule.tween;

      // If this node shared tween with the previous node,
      // just assign the updated shared tween and we’re done!
      // Otherwise, copy-on-write.
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n) { tween1.push(t); }
      }

      schedule.tween = tween1;
    };
  }

  function transition_tween(name, value) {
    var id = this._id;

    name += "";

    if (arguments.length < 2) {
      var tween = get$1(this.node(), id).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name) {
          return t.value;
        }
      }
      return null;
    }

    return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
  }

  function tweenValue(transition, name, value) {
    var id = transition._id;

    transition.each(function() {
      var schedule = set$1(this, id);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });

    return function(node) {
      return get$1(node, id).value[name];
    };
  }

  function interpolate(a, b) {
    var c;
    return (typeof b === "number" ? interpolateNumber
        : b instanceof color ? interpolateRgb
        : (c = color(b)) ? (b = c, interpolateRgb)
        : interpolateString)(a, b);
  }

  function attrRemove$1(name) {
    return function() {
      this.removeAttribute(name);
    };
  }

  function attrRemoveNS$1(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }

  function attrConstant$1(name, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function attrConstantNS$1(fullname, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function attrFunction$1(name, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) { return void this.removeAttribute(name); }
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function attrFunctionNS$1(fullname, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) { return void this.removeAttributeNS(fullname.space, fullname.local); }
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function transition_attr(name, value) {
    var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
    return this.attrTween(name, typeof value === "function"
        ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
        : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
        : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
  }

  function attrInterpolate(name, i) {
    return function(t) {
      this.setAttribute(name, i(t));
    };
  }

  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }

  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) { t0 = (i0 = i) && attrInterpolateNS(fullname, i); }
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) { t0 = (i0 = i) && attrInterpolate(name, i); }
      return t0;
    }
    tween._value = value;
    return tween;
  }

  function transition_attrTween(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) { return (key = this.tween(key)) && key._value; }
    if (value == null) { return this.tween(key, null); }
    if (typeof value !== "function") { throw new Error; }
    var fullname = namespace(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  function delayFunction(id, value) {
    return function() {
      init(this, id).delay = +value.apply(this, arguments);
    };
  }

  function delayConstant(id, value) {
    return value = +value, function() {
      init(this, id).delay = value;
    };
  }

  function transition_delay(value) {
    var id = this._id;

    return arguments.length
        ? this.each((typeof value === "function"
            ? delayFunction
            : delayConstant)(id, value))
        : get$1(this.node(), id).delay;
  }

  function durationFunction(id, value) {
    return function() {
      set$1(this, id).duration = +value.apply(this, arguments);
    };
  }

  function durationConstant(id, value) {
    return value = +value, function() {
      set$1(this, id).duration = value;
    };
  }

  function transition_duration(value) {
    var id = this._id;

    return arguments.length
        ? this.each((typeof value === "function"
            ? durationFunction
            : durationConstant)(id, value))
        : get$1(this.node(), id).duration;
  }

  function easeConstant(id, value) {
    if (typeof value !== "function") { throw new Error; }
    return function() {
      set$1(this, id).ease = value;
    };
  }

  function transition_ease(value) {
    var id = this._id;

    return arguments.length
        ? this.each(easeConstant(id, value))
        : get$1(this.node(), id).ease;
  }

  function transition_filter(match) {
    if (typeof match !== "function") { match = matcher(match); }

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }

    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  function transition_merge(transition) {
    if (transition._id !== this._id) { throw new Error; }

    for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }

    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }

    return new Transition(merges, this._parents, this._name, this._id);
  }

  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0) { t = t.slice(0, i); }
      return !t || t === "start";
    });
  }

  function onFunction(id, name, listener) {
    var on0, on1, sit = start(name) ? init : set$1;
    return function() {
      var schedule = sit(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) { (on1 = (on0 = on).copy()).on(name, listener); }

      schedule.on = on1;
    };
  }

  function transition_on(name, listener) {
    var id = this._id;

    return arguments.length < 2
        ? get$1(this.node(), id).on.on(name)
        : this.each(onFunction(id, name, listener));
  }

  function removeFunction(id) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition) { if (+i !== id) { return; } }
      if (parent) { parent.removeChild(this); }
    };
  }

  function transition_remove() {
    return this.on("end.remove", removeFunction(this._id));
  }

  function transition_select(select) {
    var name = this._name,
        id = this._id;

    if (typeof select !== "function") { select = selector(select); }

    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node) { subnode.__data__ = node.__data__; }
          subgroup[i] = subnode;
          schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
        }
      }
    }

    return new Transition(subgroups, this._parents, name, id);
  }

  function transition_selectAll(select) {
    var name = this._name,
        id = this._id;

    if (typeof select !== "function") { select = selectorAll(select); }

    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
            if (child = children[k]) {
              schedule(child, name, id, k, children, inherit);
            }
          }
          subgroups.push(children);
          parents.push(node);
        }
      }
    }

    return new Transition(subgroups, parents, name, id);
  }

  var Selection$1 = selection.prototype.constructor;

  function transition_selection() {
    return new Selection$1(this._groups, this._parents);
  }

  function styleNull(name, interpolate) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0 = styleValue(this, name),
          string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }

  function styleRemove$1(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }

  function styleConstant$1(name, interpolate, value1) {
    var string00,
        string1 = value1 + "",
        interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null
          : string0 === string00 ? interpolate0
          : interpolate0 = interpolate(string00 = string0, value1);
    };
  }

  function styleFunction$1(name, interpolate, value) {
    var string00,
        string10,
        interpolate0;
    return function() {
      var string0 = styleValue(this, name),
          value1 = value(this),
          string1 = value1 + "";
      if (value1 == null) { string1 = value1 = (this.style.removeProperty(name), styleValue(this, name)); }
      return string0 === string1 ? null
          : string0 === string00 && string1 === string10 ? interpolate0
          : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }

  function styleMaybeRemove(id, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
    return function() {
      var schedule = set$1(this, id),
          on = schedule.on,
          listener = schedule.value[key] == null ? remove || (remove = styleRemove$1(name)) : undefined;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0 || listener0 !== listener) { (on1 = (on0 = on).copy()).on(event, listener0 = listener); }

      schedule.on = on1;
    };
  }

  function transition_style(name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
    return value == null ? this
        .styleTween(name, styleNull(name, i))
        .on("end.style." + name, styleRemove$1(name))
      : typeof value === "function" ? this
        .styleTween(name, styleFunction$1(name, i, tweenValue(this, "style." + name, value)))
        .each(styleMaybeRemove(this._id, name))
      : this
        .styleTween(name, styleConstant$1(name, i, value), priority)
        .on("end.style." + name, null);
  }

  function styleInterpolate(name, i, priority) {
    return function(t) {
      this.style.setProperty(name, i(t), priority);
    };
  }

  function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0) { t = (i0 = i) && styleInterpolate(name, i, priority); }
      return t;
    }
    tween._value = value;
    return tween;
  }

  function transition_styleTween(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) { return (key = this.tween(key)) && key._value; }
    if (value == null) { return this.tween(key, null); }
    if (typeof value !== "function") { throw new Error; }
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  function textConstant$1(value) {
    return function() {
      this.textContent = value;
    };
  }

  function textFunction$1(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }

  function transition_text(value) {
    return this.tween("text", typeof value === "function"
        ? textFunction$1(tweenValue(this, "text", value))
        : textConstant$1(value == null ? "" : value + ""));
  }

  function transition_transition() {
    var name = this._name,
        id0 = this._id,
        id1 = newId();

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          var inherit = get$1(node, id0);
          schedule(node, name, id1, i, group, {
            time: inherit.time + inherit.delay + inherit.duration,
            delay: 0,
            duration: inherit.duration,
            ease: inherit.ease
          });
        }
      }
    }

    return new Transition(groups, this._parents, name, id1);
  }

  function transition_end() {
    var on0, on1, that = this, id = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = {value: reject},
          end = {value: function() { if (--size === 0) { resolve(); } }};

      that.each(function() {
        var schedule = set$1(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and we’re done!
        // Otherwise, copy-on-write.
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }

        schedule.on = on1;
      });
    });
  }

  var id$2 = 0;

  function Transition(groups, parents, name, id) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id;
  }

  function transition(name) {
    return selection().transition(name);
  }

  function newId() {
    return ++id$2;
  }

  var selection_prototype = selection.prototype;

  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease,
    end: transition_end
  };

  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  var pi = Math.PI;

  var tau = 2 * Math.PI;

  var defaultTiming = {
    time: null, // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };

  function inherit(node, id) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id])) {
      if (!(node = node.parentNode)) {
        return defaultTiming.time = now(), defaultTiming;
      }
    }
    return timing;
  }

  function selection_transition(name) {
    var id,
        timing;

    if (name instanceof Transition) {
      id = name._id, name = name._name;
    } else {
      id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }

    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          schedule(node, name, id, i, group, timing || inherit(node, id));
        }
      }
    }

    return new Transition(groups, this._parents, name, id);
  }

  selection.prototype.interrupt = selection_interrupt;
  selection.prototype.transition = selection_transition;

  var pi$1 = Math.PI;

  var pi$2 = Math.PI;

  var prefix$1 = "$";

  function Map$2() {}

  Map$2.prototype = map$2.prototype = {
    constructor: Map$2,
    has: function(key) {
      return (prefix$1 + key) in this;
    },
    get: function(key) {
      return this[prefix$1 + key];
    },
    set: function(key, value) {
      this[prefix$1 + key] = value;
      return this;
    },
    remove: function(key) {
      var property = prefix$1 + key;
      return property in this && delete this[property];
    },
    clear: function() {
      for (var property in this) { if (property[0] === prefix$1) { delete this[property]; } }
    },
    keys: function() {
      var keys = [];
      for (var property in this) { if (property[0] === prefix$1) { keys.push(property.slice(1)); } }
      return keys;
    },
    values: function() {
      var values = [];
      for (var property in this) { if (property[0] === prefix$1) { values.push(this[property]); } }
      return values;
    },
    entries: function() {
      var entries = [];
      for (var property in this) { if (property[0] === prefix$1) { entries.push({key: property.slice(1), value: this[property]}); } }
      return entries;
    },
    size: function() {
      var size = 0;
      for (var property in this) { if (property[0] === prefix$1) { ++size; } }
      return size;
    },
    empty: function() {
      for (var property in this) { if (property[0] === prefix$1) { return false; } }
      return true;
    },
    each: function(f) {
      for (var property in this) { if (property[0] === prefix$1) { f(this[property], property.slice(1), this); } }
    }
  };

  function map$2(object, f) {
    var map = new Map$2;

    // Copy constructor.
    if (object instanceof Map$2) { object.each(function(value, key) { map.set(key, value); }); }

    // Index array by numeric index or specified key function.
    else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) { while (++i < n) { map.set(i, object[i]); } }
      else { while (++i < n) { map.set(f(o = object[i], i, object), o); } }
    }

    // Convert object to map.
    else if (object) { for (var key in object) { map.set(key, object[key]); } }

    return map;
  }

  function Set$1() {}

  var proto = map$2.prototype;

  Set$1.prototype = set$2.prototype = {
    constructor: Set$1,
    has: proto.has,
    add: function(value) {
      value += "";
      this[prefix$1 + value] = value;
      return this;
    },
    remove: proto.remove,
    clear: proto.clear,
    values: proto.keys,
    size: proto.size,
    empty: proto.empty,
    each: proto.each
  };

  function set$2(object, f) {
    var set = new Set$1;

    // Copy constructor.
    if (object instanceof Set$1) { object.each(function(value) { set.add(value); }); }

    // Otherwise, assume it’s an array.
    else if (object) {
      var i = -1, n = object.length;
      if (f == null) { while (++i < n) { set.add(object[i]); } }
      else { while (++i < n) { set.add(f(object[i], i, object)); } }
    }

    return set;
  }

  var EOL = {},
      EOF = {},
      QUOTE = 34,
      NEWLINE = 10,
      RETURN = 13;

  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name, i) {
      return JSON.stringify(name) + ": d[" + i + "]";
    }).join(",") + "}");
  }

  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row, i) {
      return f(object(row), i, columns);
    };
  }

  // Compute unique columns in order of discovery.
  function inferColumns(rows) {
    var columnSet = Object.create(null),
        columns = [];

    rows.forEach(function(row) {
      for (var column in row) {
        if (!(column in columnSet)) {
          columns.push(columnSet[column] = column);
        }
      }
    });

    return columns;
  }

  function pad(value, width) {
    var s = value + "", length = s.length;
    return length < width ? new Array(width - length + 1).join(0) + s : s;
  }

  function formatYear(year) {
    return year < 0 ? "-" + pad(-year, 6)
      : year > 9999 ? "+" + pad(year, 6)
      : pad(year, 4);
  }

  function formatDate(date) {
    var hours = date.getUTCHours(),
        minutes = date.getUTCMinutes(),
        seconds = date.getUTCSeconds(),
        milliseconds = date.getUTCMilliseconds();
    return isNaN(date) ? "Invalid Date"
        : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
        + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
        : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
        : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
        : "");
  }

  function dsvFormat(delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
        DELIMITER = delimiter.charCodeAt(0);

    function parse(text, f) {
      var convert, columns, rows = parseRows(text, function(row, i) {
        if (convert) { return convert(row, i - 1); }
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns || [];
      return rows;
    }

    function parseRows(text, f) {
      var rows = [], // output rows
          N = text.length,
          I = 0, // current character index
          n = 0, // current line number
          t, // current token
          eof = N <= 0, // current token followed by EOF?
          eol = false; // current token followed by EOL?

      // Strip the trailing newline.
      if (text.charCodeAt(N - 1) === NEWLINE) { --N; }
      if (text.charCodeAt(N - 1) === RETURN) { --N; }

      function token() {
        if (eof) { return EOF; }
        if (eol) { return eol = false, EOL; }

        // Unescape quotes.
        var i, j = I, c;
        if (text.charCodeAt(j) === QUOTE) {
          while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE){ }
          if ((i = I) >= N) { eof = true; }
          else if ((c = text.charCodeAt(I++)) === NEWLINE) { eol = true; }
          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) { ++I; } }
          return text.slice(j + 1, i - 1).replace(/""/g, "\"");
        }

        // Find next delimiter or newline.
        while (I < N) {
          if ((c = text.charCodeAt(i = I++)) === NEWLINE) { eol = true; }
          else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) { ++I; } }
          else if (c !== DELIMITER) { continue; }
          return text.slice(j, i);
        }

        // Return last token before EOF.
        return eof = true, text.slice(j, N);
      }

      while ((t = token()) !== EOF) {
        var row = [];
        while (t !== EOL && t !== EOF) { row.push(t), t = token(); }
        if (f && (row = f(row, n++)) == null) { continue; }
        rows.push(row);
      }

      return rows;
    }

    function preformatBody(rows, columns) {
      return rows.map(function(row) {
        return columns.map(function(column) {
          return formatValue(row[column]);
        }).join(delimiter);
      });
    }

    function format(rows, columns) {
      if (columns == null) { columns = inferColumns(rows); }
      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
    }

    function formatBody(rows, columns) {
      if (columns == null) { columns = inferColumns(rows); }
      return preformatBody(rows, columns).join("\n");
    }

    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }

    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }

    function formatValue(value) {
      return value == null ? ""
          : value instanceof Date ? formatDate(value)
          : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
          : value;
    }

    return {
      parse: parse,
      parseRows: parseRows,
      format: format,
      formatBody: formatBody,
      formatRows: formatRows
    };
  }

  var csv = dsvFormat(",");

  var tsv = dsvFormat("\t");

  function tree_add(d) {
    var x = +this._x.call(null, d),
        y = +this._y.call(null, d);
    return add(this.cover(x, y), x, y, d);
  }

  function add(tree, x, y, d) {
    if (isNaN(x) || isNaN(y)) { return tree; } // ignore invalid points

    var parent,
        node = tree._root,
        leaf = {data: d},
        x0 = tree._x0,
        y0 = tree._y0,
        x1 = tree._x1,
        y1 = tree._y1,
        xm,
        ym,
        xp,
        yp,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) { return tree._root = leaf, tree; }

    // Find the existing leaf for the new point, or add it.
    while (node.length) {
      if (right = x >= (xm = (x0 + x1) / 2)) { x0 = xm; } else { x1 = xm; }
      if (bottom = y >= (ym = (y0 + y1) / 2)) { y0 = ym; } else { y1 = ym; }
      if (parent = node, !(node = node[i = bottom << 1 | right])) { return parent[i] = leaf, tree; }
    }

    // Is the new point is exactly coincident with the existing point?
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x === xp && y === yp) { return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; }

    // Otherwise, split the leaf node until the old and new point are separated.
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right = x >= (xm = (x0 + x1) / 2)) { x0 = xm; } else { x1 = xm; }
      if (bottom = y >= (ym = (y0 + y1) / 2)) { y0 = ym; } else { y1 = ym; }
    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
    return parent[j] = node, parent[i] = leaf, tree;
  }

  function addAll(data) {
    var d, i, n = data.length,
        x,
        y,
        xz = new Array(n),
        yz = new Array(n),
        x0 = Infinity,
        y0 = Infinity,
        x1 = -Infinity,
        y1 = -Infinity;

    // Compute the points and their extent.
    for (i = 0; i < n; ++i) {
      if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) { continue; }
      xz[i] = x;
      yz[i] = y;
      if (x < x0) { x0 = x; }
      if (x > x1) { x1 = x; }
      if (y < y0) { y0 = y; }
      if (y > y1) { y1 = y; }
    }

    // If there were no (valid) points, abort.
    if (x0 > x1 || y0 > y1) { return this; }

    // Expand the tree to cover the new points.
    this.cover(x0, y0).cover(x1, y1);

    // Add the new points.
    for (i = 0; i < n; ++i) {
      add(this, xz[i], yz[i], data[i]);
    }

    return this;
  }

  function tree_cover(x, y) {
    if (isNaN(x = +x) || isNaN(y = +y)) { return this; } // ignore invalid points

    var x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1;

    // If the quadtree has no extent, initialize them.
    // Integer extent are necessary so that if we later double the extent,
    // the existing quadrant boundaries don’t change due to floating point error!
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x)) + 1;
      y1 = (y0 = Math.floor(y)) + 1;
    }

    // Otherwise, double repeatedly to cover.
    else {
      var z = x1 - x0,
          node = this._root,
          parent,
          i;

      while (x0 > x || x >= x1 || y0 > y || y >= y1) {
        i = (y < y0) << 1 | (x < x0);
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0: x1 = x0 + z, y1 = y0 + z; break;
          case 1: x0 = x1 - z, y1 = y0 + z; break;
          case 2: x1 = x0 + z, y0 = y1 - z; break;
          case 3: x0 = x1 - z, y0 = y1 - z; break;
        }
      }

      if (this._root && this._root.length) { this._root = node; }
    }

    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  }

  function tree_data() {
    var data = [];
    this.visit(function(node) {
      if (!node.length) { do { data.push(node.data); } while (node = node.next) }
    });
    return data;
  }

  function tree_extent(_) {
    return arguments.length
        ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
        : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  function Quad(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  }

  function tree_find(x, y, radius) {
    var data,
        x0 = this._x0,
        y0 = this._y0,
        x1,
        y1,
        x2,
        y2,
        x3 = this._x1,
        y3 = this._y1,
        quads = [],
        node = this._root,
        q,
        i;

    if (node) { quads.push(new Quad(node, x0, y0, x3, y3)); }
    if (radius == null) { radius = Infinity; }
    else {
      x0 = x - radius, y0 = y - radius;
      x3 = x + radius, y3 = y + radius;
      radius *= radius;
    }

    while (q = quads.pop()) {

      // Stop searching if this quadrant can’t contain a closer node.
      if (!(node = q.node)
          || (x1 = q.x0) > x3
          || (y1 = q.y0) > y3
          || (x2 = q.x1) < x0
          || (y2 = q.y1) < y0) { continue; }

      // Bisect the current quadrant.
      if (node.length) {
        var xm = (x1 + x2) / 2,
            ym = (y1 + y2) / 2;

        quads.push(
          new Quad(node[3], xm, ym, x2, y2),
          new Quad(node[2], x1, ym, xm, y2),
          new Quad(node[1], xm, y1, x2, ym),
          new Quad(node[0], x1, y1, xm, ym)
        );

        // Visit the closest quadrant first.
        if (i = (y >= ym) << 1 | (x >= xm)) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      }

      // Visit this point. (Visiting coincident points isn’t necessary!)
      else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
    }

    return data;
  }

  function tree_remove(d) {
    if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) { return this; } // ignore invalid points

    var parent,
        node = this._root,
        retainer,
        previous,
        next,
        x0 = this._x0,
        y0 = this._y0,
        x1 = this._x1,
        y1 = this._y1,
        x,
        y,
        xm,
        ym,
        right,
        bottom,
        i,
        j;

    // If the tree is empty, initialize the root as a leaf.
    if (!node) { return this; }

    // Find the leaf node for the point.
    // While descending, also retain the deepest parent with a non-removed sibling.
    if (node.length) { while (true) {
      if (right = x >= (xm = (x0 + x1) / 2)) { x0 = xm; } else { x1 = xm; }
      if (bottom = y >= (ym = (y0 + y1) / 2)) { y0 = ym; } else { y1 = ym; }
      if (!(parent = node, node = node[i = bottom << 1 | right])) { return this; }
      if (!node.length) { break; }
      if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) { retainer = parent, j = i; }
    } }

    // Find the point to remove.
    while (node.data !== d) { if (!(previous = node, node = node.next)) { return this; } }
    if (next = node.next) { delete node.next; }

    // If there are multiple coincident points, remove just the point.
    if (previous) { return (next ? previous.next = next : delete previous.next), this; }

    // If this is the root point, remove it.
    if (!parent) { return this._root = next, this; }

    // Remove this leaf.
    next ? parent[i] = next : delete parent[i];

    // If the parent now contains exactly one leaf, collapse superfluous parents.
    if ((node = parent[0] || parent[1] || parent[2] || parent[3])
        && node === (parent[3] || parent[2] || parent[1] || parent[0])
        && !node.length) {
      if (retainer) { retainer[j] = node; }
      else { this._root = node; }
    }

    return this;
  }

  function removeAll(data) {
    for (var i = 0, n = data.length; i < n; ++i) { this.remove(data[i]); }
    return this;
  }

  function tree_root() {
    return this._root;
  }

  function tree_size() {
    var size = 0;
    this.visit(function(node) {
      if (!node.length) { do { ++size; } while (node = node.next) }
    });
    return size;
  }

  function tree_visit(callback) {
    var quads = [], q, node = this._root, child, x0, y0, x1, y1;
    if (node) { quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1)); }
    while (q = quads.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3]) { quads.push(new Quad(child, xm, ym, x1, y1)); }
        if (child = node[2]) { quads.push(new Quad(child, x0, ym, xm, y1)); }
        if (child = node[1]) { quads.push(new Quad(child, xm, y0, x1, ym)); }
        if (child = node[0]) { quads.push(new Quad(child, x0, y0, xm, ym)); }
      }
    }
    return this;
  }

  function tree_visitAfter(callback) {
    var quads = [], next = [], q;
    if (this._root) { quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1)); }
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[0]) { quads.push(new Quad(child, x0, y0, xm, ym)); }
        if (child = node[1]) { quads.push(new Quad(child, xm, y0, x1, ym)); }
        if (child = node[2]) { quads.push(new Quad(child, x0, ym, xm, y1)); }
        if (child = node[3]) { quads.push(new Quad(child, xm, ym, x1, y1)); }
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  function defaultX(d) {
    return d[0];
  }

  function tree_x(_) {
    return arguments.length ? (this._x = _, this) : this._x;
  }

  function defaultY(d) {
    return d[1];
  }

  function tree_y(_) {
    return arguments.length ? (this._y = _, this) : this._y;
  }

  function quadtree(nodes, x, y) {
    var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }

  function Quadtree(x, y, x0, y0, x1, y1) {
    this._x = x;
    this._y = y;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = undefined;
  }

  function leaf_copy(leaf) {
    var copy = {data: leaf.data}, next = copy;
    while (leaf = leaf.next) { next = next.next = {data: leaf.data}; }
    return copy;
  }

  var treeProto = quadtree.prototype = Quadtree.prototype;

  treeProto.copy = function() {
    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
        node = this._root,
        nodes,
        child;

    if (!node) { return copy; }

    if (!node.length) { return copy._root = leaf_copy(node), copy; }

    nodes = [{source: node, target: copy._root = new Array(4)}];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length) { nodes.push({source: child, target: node.target[i] = new Array(4)}); }
          else { node.target[i] = leaf_copy(child); }
        }
      }
    }

    return copy;
  };

  treeProto.add = tree_add;
  treeProto.addAll = addAll;
  treeProto.cover = tree_cover;
  treeProto.data = tree_data;
  treeProto.extent = tree_extent;
  treeProto.find = tree_find;
  treeProto.remove = tree_remove;
  treeProto.removeAll = removeAll;
  treeProto.root = tree_root;
  treeProto.size = tree_size;
  treeProto.visit = tree_visit;
  treeProto.visitAfter = tree_visitAfter;
  treeProto.x = tree_x;
  treeProto.y = tree_y;

  var initialAngle = Math.PI * (3 - Math.sqrt(5));

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) { return null; } // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) { g = Math.max(1, width - length); }
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) { break; }
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) { throw new Error("invalid format: " + specifier); }
    var match;
    this.fill = match[1] || " ";
    this.align = match[2] || ">";
    this.sign = match[3] || "-";
    this.symbol = match[4] || "";
    this.zero = !!match[5];
    this.width = match[6] && +match[6];
    this.comma = !!match[7];
    this.precision = match[8] && +match[8].slice(1);
    this.trim = !!match[9];
    this.type = match[10] || "";
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) { i0 = i; } i1 = i; break;
        default: if (i0 > 0) { if (!+s[i]) { break out; } i0 = 0; } break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) { return x + ""; }
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) { return x + ""; }
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  function identity$1(x) {
    return x;
  }

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$1,
        currency = locale.currency,
        decimal = locale.decimal,
        numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$1,
        percent = locale.percent || "%";

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") { comma = true, type = "g"; }

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes[type]) { precision == null && (precision = 12), trim = true, type = "g"; }

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) { zero = true, fill = "0", align = "="; }

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Perform the initial formatting.
          var valueNegative = value < 0;
          value = formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) { value = formatTrim(value); }

          // If a negative value rounds to zero during formatting, treat as positive.
          if (valueNegative && +value === 0) { valueNegative = false; }

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) { value = group(value, Infinity); }

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) { value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = ""; }

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  var format;
  var formatPrefix;

  defaultLocale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // Adds floating point numbers with twice the normal precision.
  // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
  // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
  // 305–363 (1997).
  // Code adapted from GeographicLib by Charles F. F. Karney,
  // http://geographiclib.sourceforge.net/

  function adder() {
    return new Adder;
  }

  function Adder() {
    this.reset();
  }

  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = // rounded value
      this.t = 0; // exact error
    },
    add: function(y) {
      add$1(temp, y, this.t);
      add$1(this, temp.s, this.s);
      if (this.s) { this.t += temp.t; }
      else { this.s = temp.t; }
    },
    valueOf: function() {
      return this.s;
    }
  };

  var temp = new Adder;

  function add$1(adder, a, b) {
    var x = adder.s = a + b,
        bv = x - a,
        av = x - bv;
    adder.t = (a - av) + (b - bv);
  }

  var pi$3 = Math.PI;

  var areaRingSum = adder();

  var areaSum = adder();

  var deltaSum = adder();

  var sum = adder();

  var lengthSum = adder();

  var areaSum$1 = adder(),
      areaRingSum$1 = adder();

  var lengthSum$1 = adder();

  var t0$1 = new Date,
      t1$1 = new Date;

  function newInterval(floori, offseti, count, field) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
    };

    interval.round = function(date) {
      var d0 = interval(date),
          d1 = interval.ceil(date);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [], previous;
      start = interval.ceil(start);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) { return range; } // also handles Invalid Date
      do { range.push(previous = new Date(+start)), offseti(start, step), floori(start); }
      while (previous < start && start < stop);
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        if (date >= date) { while (floori(date), !test(date)) { date.setTime(date - 1); } }
      }, function(date, step) {
        if (date >= date) {
          if (step < 0) { while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
          } } else { while (--step >= 0) {
            while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
          } }
        }
      });
    };

    if (count) {
      interval.count = function(start, end) {
        t0$1.setTime(+start), t1$1.setTime(+end);
        floori(t0$1), floori(t1$1);
        return Math.floor(count(t0$1, t1$1));
      };

      interval.every = function(step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null
            : !(step > 1) ? interval
            : interval.filter(field
                ? function(d) { return field(d) % step === 0; }
                : function(d) { return interval.count(0, d) % step === 0; });
      };
    }

    return interval;
  }

  var millisecond = newInterval(function() {
    // noop
  }, function(date, step) {
    date.setTime(+date + step);
  }, function(start, end) {
    return end - start;
  });

  // An optimized implementation for this simple case.
  millisecond.every = function(k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) { return null; }
    if (!(k > 1)) { return millisecond; }
    return newInterval(function(date) {
      date.setTime(Math.floor(date / k) * k);
    }, function(date, step) {
      date.setTime(+date + step * k);
    }, function(start, end) {
      return (end - start) / k;
    });
  };

  var durationSecond = 1e3;
  var durationMinute = 6e4;
  var durationHour = 36e5;
  var durationDay = 864e5;
  var durationWeek = 6048e5;

  var second = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds());
  }, function(date, step) {
    date.setTime(+date + step * durationSecond);
  }, function(start, end) {
    return (end - start) / durationSecond;
  }, function(date) {
    return date.getUTCSeconds();
  });

  var minute = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute);
  }, function(start, end) {
    return (end - start) / durationMinute;
  }, function(date) {
    return date.getMinutes();
  });

  var hour = newInterval(function(date) {
    date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
  }, function(date, step) {
    date.setTime(+date + step * durationHour);
  }, function(start, end) {
    return (end - start) / durationHour;
  }, function(date) {
    return date.getHours();
  });

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
  }, function(date) {
    return date.getDate() - 1;
  });

  function weekday(i) {
    return newInterval(function(date) {
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);
  var tuesday = weekday(2);
  var wednesday = weekday(3);
  var thursday = weekday(4);
  var friday = weekday(5);
  var saturday = weekday(6);

  var month = newInterval(function(date) {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setMonth(date.getMonth() + step);
  }, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, function(date) {
    return date.getMonth();
  });

  var year = newInterval(function(date) {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  }, function(date) {
    return date.getFullYear();
  });

  // An optimized implementation for this simple case.
  year.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setFullYear(Math.floor(date.getFullYear() / k) * k);
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step * k);
    });
  };

  var utcMinute = newInterval(function(date) {
    date.setUTCSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationMinute);
  }, function(start, end) {
    return (end - start) / durationMinute;
  }, function(date) {
    return date.getUTCMinutes();
  });

  var utcHour = newInterval(function(date) {
    date.setUTCMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * durationHour);
  }, function(start, end) {
    return (end - start) / durationHour;
  }, function(date) {
    return date.getUTCHours();
  });

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / durationDay;
  }, function(date) {
    return date.getUTCDate() - 1;
  });

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / durationWeek;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);

  var utcMonth = newInterval(function(date) {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, function(date) {
    return date.getUTCMonth();
  });

  var utcYear = newInterval(function(date) {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, function(date) {
    return date.getUTCFullYear();
  });

  // An optimized implementation for this simple case.
  utcYear.every = function(k) {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
      date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step * k);
    });
  };

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newYear(y) {
    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
  }

  function formatLocale$1(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear$1,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function(date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        if (!(date instanceof Date)) { date = new Date(+date); }

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) { c = specifier.charAt(++i); }
            else { pad = c === "e" ? " " : "0"; }
            if (format = formats[c]) { c = format(date, pad); }
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, newDate) {
      return function(string) {
        var d = newYear(1900),
            i = parseSpecifier(d, specifier, string += "", 0),
            week, day$1;
        if (i != string.length) { return null; }

        // If a UNIX timestamp is specified, return it.
        if ("Q" in d) { return new Date(d.Q); }

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) { d.H = d.H % 12 + d.p * 12; }

        // Convert day-of-week and week-of-year to day-of-year.
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) { return null; }
          if (!("w" in d)) { d.w = 1; }
          if ("Z" in d) {
            week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
            week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = newDate(newYear(d.y)), day$1 = week.getDay();
            week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
            week = day.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) { d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0; }
          day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
        }

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        return newDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) { return -1; }
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || ((j = parse(d, string, j)) < 0)) { return -1; }
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() { return specifier; };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", localDate);
        p.toString = function() { return specifier; };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() { return specifier; };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier, utcDate);
        p.toString = function() { return specifier; };
        return p;
      }
    };
  }

  var pads = {"-": "", "_": " ", "0": "0"},
      numberRe = /^\s*\d+/, // note: ignores next directive
      percentRe = /^%/,
      requoteRe = /[\\^$*+?|[\]().{}]/g;

  function pad$1(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    var map = {}, i = -1, n = names.length;
    while (++i < n) { map[names[i].toLowerCase()] = i; }
    return map;
  }

  function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }

  function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad$1(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad$1(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad$1(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad$1(1 + day.count(year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad$1(d.getMilliseconds(), p, 3);
  }

  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }

  function formatMonthNumber(d, p) {
    return pad$1(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad$1(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad$1(d.getSeconds(), p, 2);
  }

  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }

  function formatWeekNumberSunday(d, p) {
    return pad$1(sunday.count(year(d), d), p, 2);
  }

  function formatWeekNumberISO(d, p) {
    var day = d.getDay();
    d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    return pad$1(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
  }

  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad$1(monday.count(year(d), d), p, 2);
  }

  function formatYear$1(d, p) {
    return pad$1(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad$1(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad$1(z / 60 | 0, "0", 2)
        + pad$1(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad$1(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad$1(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad$1(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad$1(1 + utcDay.count(utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad$1(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }

  function formatUTCMonthNumber(d, p) {
    return pad$1(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad$1(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad$1(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad$1(utcSunday.count(utcYear(d), d), p, 2);
  }

  function formatUTCWeekNumberISO(d, p) {
    var day = d.getUTCDay();
    d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    return pad$1(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }

  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad$1(utcMonday.count(utcYear(d), d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad$1(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad$1(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  function formatUnixTimestamp(d) {
    return +d;
  }

  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1000);
  }

  var locale$1;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;

  defaultLocale$1({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    timeFormat = locale$1.format;
    timeParse = locale$1.parse;
    utcFormat = locale$1.utcFormat;
    utcParse = locale$1.utcParse;
    return locale$1;
  }

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

  function formatIsoNative(date) {
    return date.toISOString();
  }

  var formatIso = Date.prototype.toISOString
      ? formatIsoNative
      : utcFormat(isoSpecifier);

  function parseIsoNative(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  }

  var parseIso = +new Date("2000-01-01T00:00:00.000Z")
      ? parseIsoNative
      : utcParse(isoSpecifier);

  function colors(specifier) {
    var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
    while (i < n) { colors[i] = "#" + specifier.slice(i * 6, ++i * 6); }
    return colors;
  }

  colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

  colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

  colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

  colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

  colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

  colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

  colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

  function ramp(scheme) {
    return rgbBasis(scheme[scheme.length - 1]);
  }

  var scheme = new Array(3).concat(
    "d8b365f5f5f55ab4ac",
    "a6611adfc27d80cdc1018571",
    "a6611adfc27df5f5f580cdc1018571",
    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
  ).map(colors);

  ramp(scheme);

  var scheme$1 = new Array(3).concat(
    "af8dc3f7f7f77fbf7b",
    "7b3294c2a5cfa6dba0008837",
    "7b3294c2a5cff7f7f7a6dba0008837",
    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
  ).map(colors);

  ramp(scheme$1);

  var scheme$2 = new Array(3).concat(
    "e9a3c9f7f7f7a1d76a",
    "d01c8bf1b6dab8e1864dac26",
    "d01c8bf1b6daf7f7f7b8e1864dac26",
    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
  ).map(colors);

  ramp(scheme$2);

  var scheme$3 = new Array(3).concat(
    "998ec3f7f7f7f1a340",
    "5e3c99b2abd2fdb863e66101",
    "5e3c99b2abd2f7f7f7fdb863e66101",
    "542788998ec3d8daebfee0b6f1a340b35806",
    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
  ).map(colors);

  ramp(scheme$3);

  var scheme$4 = new Array(3).concat(
    "ef8a62f7f7f767a9cf",
    "ca0020f4a58292c5de0571b0",
    "ca0020f4a582f7f7f792c5de0571b0",
    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
  ).map(colors);

  ramp(scheme$4);

  var scheme$5 = new Array(3).concat(
    "ef8a62ffffff999999",
    "ca0020f4a582bababa404040",
    "ca0020f4a582ffffffbababa404040",
    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
  ).map(colors);

  ramp(scheme$5);

  var scheme$6 = new Array(3).concat(
    "fc8d59ffffbf91bfdb",
    "d7191cfdae61abd9e92c7bb6",
    "d7191cfdae61ffffbfabd9e92c7bb6",
    "d73027fc8d59fee090e0f3f891bfdb4575b4",
    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
  ).map(colors);

  ramp(scheme$6);

  var scheme$7 = new Array(3).concat(
    "fc8d59ffffbf91cf60",
    "d7191cfdae61a6d96a1a9641",
    "d7191cfdae61ffffbfa6d96a1a9641",
    "d73027fc8d59fee08bd9ef8b91cf601a9850",
    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
  ).map(colors);

  ramp(scheme$7);

  var scheme$8 = new Array(3).concat(
    "fc8d59ffffbf99d594",
    "d7191cfdae61abdda42b83ba",
    "d7191cfdae61ffffbfabdda42b83ba",
    "d53e4ffc8d59fee08be6f59899d5943288bd",
    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
  ).map(colors);

  ramp(scheme$8);

  var scheme$9 = new Array(3).concat(
    "e5f5f999d8c92ca25f",
    "edf8fbb2e2e266c2a4238b45",
    "edf8fbb2e2e266c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
  ).map(colors);

  ramp(scheme$9);

  var scheme$a = new Array(3).concat(
    "e0ecf49ebcda8856a7",
    "edf8fbb3cde38c96c688419d",
    "edf8fbb3cde38c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
  ).map(colors);

  ramp(scheme$a);

  var scheme$b = new Array(3).concat(
    "e0f3dba8ddb543a2ca",
    "f0f9e8bae4bc7bccc42b8cbe",
    "f0f9e8bae4bc7bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
  ).map(colors);

  ramp(scheme$b);

  var scheme$c = new Array(3).concat(
    "fee8c8fdbb84e34a33",
    "fef0d9fdcc8afc8d59d7301f",
    "fef0d9fdcc8afc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
  ).map(colors);

  ramp(scheme$c);

  var scheme$d = new Array(3).concat(
    "ece2f0a6bddb1c9099",
    "f6eff7bdc9e167a9cf02818a",
    "f6eff7bdc9e167a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
  ).map(colors);

  ramp(scheme$d);

  var scheme$e = new Array(3).concat(
    "ece7f2a6bddb2b8cbe",
    "f1eef6bdc9e174a9cf0570b0",
    "f1eef6bdc9e174a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
  ).map(colors);

  ramp(scheme$e);

  var scheme$f = new Array(3).concat(
    "e7e1efc994c7dd1c77",
    "f1eef6d7b5d8df65b0ce1256",
    "f1eef6d7b5d8df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
  ).map(colors);

  ramp(scheme$f);

  var scheme$g = new Array(3).concat(
    "fde0ddfa9fb5c51b8a",
    "feebe2fbb4b9f768a1ae017e",
    "feebe2fbb4b9f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
  ).map(colors);

  ramp(scheme$g);

  var scheme$h = new Array(3).concat(
    "edf8b17fcdbb2c7fb8",
    "ffffcca1dab441b6c4225ea8",
    "ffffcca1dab441b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
  ).map(colors);

  ramp(scheme$h);

  var scheme$i = new Array(3).concat(
    "f7fcb9addd8e31a354",
    "ffffccc2e69978c679238443",
    "ffffccc2e69978c67931a354006837",
    "ffffccd9f0a3addd8e78c67931a354006837",
    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
  ).map(colors);

  ramp(scheme$i);

  var scheme$j = new Array(3).concat(
    "fff7bcfec44fd95f0e",
    "ffffd4fed98efe9929cc4c02",
    "ffffd4fed98efe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
  ).map(colors);

  ramp(scheme$j);

  var scheme$k = new Array(3).concat(
    "ffeda0feb24cf03b20",
    "ffffb2fecc5cfd8d3ce31a1c",
    "ffffb2fecc5cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
  ).map(colors);

  ramp(scheme$k);

  var scheme$l = new Array(3).concat(
    "deebf79ecae13182bd",
    "eff3ffbdd7e76baed62171b5",
    "eff3ffbdd7e76baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
  ).map(colors);

  ramp(scheme$l);

  var scheme$m = new Array(3).concat(
    "e5f5e0a1d99b31a354",
    "edf8e9bae4b374c476238b45",
    "edf8e9bae4b374c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
  ).map(colors);

  ramp(scheme$m);

  var scheme$n = new Array(3).concat(
    "f0f0f0bdbdbd636363",
    "f7f7f7cccccc969696525252",
    "f7f7f7cccccc969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
  ).map(colors);

  ramp(scheme$n);

  var scheme$o = new Array(3).concat(
    "efedf5bcbddc756bb1",
    "f2f0f7cbc9e29e9ac86a51a3",
    "f2f0f7cbc9e29e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
  ).map(colors);

  ramp(scheme$o);

  var scheme$p = new Array(3).concat(
    "fee0d2fc9272de2d26",
    "fee5d9fcae91fb6a4acb181d",
    "fee5d9fcae91fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
  ).map(colors);

  ramp(scheme$p);

  var scheme$q = new Array(3).concat(
    "fee6cefdae6be6550d",
    "feeddefdbe85fd8d3cd94701",
    "feeddefdbe85fd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
  ).map(colors);

  ramp(scheme$q);

  cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

  var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

  var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

  var c = cubehelix();

  var c$1 = rgb(),
      pi_1_3 = Math.PI / 3,
      pi_2_3 = Math.PI * 2 / 3;

  function ramp$1(range) {
    var n = range.length;
    return function(t) {
      return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }

  ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

  var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

  var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

  var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  var pi$4 = Math.PI;

  function sign(x) {
    return x < 0 ? -1 : 1;
  }

  // Calculate the slopes of the tangents (Hermite-type interpolation) based on
  // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
  // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
  // NOV(II), P. 443, 1990.
  function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0,
        h1 = x2 - that._x1,
        s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
        s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
        p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }

  // Calculate a one-sided slope.
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }

  // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
  // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
  // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
  function point(that, t0, t1) {
    var x0 = that._x0,
        y0 = that._y0,
        x1 = that._x1,
        y1 = that._y1,
        dx = (x1 - x0) / 3;
    that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
  }

  function MonotoneX(context) {
    this._context = context;
  }

  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 =
      this._y0 = this._y1 =
      this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2: this._context.lineTo(this._x1, this._y1); break;
        case 3: point(this, this._t0, slope2(this, this._t0)); break;
      }
      if (this._line || (this._line !== 0 && this._point === 1)) { this._context.closePath(); }
      this._line = 1 - this._line;
    },
    point: function(x, y) {
      var t1 = NaN;

      x = +x, y = +y;
      if (x === this._x1 && y === this._y1) { return; } // Ignore coincident points.
      switch (this._point) {
        case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
        case 1: this._point = 2; break;
        case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
        default: point(this, this._t0, t1 = slope3(this, x, y)); break;
      }

      this._x0 = this._x1, this._x1 = x;
      this._y0 = this._y1, this._y1 = y;
      this._t0 = t1;
    }
  };

  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }

  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
    MonotoneX.prototype.point.call(this, y, x);
  };

  function ReflectContext(context) {
    this._context = context;
  }

  ReflectContext.prototype = {
    moveTo: function(x, y) { this._context.moveTo(y, x); },
    closePath: function() { this._context.closePath(); },
    lineTo: function(x, y) { this._context.lineTo(y, x); },
    bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
  };

  var fastclick = createCommonjsModule(function (module) {
  (function () {

  	/**
  	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
  	 *
  	 * @codingstandard ftlabs-jsv2
  	 * @copyright The Financial Times Limited [All Rights Reserved]
  	 * @license MIT License (see LICENSE.txt)
  	 */

  	/*jslint browser:true, node:true*/
  	/*global define, Event, Node*/


  	/**
  	 * Instantiate fast-clicking listeners on the specified layer.
  	 *
  	 * @constructor
  	 * @param {Element} layer The layer to listen on
  	 * @param {Object} [options={}] The options to override the defaults
  	 */
  	function FastClick(layer, options) {
  		var oldOnClick;

  		options = options || {};

  		/**
  		 * Whether a click is currently being tracked.
  		 *
  		 * @type boolean
  		 */
  		this.trackingClick = false;


  		/**
  		 * Timestamp for when click tracking started.
  		 *
  		 * @type number
  		 */
  		this.trackingClickStart = 0;


  		/**
  		 * The element being tracked for a click.
  		 *
  		 * @type EventTarget
  		 */
  		this.targetElement = null;


  		/**
  		 * X-coordinate of touch start event.
  		 *
  		 * @type number
  		 */
  		this.touchStartX = 0;


  		/**
  		 * Y-coordinate of touch start event.
  		 *
  		 * @type number
  		 */
  		this.touchStartY = 0;


  		/**
  		 * ID of the last touch, retrieved from Touch.identifier.
  		 *
  		 * @type number
  		 */
  		this.lastTouchIdentifier = 0;


  		/**
  		 * Touchmove boundary, beyond which a click will be cancelled.
  		 *
  		 * @type number
  		 */
  		this.touchBoundary = options.touchBoundary || 10;


  		/**
  		 * The FastClick layer.
  		 *
  		 * @type Element
  		 */
  		this.layer = layer;

  		/**
  		 * The minimum time between tap(touchstart and touchend) events
  		 *
  		 * @type number
  		 */
  		this.tapDelay = options.tapDelay || 200;

  		/**
  		 * The maximum time for a tap
  		 *
  		 * @type number
  		 */
  		this.tapTimeout = options.tapTimeout || 700;

  		if (FastClick.notNeeded(layer)) {
  			return;
  		}

  		// Some old versions of Android don't have Function.prototype.bind
  		function bind(method, context) {
  			return function() { return method.apply(context, arguments); };
  		}


  		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
  		var context = this;
  		for (var i = 0, l = methods.length; i < l; i++) {
  			context[methods[i]] = bind(context[methods[i]], context);
  		}

  		// Set up event handlers as required
  		if (deviceIsAndroid) {
  			layer.addEventListener('mouseover', this.onMouse, true);
  			layer.addEventListener('mousedown', this.onMouse, true);
  			layer.addEventListener('mouseup', this.onMouse, true);
  		}

  		layer.addEventListener('click', this.onClick, true);
  		layer.addEventListener('touchstart', this.onTouchStart, false);
  		layer.addEventListener('touchmove', this.onTouchMove, false);
  		layer.addEventListener('touchend', this.onTouchEnd, false);
  		layer.addEventListener('touchcancel', this.onTouchCancel, false);

  		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
  		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
  		// layer when they are cancelled.
  		if (!Event.prototype.stopImmediatePropagation) {
  			layer.removeEventListener = function(type, callback, capture) {
  				var rmv = Node.prototype.removeEventListener;
  				if (type === 'click') {
  					rmv.call(layer, type, callback.hijacked || callback, capture);
  				} else {
  					rmv.call(layer, type, callback, capture);
  				}
  			};

  			layer.addEventListener = function(type, callback, capture) {
  				var adv = Node.prototype.addEventListener;
  				if (type === 'click') {
  					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
  						if (!event.propagationStopped) {
  							callback(event);
  						}
  					}), capture);
  				} else {
  					adv.call(layer, type, callback, capture);
  				}
  			};
  		}

  		// If a handler is already declared in the element's onclick attribute, it will be fired before
  		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
  		// adding it as listener.
  		if (typeof layer.onclick === 'function') {

  			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
  			// - the old one won't work if passed to addEventListener directly.
  			oldOnClick = layer.onclick;
  			layer.addEventListener('click', function(event) {
  				oldOnClick(event);
  			}, false);
  			layer.onclick = null;
  		}
  	}

  	/**
  	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
  	*
  	* @type boolean
  	*/
  	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

  	/**
  	 * Android requires exceptions.
  	 *
  	 * @type boolean
  	 */
  	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


  	/**
  	 * iOS requires exceptions.
  	 *
  	 * @type boolean
  	 */
  	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


  	/**
  	 * iOS 4 requires an exception for select elements.
  	 *
  	 * @type boolean
  	 */
  	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


  	/**
  	 * iOS 6.0-7.* requires the target element to be manually derived
  	 *
  	 * @type boolean
  	 */
  	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

  	/**
  	 * BlackBerry requires exceptions.
  	 *
  	 * @type boolean
  	 */
  	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

  	/**
  	 * Determine whether a given element requires a native click.
  	 *
  	 * @param {EventTarget|Element} target Target DOM element
  	 * @returns {boolean} Returns true if the element needs a native click
  	 */
  	FastClick.prototype.needsClick = function(target) {
  		switch (target.nodeName.toLowerCase()) {

  		// Don't send a synthetic click to disabled inputs (issue #62)
  		case 'button':
  		case 'select':
  		case 'textarea':
  			if (target.disabled) {
  				return true;
  			}

  			break;
  		case 'input':

  			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
  			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
  				return true;
  			}

  			break;
  		case 'label':
  		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
  		case 'video':
  			return true;
  		}

  		return (/\bneedsclick\b/).test(target.className);
  	};


  	/**
  	 * Determine whether a given element requires a call to focus to simulate click into element.
  	 *
  	 * @param {EventTarget|Element} target Target DOM element
  	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
  	 */
  	FastClick.prototype.needsFocus = function(target) {
  		switch (target.nodeName.toLowerCase()) {
  		case 'textarea':
  			return true;
  		case 'select':
  			return !deviceIsAndroid;
  		case 'input':
  			switch (target.type) {
  			case 'button':
  			case 'checkbox':
  			case 'file':
  			case 'image':
  			case 'radio':
  			case 'submit':
  				return false;
  			}

  			// No point in attempting to focus disabled inputs
  			return !target.disabled && !target.readOnly;
  		default:
  			return (/\bneedsfocus\b/).test(target.className);
  		}
  	};


  	/**
  	 * Send a click event to the specified element.
  	 *
  	 * @param {EventTarget|Element} targetElement
  	 * @param {Event} event
  	 */
  	FastClick.prototype.sendClick = function(targetElement, event) {
  		var clickEvent, touch;

  		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
  		if (document.activeElement && document.activeElement !== targetElement) {
  			document.activeElement.blur();
  		}

  		touch = event.changedTouches[0];

  		// Synthesise a click event, with an extra attribute so it can be tracked
  		clickEvent = document.createEvent('MouseEvents');
  		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  		clickEvent.forwardedTouchEvent = true;
  		targetElement.dispatchEvent(clickEvent);
  	};

  	FastClick.prototype.determineEventType = function(targetElement) {

  		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
  		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
  			return 'mousedown';
  		}

  		return 'click';
  	};


  	/**
  	 * @param {EventTarget|Element} targetElement
  	 */
  	FastClick.prototype.focus = function(targetElement) {
  		var length;

  		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
  		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
  			length = targetElement.value.length;
  			targetElement.setSelectionRange(length, length);
  		} else {
  			targetElement.focus();
  		}
  	};


  	/**
  	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
  	 *
  	 * @param {EventTarget|Element} targetElement
  	 */
  	FastClick.prototype.updateScrollParent = function(targetElement) {
  		var scrollParent, parentElement;

  		scrollParent = targetElement.fastClickScrollParent;

  		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
  		// target element was moved to another parent.
  		if (!scrollParent || !scrollParent.contains(targetElement)) {
  			parentElement = targetElement;
  			do {
  				if (parentElement.scrollHeight > parentElement.offsetHeight) {
  					scrollParent = parentElement;
  					targetElement.fastClickScrollParent = parentElement;
  					break;
  				}

  				parentElement = parentElement.parentElement;
  			} while (parentElement);
  		}

  		// Always update the scroll top tracker if possible.
  		if (scrollParent) {
  			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
  		}
  	};


  	/**
  	 * @param {EventTarget} targetElement
  	 * @returns {Element|EventTarget}
  	 */
  	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

  		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
  		if (eventTarget.nodeType === Node.TEXT_NODE) {
  			return eventTarget.parentNode;
  		}

  		return eventTarget;
  	};


  	/**
  	 * On touch start, record the position and scroll offset.
  	 *
  	 * @param {Event} event
  	 * @returns {boolean}
  	 */
  	FastClick.prototype.onTouchStart = function(event) {
  		var targetElement, touch, selection;

  		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
  		if (event.targetTouches.length > 1) {
  			return true;
  		}

  		targetElement = this.getTargetElementFromEventTarget(event.target);
  		touch = event.targetTouches[0];

  		if (deviceIsIOS) {

  			// Only trusted events will deselect text on iOS (issue #49)
  			selection = window.getSelection();
  			if (selection.rangeCount && !selection.isCollapsed) {
  				return true;
  			}

  			if (!deviceIsIOS4) {

  				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
  				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
  				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
  				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
  				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
  				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
  				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
  				// random integers, it's safe to to continue if the identifier is 0 here.
  				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
  					event.preventDefault();
  					return false;
  				}

  				this.lastTouchIdentifier = touch.identifier;

  				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
  				// 1) the user does a fling scroll on the scrollable layer
  				// 2) the user stops the fling scroll with another tap
  				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
  				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
  				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
  				this.updateScrollParent(targetElement);
  			}
  		}

  		this.trackingClick = true;
  		this.trackingClickStart = event.timeStamp;
  		this.targetElement = targetElement;

  		this.touchStartX = touch.pageX;
  		this.touchStartY = touch.pageY;

  		// Prevent phantom clicks on fast double-tap (issue #36)
  		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
  			event.preventDefault();
  		}

  		return true;
  	};


  	/**
  	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
  	 *
  	 * @param {Event} event
  	 * @returns {boolean}
  	 */
  	FastClick.prototype.touchHasMoved = function(event) {
  		var touch = event.changedTouches[0], boundary = this.touchBoundary;

  		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
  			return true;
  		}

  		return false;
  	};


  	/**
  	 * Update the last position.
  	 *
  	 * @param {Event} event
  	 * @returns {boolean}
  	 */
  	FastClick.prototype.onTouchMove = function(event) {
  		if (!this.trackingClick) {
  			return true;
  		}

  		// If the touch has moved, cancel the click tracking
  		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
  			this.trackingClick = false;
  			this.targetElement = null;
  		}

  		return true;
  	};


  	/**
  	 * Attempt to find the labelled control for the given label element.
  	 *
  	 * @param {EventTarget|HTMLLabelElement} labelElement
  	 * @returns {Element|null}
  	 */
  	FastClick.prototype.findControl = function(labelElement) {

  		// Fast path for newer browsers supporting the HTML5 control attribute
  		if (labelElement.control !== undefined) {
  			return labelElement.control;
  		}

  		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
  		if (labelElement.htmlFor) {
  			return document.getElementById(labelElement.htmlFor);
  		}

  		// If no for attribute exists, attempt to retrieve the first labellable descendant element
  		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
  		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
  	};


  	/**
  	 * On touch end, determine whether to send a click event at once.
  	 *
  	 * @param {Event} event
  	 * @returns {boolean}
  	 */
  	FastClick.prototype.onTouchEnd = function(event) {
  		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

  		if (!this.trackingClick) {
  			return true;
  		}

  		// Prevent phantom clicks on fast double-tap (issue #36)
  		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
  			this.cancelNextClick = true;
  			return true;
  		}

  		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
  			return true;
  		}

  		// Reset to prevent wrong click cancel on input (issue #156).
  		this.cancelNextClick = false;

  		this.lastClickTime = event.timeStamp;

  		trackingClickStart = this.trackingClickStart;
  		this.trackingClick = false;
  		this.trackingClickStart = 0;

  		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
  		// is performing a transition or scroll, and has to be re-detected manually. Note that
  		// for this to function correctly, it must be called *after* the event target is checked!
  		// See issue #57; also filed as rdar://13048589 .
  		if (deviceIsIOSWithBadTarget) {
  			touch = event.changedTouches[0];

  			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
  			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
  			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
  		}

  		targetTagName = targetElement.tagName.toLowerCase();
  		if (targetTagName === 'label') {
  			forElement = this.findControl(targetElement);
  			if (forElement) {
  				this.focus(targetElement);
  				if (deviceIsAndroid) {
  					return false;
  				}

  				targetElement = forElement;
  			}
  		} else if (this.needsFocus(targetElement)) {

  			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
  			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
  			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
  				this.targetElement = null;
  				return false;
  			}

  			this.focus(targetElement);
  			this.sendClick(targetElement, event);

  			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
  			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
  			if (!deviceIsIOS || targetTagName !== 'select') {
  				this.targetElement = null;
  				event.preventDefault();
  			}

  			return false;
  		}

  		if (deviceIsIOS && !deviceIsIOS4) {

  			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
  			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
  			scrollParent = targetElement.fastClickScrollParent;
  			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
  				return true;
  			}
  		}

  		// Prevent the actual click from going though - unless the target node is marked as requiring
  		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
  		if (!this.needsClick(targetElement)) {
  			event.preventDefault();
  			this.sendClick(targetElement, event);
  		}

  		return false;
  	};


  	/**
  	 * On touch cancel, stop tracking the click.
  	 *
  	 * @returns {void}
  	 */
  	FastClick.prototype.onTouchCancel = function() {
  		this.trackingClick = false;
  		this.targetElement = null;
  	};


  	/**
  	 * Determine mouse events which should be permitted.
  	 *
  	 * @param {Event} event
  	 * @returns {boolean}
  	 */
  	FastClick.prototype.onMouse = function(event) {

  		// If a target element was never set (because a touch event was never fired) allow the event
  		if (!this.targetElement) {
  			return true;
  		}

  		if (event.forwardedTouchEvent) {
  			return true;
  		}

  		// Programmatically generated events targeting a specific element should be permitted
  		if (!event.cancelable) {
  			return true;
  		}

  		// Derive and check the target element to see whether the mouse event needs to be permitted;
  		// unless explicitly enabled, prevent non-touch click events from triggering actions,
  		// to prevent ghost/doubleclicks.
  		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

  			// Prevent any user-added listeners declared on FastClick element from being fired.
  			if (event.stopImmediatePropagation) {
  				event.stopImmediatePropagation();
  			} else {

  				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
  				event.propagationStopped = true;
  			}

  			// Cancel the event
  			event.stopPropagation();
  			event.preventDefault();

  			return false;
  		}

  		// If the mouse event is permitted, return true for the action to go through.
  		return true;
  	};


  	/**
  	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
  	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
  	 * an actual click which should be permitted.
  	 *
  	 * @param {Event} event
  	 * @returns {boolean}
  	 */
  	FastClick.prototype.onClick = function(event) {
  		var permitted;

  		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
  		if (this.trackingClick) {
  			this.targetElement = null;
  			this.trackingClick = false;
  			return true;
  		}

  		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
  		if (event.target.type === 'submit' && event.detail === 0) {
  			return true;
  		}

  		permitted = this.onMouse(event);

  		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
  		if (!permitted) {
  			this.targetElement = null;
  		}

  		// If clicks are permitted, return true for the action to go through.
  		return permitted;
  	};


  	/**
  	 * Remove all FastClick's event listeners.
  	 *
  	 * @returns {void}
  	 */
  	FastClick.prototype.destroy = function() {
  		var layer = this.layer;

  		if (deviceIsAndroid) {
  			layer.removeEventListener('mouseover', this.onMouse, true);
  			layer.removeEventListener('mousedown', this.onMouse, true);
  			layer.removeEventListener('mouseup', this.onMouse, true);
  		}

  		layer.removeEventListener('click', this.onClick, true);
  		layer.removeEventListener('touchstart', this.onTouchStart, false);
  		layer.removeEventListener('touchmove', this.onTouchMove, false);
  		layer.removeEventListener('touchend', this.onTouchEnd, false);
  		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
  	};


  	/**
  	 * Check whether FastClick is needed.
  	 *
  	 * @param {Element} layer The layer to listen on
  	 */
  	FastClick.notNeeded = function(layer) {
  		var metaViewport;
  		var chromeVersion;
  		var blackberryVersion;
  		var firefoxVersion;

  		// Devices that don't support touch don't need FastClick
  		if (typeof window.ontouchstart === 'undefined') {
  			return true;
  		}

  		// Chrome version - zero for other browsers
  		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

  		if (chromeVersion) {

  			if (deviceIsAndroid) {
  				metaViewport = document.querySelector('meta[name=viewport]');

  				if (metaViewport) {
  					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
  					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
  						return true;
  					}
  					// Chrome 32 and above with width=device-width or less don't need FastClick
  					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
  						return true;
  					}
  				}

  			// Chrome desktop doesn't need FastClick (issue #15)
  			} else {
  				return true;
  			}
  		}

  		if (deviceIsBlackBerry10) {
  			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

  			// BlackBerry 10.3+ does not require Fastclick library.
  			// https://github.com/ftlabs/fastclick/issues/251
  			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
  				metaViewport = document.querySelector('meta[name=viewport]');

  				if (metaViewport) {
  					// user-scalable=no eliminates click delay.
  					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
  						return true;
  					}
  					// width=device-width (or less than device-width) eliminates click delay.
  					if (document.documentElement.scrollWidth <= window.outerWidth) {
  						return true;
  					}
  				}
  			}
  		}

  		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
  		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
  			return true;
  		}

  		// Firefox version - zero for other browsers
  		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

  		if (firefoxVersion >= 27) {
  			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

  			metaViewport = document.querySelector('meta[name=viewport]');
  			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
  				return true;
  			}
  		}

  		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
  		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
  		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
  			return true;
  		}

  		return false;
  	};


  	/**
  	 * Factory method for creating a FastClick object
  	 *
  	 * @param {Element} layer The layer to listen on
  	 * @param {Object} [options={}] The options to override the defaults
  	 */
  	FastClick.attach = function(layer, options) {
  		return new FastClick(layer, options);
  	};


  	if ( module.exports) {
  		module.exports = FastClick.attach;
  		module.exports.FastClick = FastClick;
  	} else {
  		window.FastClick = FastClick;
  	}
  }());
  });
  var fastclick_1 = fastclick.FastClick;

  function bind() {
    if (typeof window === 'undefined') {
      return;
    }

    var body = select('body');

    fastclick(body.node());

    body.on('touchstart', function () {
      body.dispatch('click', event$1);
    });

    body.on('click.scola-menu', function () {
      if (select(event$1.target).classed('show-menu') === true) {
        select('.app > .menu')
          .classed('transition', true)
          .classed('in', true)
          .on('touchstart.scola-menu', function () { return event$1.stopPropagation(); })
          .on('click.scola-menu', function () { return event$1.stopPropagation(); });
      } else {
        select('.app > .menu.in')
          .classed('transition', true)
          .classed('in', false)
          .on('touchstart.scola-menu', null)
          .on('click.scola-menu', null);
      }
    });
  }

  // https://developer.mozilla.org/en-US/docs/Web/API/document
  if (!('HTMLDocument' in window)) {
    window.HTMLDocument = window.Document;
  }

  (function () {

    /**
     * Detect full support
     */

    var isSupported = (
      'CustomEvent' in window &&
      // in Safari, typeof CustomEvent == 'object' but it works
      (typeof window.CustomEvent === 'function' ||
          (window.CustomEvent.toString().indexOf('CustomEventConstructor') > -1))
    );

    if (isSupported) { return; }

    /**
     * Apply shim
     */

    /**
     * http://www.w3.org/TR/dom/#customevent
     * @param {string} type
     * @param {{bubbles: (boolean|undefined),
     *          cancelable: (boolean|undefined),
     *          detail: *}=} eventInitDict
     */
    function CustomEvent(type, eventInitDict) {
      if (typeof type != 'string') {
        throw new TypeError(
          'Failed to construct "CustomEvent": An event name must be provided.');
      }

      var event = document.createEvent('CustomEvent');
      var defaultInitDict = { bubbles: false, cancelable: false, detail: null };
      eventInitDict = eventInitDict || defaultInitDict;
      event.initCustomEvent(
        type,
        eventInitDict.bubbles,
        eventInitDict.cancelable,
        eventInitDict.detail
      );
      return event;
    }

    window.CustomEvent = CustomEvent;
  }());

  (function () {

    var ElementPrototype = Element.prototype;

    /**
     * Detect full support
     */

    var nativeMatches = ElementPrototype.matches = ElementPrototype.matches ||
        ElementPrototype.mozMatchesSelector ||
        ElementPrototype.msMatchesSelector ||
        ElementPrototype.oMatchesSelector ||
        ElementPrototype.webkitMatchesSelector;

    // determine if the browser supports matching orphan elements. IE 9's
    // vendor-specific implementation doesn't work with orphans.
    var isSupported = ('matches' in ElementPrototype) ?
        nativeMatches.call(document.createElement('a'), 'a') : false;

    if (isSupported) { return; }

    /**
     * Apply shim
     */

    ElementPrototype.matches = function (selector) {
      var indexOf = Array.prototype.indexOf;
      var parentElement = this.parentNode;

      // create a parent for orphans
      if (!parentElement) {
        parentElement = document.createDocumentFragment();
        parentElement.appendChild(this);
      }

      if (nativeMatches) {
        return nativeMatches.call(this, selector);
      } else {
        return indexOf.call(parentElement.querySelectorAll(selector), this) > -1;
      }
    };
  }());

  (function () {

    var ElementPrototype = Element.prototype;

    /**
     * Detect full support
     */

    if ('closest' in ElementPrototype) { return; }

    /**
     * Apply shim
     */

    ElementPrototype.closest = function (selector) {
      var element = this;

      while (element) {
        if (element.matches(selector)) {
          return element;
        } else {
          element = element.parentElement;
        }
      }

      return null;
    };
  }());

  (function () {

    var ElementPrototype = Element.prototype;

    /**
     * Detect full support
     */

    var isSupported = ElementPrototype.after &&
        ElementPrototype.append &&
        ElementPrototype.before &&
        ElementPrototype.prepend &&
        ElementPrototype.remove &&
        ElementPrototype.replace;

    if (isSupported) { return; }

    /**
     * Apply mutation shims
     */

    function toNode(node) {
      return typeof node === 'string' ? document.createTextNode(node) : node;
    }

    function mutationMacro(nodes) {
      var fragment, i, len;
      if (nodes) { len = nodes.length; }

      if (!len) {
        throw new Error('No node was specified (DOM Exception 8)');
      }

      if (len === 1) {
        return toNode(nodes[0]);
      } else {
        fragment = document.createDocumentFragment();
        for (i = 0; i < len; i++) {
          fragment.appendChild(toNode(nodes[i]));
        }
        return fragment;
      }
    }

    ElementPrototype.prepend = function prepend() {
      this.insertBefore(mutationMacro(arguments), this.firstChild);
    };

    ElementPrototype.append = function append() {
      this.appendChild(mutationMacro(arguments));
    };

    ElementPrototype.before = function before() {
      var parentNode = this.parentNode;
      if (parentNode) {
        parentNode.insertBefore(mutationMacro(arguments), this);
      }
    };

    ElementPrototype.after = function after() {
      var parentNode = this.parentNode;
      if (parentNode) {
        parentNode.insertBefore(mutationMacro(arguments), this.nextSibling);
      }
    };

    ElementPrototype.replace = function replace() {
      var parentNode = this.parentNode;
      if (parentNode) {
        parentNode.replaceChild(mutationMacro(arguments), this);
      }
    };

    /**
     * This method is defined with bracket notation to avoid conflicting with the
     * definition of HTMLSelectElement.
     */
    ElementPrototype['remove'] = function remove() {
      var parentNode = this.parentNode;
      if (parentNode) {
        parentNode.removeChild(this);
      }
    };
  }());

  /**
   * DOMTokenList constructor
   *
   * @param {Element} element - DOM element
   * @param {string} attribute - Attribute to create a token list for
   * @constructor
   */
  function DOMTokenList$1(element, attribute) {
    this._getString = function () {
      return element.getAttribute(attribute) || '';
    };
    this._setString = function (value) {
      element.setAttribute(attribute, value);
    };
    fixIndex(this, getList(this));
  }

  DOMTokenList$1.prototype = {
    /**
     * Adds tokens to the token list
     * @param {...string} tokens
     */
    add: function add(tokens) {
      var arguments$1 = arguments;

      var token;
      var i = 0;
      var len = arguments.length;
      var list = getList(this);
      var updated = false;

      for (; i < len; i++) {
        token = arguments$1[i];
        validateToken(token);
        if (list.indexOf(token) < 0) {
          list.push(token);
          updated = true;
        }
      }

      if (updated) {
        this._setString(list.join(' ').trim());
        fixIndex(this, list);
      }
    },

    /**
     * @param {string} token
     * @return {boolean}
     */
    contains: function contains(token) {
      validateToken(token);
      return (getList(this)).indexOf(token) > -1;
    },

    /**
     * Returns the token at a given index
     * @param {number} index
     * @return {string|null} - the token
     */
    item: function item(index) {
      return (getList(this))[index] || null;
    },

    /**
     * @return {number} - length of the token list
     */
    get length () {
      return (getList(this)).length;
    },

    /**
     * Removes tokens from the token list
     * @param {...string} tokens
     */
    remove: function remove(tokens) {
      var arguments$1 = arguments;

      var index, token;
      var i = 0;
      var len = arguments.length;
      var list = getList(this);
      var updated = false;

      for (; i < len; i++) {
        token = arguments$1[i];
        validateToken(token);
        // remove multiple instances of the same class
        while ((index = list.indexOf(token)) > -1) {
          list.splice(index, 1);
          updated = true;
        }
      }

      if (updated) {
        this._setString(list.join(' ').trim());
        fixIndex(this, list);
      }
    },

    /**
     * Toggles a token's presence in the token list
     * @param {string} token
     * @param {boolean} force - true: always add; false: always remove
     * @return {boolean} - true: the value was added to the token list
     */
    toggle: function toggle(token, force) {
      var hasToken = this.contains(token);
      var method = hasToken ?
          (force !== true && 'remove') :
          (force !== false && 'add');

      if (method) {
        this[method](token);
      }

      return (typeof force == 'boolean' ? force : !hasToken);
    },

    /**
     * @return {string} - value of the token list's associated attribute
     */
    toString: function toString() {
      return this._getString();
    }
  };

  /**
   * Ensure the token list is indexable
   *
   * @param {Object} instance
   * @param {Array} list
   */
  function fixIndex(instance, list) {
    var len = list.length;
    var i = 0;
    for (; i < len; i++) { instance[i] = list[i]; }
    delete instance[len];
  }

  /**
   * Get the attribute's list of values
   *
   * @param {Object} instance
   * @return {Array} - values
   */
  function getList(instance) {
    var str = instance._getString();
    if (!str || str === '') {
      return [];
    } else {
      return str.split(/\s+/);
    }
  }

  /**
   * @param {string} token
   */
  function validateToken(token) {
    if (token === '' || token === undefined) {
      throw new Error(
        'An invalid or illegal string was specified (DOM Exception 12)');
    } else if (/\s+/.test(token)) {
      throw new Error(
        'InvalidCharacterError: String contains an invalid character ' +
        '(DOM Exception 5)');
    }
  }

  var DOMTokenList_1 = DOMTokenList$1;

  (function () {

    /**
     * Detect full support
     */

    var DOMTokenListShim;
    var testHTMLElement = document.createElement('x');
    var testSVGElement = document.createElementNS('http://www.w3.org/2000/svg',
                                                  'svg');

    var isSupported = function (element) {
      return ('classList' in element) ?
        (!element.classList.toggle('a', false) && !element.classList.contains('a')) :
        false;
    };

    /**
     * Apply classList shim
     */

    // Element.prototype.classList
    // provide SVG support in IE 9-11
    if (!isSupported(testSVGElement)) {
      DOMTokenListShim = DOMTokenList_1;

      Object.defineProperty(Element.prototype, 'classList', {
        get: function () {
          /** @constructor */
          function ClassList() {}
          ClassList.prototype = new DOMTokenListShim(this, 'class');
          return new ClassList();
        }
      });
    }

    // Fix incomplete add/remove/toggle implementations in IE 10-11, iOS 5,
    // Android 4.3
    if (!isSupported(testHTMLElement)) {
      DOMTokenListShim = DOMTokenList_1;

      var DOMTokenListPrototype = DOMTokenList.prototype;
      var shimMethod = function (original) {
        return function () {
          var arguments$1 = arguments;

          var i;
          var len = arguments.length;

          for (i = 0; i < len; i++) {
            original.call(this, arguments$1[i]);
          }
        };
      };

      DOMTokenListPrototype.add = shimMethod(DOMTokenListPrototype.add);
      DOMTokenListPrototype.remove = shimMethod(DOMTokenListPrototype.remove);

      /**
       * @param {string} token
       * @param {boolean=} force
       * @this DOMTokenList
       * @return boolean
       */
      DOMTokenListPrototype.toggle = function(token, force) {
        if (1 in arguments && this.contains(token) === force) {
          return force;
        } else {
          return DOMTokenListShim.prototype.toggle.call(this, token, force);
        }
      };
    }
  }());

  var es5Shim = createCommonjsModule(function (module, exports) {

  // UMD (Universal Module Definition)
  // see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
  (function (root, factory) {

      /* global define, exports, module */
      {
          // Node. Does not work with strict CommonJS, but
          // only CommonJS-like enviroments that support module.exports,
          // like Node.
          module.exports = factory();
      }
  }(commonjsGlobal, function () {
      /**
       * Brings an environment as close to ECMAScript 5 compliance
       * as is possible with the facilities of erstwhile engines.
       *
       * Annotated ES5: http://es5.github.com/ (specific links below)
       * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
       * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
       */

      // Shortcut to an often accessed properties, in order to avoid multiple
      // dereference that costs universally. This also holds a reference to known-good
      // functions.
      var $Array = Array;
      var ArrayPrototype = $Array.prototype;
      var $Object = Object;
      var ObjectPrototype = $Object.prototype;
      var $Function = Function;
      var FunctionPrototype = $Function.prototype;
      var $String = String;
      var StringPrototype = $String.prototype;
      var $Number = Number;
      var NumberPrototype = $Number.prototype;
      var array_slice = ArrayPrototype.slice;
      var array_splice = ArrayPrototype.splice;
      var array_push = ArrayPrototype.push;
      var array_unshift = ArrayPrototype.unshift;
      var array_concat = ArrayPrototype.concat;
      var array_join = ArrayPrototype.join;
      var call = FunctionPrototype.call;
      var apply = FunctionPrototype.apply;
      var max = Math.max;
      var min = Math.min;

      // Having a toString local variable name breaks in Opera so use to_string.
      var to_string = ObjectPrototype.toString;

      /* global Symbol */
      /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
      var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
      var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

      var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
      var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
      /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

      /* inlined from http://npmjs.com/define-properties */
      var supportsDescriptors = $Object.defineProperty && (function () {
          try {
              var obj = {};
              $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
              for (var _ in obj) { // jscs:ignore disallowUnusedVariables
                  return false;
              }
              return obj.x === obj;
          } catch (e) { /* this is ES3 */
              return false;
          }
      }());
      var defineProperties = (function (has) {
          // Define configurable, writable, and non-enumerable props
          // if they don't exist.
          var defineProperty;
          if (supportsDescriptors) {
              defineProperty = function (object, name, method, forceAssign) {
                  if (!forceAssign && (name in object)) {
                      return;
                  }
                  $Object.defineProperty(object, name, {
                      configurable: true,
                      enumerable: false,
                      writable: true,
                      value: method
                  });
              };
          } else {
              defineProperty = function (object, name, method, forceAssign) {
                  if (!forceAssign && (name in object)) {
                      return;
                  }
                  object[name] = method;
              };
          }
          return function defineProperties(object, map, forceAssign) {
              for (var name in map) {
                  if (has.call(map, name)) {
                      defineProperty(object, name, map[name], forceAssign);
                  }
              }
          };
      }(ObjectPrototype.hasOwnProperty));

      //
      // Util
      // ======
      //

      /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
      var isPrimitive = function isPrimitive(input) {
          var type = typeof input;
          return input === null || (type !== 'object' && type !== 'function');
      };

      var isActualNaN = $Number.isNaN || function isActualNaN(x) {
          return x !== x;
      };

      var ES = {
          // ES5 9.4
          // http://es5.github.com/#x9.4
          // http://jsperf.com/to-integer
          /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
          ToInteger: function ToInteger(num) {
              var n = +num;
              if (isActualNaN(n)) {
                  n = 0;
              } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                  n = (n > 0 || -1) * Math.floor(Math.abs(n));
              }
              return n;
          },

          /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
          ToPrimitive: function ToPrimitive(input) {
              var val, valueOf, toStr;
              if (isPrimitive(input)) {
                  return input;
              }
              valueOf = input.valueOf;
              if (isCallable(valueOf)) {
                  val = valueOf.call(input);
                  if (isPrimitive(val)) {
                      return val;
                  }
              }
              toStr = input.toString;
              if (isCallable(toStr)) {
                  val = toStr.call(input);
                  if (isPrimitive(val)) {
                      return val;
                  }
              }
              throw new TypeError();
          },

          // ES5 9.9
          // http://es5.github.com/#x9.9
          /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
          ToObject: function (o) {
              if (o == null) { // this matches both null and undefined
                  throw new TypeError("can't convert " + o + ' to object');
              }
              return $Object(o);
          },

          /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
          ToUint32: function ToUint32(x) {
              return x >>> 0;
          }
      };

      //
      // Function
      // ========
      //

      // ES-5 15.3.4.5
      // http://es5.github.com/#x15.3.4.5

      var Empty = function Empty() {};

      defineProperties(FunctionPrototype, {
          bind: function bind(that) { // .length is 1
              // 1. Let Target be the this value.
              var target = this;
              // 2. If IsCallable(Target) is false, throw a TypeError exception.
              if (!isCallable(target)) {
                  throw new TypeError('Function.prototype.bind called on incompatible ' + target);
              }
              // 3. Let A be a new (possibly empty) internal list of all of the
              //   argument values provided after thisArg (arg1, arg2 etc), in order.
              // XXX slicedArgs will stand in for "A" if used
              var args = array_slice.call(arguments, 1); // for normal call
              // 4. Let F be a new native ECMAScript object.
              // 11. Set the [[Prototype]] internal property of F to the standard
              //   built-in Function prototype object as specified in 15.3.3.1.
              // 12. Set the [[Call]] internal property of F as described in
              //   15.3.4.5.1.
              // 13. Set the [[Construct]] internal property of F as described in
              //   15.3.4.5.2.
              // 14. Set the [[HasInstance]] internal property of F as described in
              //   15.3.4.5.3.
              var bound;
              var binder = function () {

                  if (this instanceof bound) {
                      // 15.3.4.5.2 [[Construct]]
                      // When the [[Construct]] internal method of a function object,
                      // F that was created using the bind function is called with a
                      // list of arguments ExtraArgs, the following steps are taken:
                      // 1. Let target be the value of F's [[TargetFunction]]
                      //   internal property.
                      // 2. If target has no [[Construct]] internal method, a
                      //   TypeError exception is thrown.
                      // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                      //   property.
                      // 4. Let args be a new list containing the same values as the
                      //   list boundArgs in the same order followed by the same
                      //   values as the list ExtraArgs in the same order.
                      // 5. Return the result of calling the [[Construct]] internal
                      //   method of target providing args as the arguments.

                      var result = apply.call(
                          target,
                          this,
                          array_concat.call(args, array_slice.call(arguments))
                      );
                      if ($Object(result) === result) {
                          return result;
                      }
                      return this;

                  } else {
                      // 15.3.4.5.1 [[Call]]
                      // When the [[Call]] internal method of a function object, F,
                      // which was created using the bind function is called with a
                      // this value and a list of arguments ExtraArgs, the following
                      // steps are taken:
                      // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                      //   property.
                      // 2. Let boundThis be the value of F's [[BoundThis]] internal
                      //   property.
                      // 3. Let target be the value of F's [[TargetFunction]] internal
                      //   property.
                      // 4. Let args be a new list containing the same values as the
                      //   list boundArgs in the same order followed by the same
                      //   values as the list ExtraArgs in the same order.
                      // 5. Return the result of calling the [[Call]] internal method
                      //   of target providing boundThis as the this value and
                      //   providing args as the arguments.

                      // equiv: target.call(this, ...boundArgs, ...args)
                      return apply.call(
                          target,
                          that,
                          array_concat.call(args, array_slice.call(arguments))
                      );

                  }

              };

              // 15. If the [[Class]] internal property of Target is "Function", then
              //     a. Let L be the length property of Target minus the length of A.
              //     b. Set the length own property of F to either 0 or L, whichever is
              //       larger.
              // 16. Else set the length own property of F to 0.

              var boundLength = max(0, target.length - args.length);

              // 17. Set the attributes of the length own property of F to the values
              //   specified in 15.3.5.1.
              var boundArgs = [];
              for (var i = 0; i < boundLength; i++) {
                  array_push.call(boundArgs, '$' + i);
              }

              // XXX Build a dynamic function with desired amount of arguments is the only
              // way to set the length property of a function.
              // In environments where Content Security Policies enabled (Chrome extensions,
              // for ex.) all use of eval or Function costructor throws an exception.
              // However in all of these environments Function.prototype.bind exists
              // and so this code will never be executed.
              bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

              if (target.prototype) {
                  Empty.prototype = target.prototype;
                  bound.prototype = new Empty();
                  // Clean up dangling references.
                  Empty.prototype = null;
              }

              // TODO
              // 18. Set the [[Extensible]] internal property of F to true.

              // TODO
              // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
              // 20. Call the [[DefineOwnProperty]] internal method of F with
              //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
              //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
              //   false.
              // 21. Call the [[DefineOwnProperty]] internal method of F with
              //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
              //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
              //   and false.

              // TODO
              // NOTE Function objects created using Function.prototype.bind do not
              // have a prototype property or the [[Code]], [[FormalParameters]], and
              // [[Scope]] internal properties.
              // XXX can't delete prototype in pure-js.

              // 22. Return F.
              return bound;
          }
      });

      // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
      // use it in defining shortcuts.
      var owns = call.bind(ObjectPrototype.hasOwnProperty);
      var toStr = call.bind(ObjectPrototype.toString);
      var arraySlice = call.bind(array_slice);
      var arraySliceApply = apply.bind(array_slice);
      /* globals document */
      if (typeof document === 'object' && document && document.documentElement) {
          try {
              arraySlice(document.documentElement.childNodes);
          } catch (e) {
              var origArraySlice = arraySlice;
              var origArraySliceApply = arraySliceApply;
              arraySlice = function arraySliceIE(arr) {
                  var r = [];
                  var i = arr.length;
                  while (i-- > 0) {
                      r[i] = arr[i];
                  }
                  return origArraySliceApply(r, origArraySlice(arguments, 1));
              };
              arraySliceApply = function arraySliceApplyIE(arr, args) {
                  return origArraySliceApply(arraySlice(arr), args);
              };
          }
      }
      var strSlice = call.bind(StringPrototype.slice);
      var strSplit = call.bind(StringPrototype.split);
      var strIndexOf = call.bind(StringPrototype.indexOf);
      var pushCall = call.bind(array_push);
      var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
      var arraySort = call.bind(ArrayPrototype.sort);

      //
      // Array
      // =====
      //

      var isArray = $Array.isArray || function isArray(obj) {
          return toStr(obj) === '[object Array]';
      };

      // ES5 15.4.4.12
      // http://es5.github.com/#x15.4.4.13
      // Return len+argCount.
      // [bugfix, ielt8]
      // IE < 8 bug: [].unshift(0) === undefined but should be "1"
      var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
      defineProperties(ArrayPrototype, {
          unshift: function () {
              array_unshift.apply(this, arguments);
              return this.length;
          }
      }, hasUnshiftReturnValueBug);

      // ES5 15.4.3.2
      // http://es5.github.com/#x15.4.3.2
      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
      defineProperties($Array, { isArray: isArray });

      // The IsCallable() check in the Array functions
      // has been replaced with a strict check on the
      // internal class of the object to trap cases where
      // the provided function was actually a regular
      // expression literal, which in V8 and
      // JavaScriptCore is a typeof "function".  Only in
      // V8 are regular expression literals permitted as
      // reduce parameters, so it is desirable in the
      // general case for the shim to match the more
      // strict and common behavior of rejecting regular
      // expressions.

      // ES5 15.4.4.18
      // http://es5.github.com/#x15.4.4.18
      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

      // Check failure of by-index access of string characters (IE < 9)
      // and failure of `0 in boxedString` (Rhino)
      var boxedString = $Object('a');
      var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

      var properlyBoxesContext = function properlyBoxed(method) {
          // Check node 0.6.21 bug where third parameter is not boxed
          var properlyBoxesNonStrict = true;
          var properlyBoxesStrict = true;
          var threwException = false;
          if (method) {
              try {
                  method.call('foo', function (_, __, context) {
                      if (typeof context !== 'object') {
                          properlyBoxesNonStrict = false;
                      }
                  });

                  method.call([1], function () {
                      'use strict';

                      properlyBoxesStrict = typeof this === 'string';
                  }, 'x');
              } catch (e) {
                  threwException = true;
              }
          }
          return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
      };

      defineProperties(ArrayPrototype, {
          forEach: function forEach(callbackfn/*, thisArg*/) {
              var object = ES.ToObject(this);
              var self = splitString && isString(this) ? strSplit(this, '') : object;
              var i = -1;
              var length = ES.ToUint32(self.length);
              var T;
              if (arguments.length > 1) {
                  T = arguments[1];
              }

              // If no callback function or if callback is not a callable function
              if (!isCallable(callbackfn)) {
                  throw new TypeError('Array.prototype.forEach callback must be a function');
              }

              while (++i < length) {
                  if (i in self) {
                      // Invoke the callback function with call, passing arguments:
                      // context, property value, property key, thisArg object
                      if (typeof T === 'undefined') {
                          callbackfn(self[i], i, object);
                      } else {
                          callbackfn.call(T, self[i], i, object);
                      }
                  }
              }
          }
      }, !properlyBoxesContext(ArrayPrototype.forEach));

      // ES5 15.4.4.19
      // http://es5.github.com/#x15.4.4.19
      // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
      defineProperties(ArrayPrototype, {
          map: function map(callbackfn/*, thisArg*/) {
              var object = ES.ToObject(this);
              var self = splitString && isString(this) ? strSplit(this, '') : object;
              var length = ES.ToUint32(self.length);
              var result = $Array(length);
              var T;
              if (arguments.length > 1) {
                  T = arguments[1];
              }

              // If no callback function or if callback is not a callable function
              if (!isCallable(callbackfn)) {
                  throw new TypeError('Array.prototype.map callback must be a function');
              }

              for (var i = 0; i < length; i++) {
                  if (i in self) {
                      if (typeof T === 'undefined') {
                          result[i] = callbackfn(self[i], i, object);
                      } else {
                          result[i] = callbackfn.call(T, self[i], i, object);
                      }
                  }
              }
              return result;
          }
      }, !properlyBoxesContext(ArrayPrototype.map));

      // ES5 15.4.4.20
      // http://es5.github.com/#x15.4.4.20
      // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
      defineProperties(ArrayPrototype, {
          filter: function filter(callbackfn/*, thisArg*/) {
              var object = ES.ToObject(this);
              var self = splitString && isString(this) ? strSplit(this, '') : object;
              var length = ES.ToUint32(self.length);
              var result = [];
              var value;
              var T;
              if (arguments.length > 1) {
                  T = arguments[1];
              }

              // If no callback function or if callback is not a callable function
              if (!isCallable(callbackfn)) {
                  throw new TypeError('Array.prototype.filter callback must be a function');
              }

              for (var i = 0; i < length; i++) {
                  if (i in self) {
                      value = self[i];
                      if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                          pushCall(result, value);
                      }
                  }
              }
              return result;
          }
      }, !properlyBoxesContext(ArrayPrototype.filter));

      // ES5 15.4.4.16
      // http://es5.github.com/#x15.4.4.16
      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
      defineProperties(ArrayPrototype, {
          every: function every(callbackfn/*, thisArg*/) {
              var object = ES.ToObject(this);
              var self = splitString && isString(this) ? strSplit(this, '') : object;
              var length = ES.ToUint32(self.length);
              var T;
              if (arguments.length > 1) {
                  T = arguments[1];
              }

              // If no callback function or if callback is not a callable function
              if (!isCallable(callbackfn)) {
                  throw new TypeError('Array.prototype.every callback must be a function');
              }

              for (var i = 0; i < length; i++) {
                  if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                      return false;
                  }
              }
              return true;
          }
      }, !properlyBoxesContext(ArrayPrototype.every));

      // ES5 15.4.4.17
      // http://es5.github.com/#x15.4.4.17
      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
      defineProperties(ArrayPrototype, {
          some: function some(callbackfn/*, thisArg */) {
              var object = ES.ToObject(this);
              var self = splitString && isString(this) ? strSplit(this, '') : object;
              var length = ES.ToUint32(self.length);
              var T;
              if (arguments.length > 1) {
                  T = arguments[1];
              }

              // If no callback function or if callback is not a callable function
              if (!isCallable(callbackfn)) {
                  throw new TypeError('Array.prototype.some callback must be a function');
              }

              for (var i = 0; i < length; i++) {
                  if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                      return true;
                  }
              }
              return false;
          }
      }, !properlyBoxesContext(ArrayPrototype.some));

      // ES5 15.4.4.21
      // http://es5.github.com/#x15.4.4.21
      // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
      var reduceCoercesToObject = false;
      if (ArrayPrototype.reduce) {
          reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
              return list;
          }) === 'object';
      }
      defineProperties(ArrayPrototype, {
          reduce: function reduce(callbackfn/*, initialValue*/) {
              var object = ES.ToObject(this);
              var self = splitString && isString(this) ? strSplit(this, '') : object;
              var length = ES.ToUint32(self.length);

              // If no callback function or if callback is not a callable function
              if (!isCallable(callbackfn)) {
                  throw new TypeError('Array.prototype.reduce callback must be a function');
              }

              // no value to return if no initial value and an empty array
              if (length === 0 && arguments.length === 1) {
                  throw new TypeError('reduce of empty array with no initial value');
              }

              var i = 0;
              var result;
              if (arguments.length >= 2) {
                  result = arguments[1];
              } else {
                  do {
                      if (i in self) {
                          result = self[i++];
                          break;
                      }

                      // if array contains no values, no initial value to return
                      if (++i >= length) {
                          throw new TypeError('reduce of empty array with no initial value');
                      }
                  } while (true);
              }

              for (; i < length; i++) {
                  if (i in self) {
                      result = callbackfn(result, self[i], i, object);
                  }
              }

              return result;
          }
      }, !reduceCoercesToObject);

      // ES5 15.4.4.22
      // http://es5.github.com/#x15.4.4.22
      // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
      var reduceRightCoercesToObject = false;
      if (ArrayPrototype.reduceRight) {
          reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
              return list;
          }) === 'object';
      }
      defineProperties(ArrayPrototype, {
          reduceRight: function reduceRight(callbackfn/*, initial*/) {
              var object = ES.ToObject(this);
              var self = splitString && isString(this) ? strSplit(this, '') : object;
              var length = ES.ToUint32(self.length);

              // If no callback function or if callback is not a callable function
              if (!isCallable(callbackfn)) {
                  throw new TypeError('Array.prototype.reduceRight callback must be a function');
              }

              // no value to return if no initial value, empty array
              if (length === 0 && arguments.length === 1) {
                  throw new TypeError('reduceRight of empty array with no initial value');
              }

              var result;
              var i = length - 1;
              if (arguments.length >= 2) {
                  result = arguments[1];
              } else {
                  do {
                      if (i in self) {
                          result = self[i--];
                          break;
                      }

                      // if array contains no values, no initial value to return
                      if (--i < 0) {
                          throw new TypeError('reduceRight of empty array with no initial value');
                      }
                  } while (true);
              }

              if (i < 0) {
                  return result;
              }

              do {
                  if (i in self) {
                      result = callbackfn(result, self[i], i, object);
                  }
              } while (i--);

              return result;
          }
      }, !reduceRightCoercesToObject);

      // ES5 15.4.4.14
      // http://es5.github.com/#x15.4.4.14
      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
      var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
      defineProperties(ArrayPrototype, {
          indexOf: function indexOf(searchElement/*, fromIndex */) {
              var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
              var length = ES.ToUint32(self.length);

              if (length === 0) {
                  return -1;
              }

              var i = 0;
              if (arguments.length > 1) {
                  i = ES.ToInteger(arguments[1]);
              }

              // handle negative indices
              i = i >= 0 ? i : max(0, length + i);
              for (; i < length; i++) {
                  if (i in self && self[i] === searchElement) {
                      return i;
                  }
              }
              return -1;
          }
      }, hasFirefox2IndexOfBug);

      // ES5 15.4.4.15
      // http://es5.github.com/#x15.4.4.15
      // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
      var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
      defineProperties(ArrayPrototype, {
          lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
              var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
              var length = ES.ToUint32(self.length);

              if (length === 0) {
                  return -1;
              }
              var i = length - 1;
              if (arguments.length > 1) {
                  i = min(i, ES.ToInteger(arguments[1]));
              }
              // handle negative indices
              i = i >= 0 ? i : length - Math.abs(i);
              for (; i >= 0; i--) {
                  if (i in self && searchElement === self[i]) {
                      return i;
                  }
              }
              return -1;
          }
      }, hasFirefox2LastIndexOfBug);

      // ES5 15.4.4.12
      // http://es5.github.com/#x15.4.4.12
      var spliceNoopReturnsEmptyArray = (function () {
          var a = [1, 2];
          var result = a.splice();
          return a.length === 2 && isArray(result) && result.length === 0;
      }());
      defineProperties(ArrayPrototype, {
          // Safari 5.0 bug where .splice() returns undefined
          splice: function splice(start, deleteCount) {
              if (arguments.length === 0) {
                  return [];
              } else {
                  return array_splice.apply(this, arguments);
              }
          }
      }, !spliceNoopReturnsEmptyArray);

      var spliceWorksWithEmptyObject = (function () {
          var obj = {};
          ArrayPrototype.splice.call(obj, 0, 0, 1);
          return obj.length === 1;
      }());
      defineProperties(ArrayPrototype, {
          splice: function splice(start, deleteCount) {
              if (arguments.length === 0) {
                  return [];
              }
              var args = arguments;
              this.length = max(ES.ToInteger(this.length), 0);
              if (arguments.length > 0 && typeof deleteCount !== 'number') {
                  args = arraySlice(arguments);
                  if (args.length < 2) {
                      pushCall(args, this.length - start);
                  } else {
                      args[1] = ES.ToInteger(deleteCount);
                  }
              }
              return array_splice.apply(this, args);
          }
      }, !spliceWorksWithEmptyObject);
      var spliceWorksWithLargeSparseArrays = (function () {
          // Per https://github.com/es-shims/es5-shim/issues/295
          // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
          var arr = new $Array(1e5);
          // note: the index MUST be 8 or larger or the test will false pass
          arr[8] = 'x';
          arr.splice(1, 1);
          // note: this test must be defined *after* the indexOf shim
          // per https://github.com/es-shims/es5-shim/issues/313
          return arr.indexOf('x') === 7;
      }());
      var spliceWorksWithSmallSparseArrays = (function () {
          // Per https://github.com/es-shims/es5-shim/issues/295
          // Opera 12.15 breaks on this, no idea why.
          var n = 256;
          var arr = [];
          arr[n] = 'a';
          arr.splice(n + 1, 0, 'b');
          return arr[n] === 'a';
      }());
      defineProperties(ArrayPrototype, {
          splice: function splice(start, deleteCount) {
              var O = ES.ToObject(this);
              var A = [];
              var len = ES.ToUint32(O.length);
              var relativeStart = ES.ToInteger(start);
              var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
              var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

              var k = 0;
              var from;
              while (k < actualDeleteCount) {
                  from = $String(actualStart + k);
                  if (owns(O, from)) {
                      A[k] = O[from];
                  }
                  k += 1;
              }

              var items = arraySlice(arguments, 2);
              var itemCount = items.length;
              var to;
              if (itemCount < actualDeleteCount) {
                  k = actualStart;
                  var maxK = len - actualDeleteCount;
                  while (k < maxK) {
                      from = $String(k + actualDeleteCount);
                      to = $String(k + itemCount);
                      if (owns(O, from)) {
                          O[to] = O[from];
                      } else {
                          delete O[to];
                      }
                      k += 1;
                  }
                  k = len;
                  var minK = len - actualDeleteCount + itemCount;
                  while (k > minK) {
                      delete O[k - 1];
                      k -= 1;
                  }
              } else if (itemCount > actualDeleteCount) {
                  k = len - actualDeleteCount;
                  while (k > actualStart) {
                      from = $String(k + actualDeleteCount - 1);
                      to = $String(k + itemCount - 1);
                      if (owns(O, from)) {
                          O[to] = O[from];
                      } else {
                          delete O[to];
                      }
                      k -= 1;
                  }
              }
              k = actualStart;
              for (var i = 0; i < items.length; ++i) {
                  O[k] = items[i];
                  k += 1;
              }
              O.length = len - actualDeleteCount + itemCount;

              return A;
          }
      }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

      var originalJoin = ArrayPrototype.join;
      var hasStringJoinBug;
      try {
          hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
      } catch (e) {
          hasStringJoinBug = true;
      }
      if (hasStringJoinBug) {
          defineProperties(ArrayPrototype, {
              join: function join(separator) {
                  var sep = typeof separator === 'undefined' ? ',' : separator;
                  return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
              }
          }, hasStringJoinBug);
      }

      var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
      if (hasJoinUndefinedBug) {
          defineProperties(ArrayPrototype, {
              join: function join(separator) {
                  var sep = typeof separator === 'undefined' ? ',' : separator;
                  return originalJoin.call(this, sep);
              }
          }, hasJoinUndefinedBug);
      }

      var pushShim = function push(item) {
          var arguments$1 = arguments;

          var O = ES.ToObject(this);
          var n = ES.ToUint32(O.length);
          var i = 0;
          while (i < arguments.length) {
              O[n + i] = arguments$1[i];
              i += 1;
          }
          O.length = n + i;
          return n + i;
      };

      var pushIsNotGeneric = (function () {
          var obj = {};
          var result = Array.prototype.push.call(obj, undefined);
          return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
      }());
      defineProperties(ArrayPrototype, {
          push: function push(item) {
              if (isArray(this)) {
                  return array_push.apply(this, arguments);
              }
              return pushShim.apply(this, arguments);
          }
      }, pushIsNotGeneric);

      // This fixes a very weird bug in Opera 10.6 when pushing `undefined
      var pushUndefinedIsWeird = (function () {
          var arr = [];
          var result = arr.push(undefined);
          return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
      }());
      defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

      // ES5 15.2.3.14
      // http://es5.github.io/#x15.4.4.10
      // Fix boxed string bug
      defineProperties(ArrayPrototype, {
          slice: function (start, end) {
              var arr = isString(this) ? strSplit(this, '') : this;
              return arraySliceApply(arr, arguments);
          }
      }, splitString);

      var sortIgnoresNonFunctions = (function () {
          try {
              [1, 2].sort(null);
          } catch (e) {
              try {
                  [1, 2].sort({});
              } catch (e2) {
                  return false;
              }
          }
          return true;
      }());
      var sortThrowsOnRegex = (function () {
          // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
          try {
              [1, 2].sort(/a/);
              return false;
          } catch (e) {}
          return true;
      }());
      var sortIgnoresUndefined = (function () {
          // applies in IE 8, for one.
          try {
              [1, 2].sort(undefined);
              return true;
          } catch (e) {}
          return false;
      }());
      defineProperties(ArrayPrototype, {
          sort: function sort(compareFn) {
              if (typeof compareFn === 'undefined') {
                  return arraySort(this);
              }
              if (!isCallable(compareFn)) {
                  throw new TypeError('Array.prototype.sort callback must be a function');
              }
              return arraySort(this, compareFn);
          }
      }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

      //
      // Object
      // ======
      //

      // ES5 15.2.3.14
      // http://es5.github.com/#x15.2.3.14

      // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
      var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString'); // jscs:ignore disallowQuotedKeysInObjects
      var hasProtoEnumBug = isEnum(function () {}, 'prototype');
      var hasStringEnumBug = !owns('x', '0');
      var equalsConstructorPrototype = function (o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
      };
      var excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true,

          $width: true,
          $height: true,
          $top: true,
          $localStorage: true
      };
      var hasAutomationEqualityBug = (function () {
          /* globals window */
          if (typeof window === 'undefined') {
              return false;
          }
          for (var k in window) {
              try {
                  if (!excludedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                      equalsConstructorPrototype(window[k]);
                  }
              } catch (e) {
                  return true;
              }
          }
          return false;
      }());
      var equalsConstructorPrototypeIfNotBuggy = function (object) {
          if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
              return equalsConstructorPrototype(object);
          }
          try {
              return equalsConstructorPrototype(object);
          } catch (e) {
              return false;
          }
      };
      var dontEnums = [
          'toString',
          'toLocaleString',
          'valueOf',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'constructor'
      ];
      var dontEnumsLength = dontEnums.length;

      // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
      // can be replaced with require('is-arguments') if we ever use a build process instead
      var isStandardArguments = function isArguments(value) {
          return toStr(value) === '[object Arguments]';
      };
      var isLegacyArguments = function isArguments(value) {
          return value !== null
              && typeof value === 'object'
              && typeof value.length === 'number'
              && value.length >= 0
              && !isArray(value)
              && isCallable(value.callee);
      };
      var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

      defineProperties($Object, {
          keys: function keys(object) {
              var isFn = isCallable(object);
              var isArgs = isArguments(object);
              var isObject = object !== null && typeof object === 'object';
              var isStr = isObject && isString(object);

              if (!isObject && !isFn && !isArgs) {
                  throw new TypeError('Object.keys called on a non-object');
              }

              var theKeys = [];
              var skipProto = hasProtoEnumBug && isFn;
              if ((isStr && hasStringEnumBug) || isArgs) {
                  for (var i = 0; i < object.length; ++i) {
                      pushCall(theKeys, $String(i));
                  }
              }

              if (!isArgs) {
                  for (var name in object) {
                      if (!(skipProto && name === 'prototype') && owns(object, name)) {
                          pushCall(theKeys, $String(name));
                      }
                  }
              }

              if (hasDontEnumBug) {
                  var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                  for (var j = 0; j < dontEnumsLength; j++) {
                      var dontEnum = dontEnums[j];
                      if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                          pushCall(theKeys, dontEnum);
                      }
                  }
              }
              return theKeys;
          }
      });

      var keysWorksWithArguments = $Object.keys && (function () {
          // Safari 5.0 bug
          return $Object.keys(arguments).length === 2;
      }(1, 2));
      var keysHasArgumentsLengthBug = $Object.keys && (function () {
          var argKeys = $Object.keys(arguments);
          return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
      }(1));
      var originalKeys = $Object.keys;
      defineProperties($Object, {
          keys: function keys(object) {
              if (isArguments(object)) {
                  return originalKeys(arraySlice(object));
              } else {
                  return originalKeys(object);
              }
          }
      }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

      //
      // Date
      // ====
      //

      var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
      var aNegativeTestDate = new Date(-1509842289600292);
      var aPositiveTestDate = new Date(1449662400000);
      var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
      var hasToDateStringFormatBug;
      var hasToStringFormatBug;
      var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
      if (timeZoneOffset < -720) {
          hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
          hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
      } else {
          hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
          hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-+]\d\d\d\d(?: |$)/).test(String(aPositiveTestDate));
      }

      var originalGetFullYear = call.bind(Date.prototype.getFullYear);
      var originalGetMonth = call.bind(Date.prototype.getMonth);
      var originalGetDate = call.bind(Date.prototype.getDate);
      var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
      var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
      var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
      var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
      var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
      var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
      var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
      var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
      var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      var daysInMonth = function daysInMonth(month, year) {
          return originalGetDate(new Date(year, month, 0));
      };

      defineProperties(Date.prototype, {
          getFullYear: function getFullYear() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var year = originalGetFullYear(this);
              if (year < 0 && originalGetMonth(this) > 11) {
                  return year + 1;
              }
              return year;
          },
          getMonth: function getMonth() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var year = originalGetFullYear(this);
              var month = originalGetMonth(this);
              if (year < 0 && month > 11) {
                  return 0;
              }
              return month;
          },
          getDate: function getDate() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var year = originalGetFullYear(this);
              var month = originalGetMonth(this);
              var date = originalGetDate(this);
              if (year < 0 && month > 11) {
                  if (month === 12) {
                      return date;
                  }
                  var days = daysInMonth(0, year + 1);
                  return (days - date) + 1;
              }
              return date;
          },
          getUTCFullYear: function getUTCFullYear() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var year = originalGetUTCFullYear(this);
              if (year < 0 && originalGetUTCMonth(this) > 11) {
                  return year + 1;
              }
              return year;
          },
          getUTCMonth: function getUTCMonth() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var year = originalGetUTCFullYear(this);
              var month = originalGetUTCMonth(this);
              if (year < 0 && month > 11) {
                  return 0;
              }
              return month;
          },
          getUTCDate: function getUTCDate() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var year = originalGetUTCFullYear(this);
              var month = originalGetUTCMonth(this);
              var date = originalGetUTCDate(this);
              if (year < 0 && month > 11) {
                  if (month === 12) {
                      return date;
                  }
                  var days = daysInMonth(0, year + 1);
                  return (days - date) + 1;
              }
              return date;
          }
      }, hasNegativeMonthYearBug);

      defineProperties(Date.prototype, {
          toUTCString: function toUTCString() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var day = originalGetUTCDay(this);
              var date = originalGetUTCDate(this);
              var month = originalGetUTCMonth(this);
              var year = originalGetUTCFullYear(this);
              var hour = originalGetUTCHours(this);
              var minute = originalGetUTCMinutes(this);
              var second = originalGetUTCSeconds(this);
              return dayName[day] + ', '
                  + (date < 10 ? '0' + date : date) + ' '
                  + monthName[month] + ' '
                  + year + ' '
                  + (hour < 10 ? '0' + hour : hour) + ':'
                  + (minute < 10 ? '0' + minute : minute) + ':'
                  + (second < 10 ? '0' + second : second) + ' GMT';
          }
      }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

      // Opera 12 has `,`
      defineProperties(Date.prototype, {
          toDateString: function toDateString() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var day = this.getDay();
              var date = this.getDate();
              var month = this.getMonth();
              var year = this.getFullYear();
              return dayName[day] + ' '
                  + monthName[month] + ' '
                  + (date < 10 ? '0' + date : date) + ' '
                  + year;
          }
      }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

      // can't use defineProperties here because of toString enumeration issue in IE <= 8
      if (hasNegativeMonthYearBug || hasToStringFormatBug) {
          Date.prototype.toString = function toString() {
              if (!this || !(this instanceof Date)) {
                  throw new TypeError('this is not a Date object.');
              }
              var day = this.getDay();
              var date = this.getDate();
              var month = this.getMonth();
              var year = this.getFullYear();
              var hour = this.getHours();
              var minute = this.getMinutes();
              var second = this.getSeconds();
              var timezoneOffset = this.getTimezoneOffset();
              var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
              var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
              return dayName[day] + ' '
                  + monthName[month] + ' '
                  + (date < 10 ? '0' + date : date) + ' '
                  + year + ' '
                  + (hour < 10 ? '0' + hour : hour) + ':'
                  + (minute < 10 ? '0' + minute : minute) + ':'
                  + (second < 10 ? '0' + second : second) + ' GMT'
                  + (timezoneOffset > 0 ? '-' : '+')
                  + (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset)
                  + (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
          };
          if (supportsDescriptors) {
              $Object.defineProperty(Date.prototype, 'toString', {
                  configurable: true,
                  enumerable: false,
                  writable: true
              });
          }
      }

      // ES5 15.9.5.43
      // http://es5.github.com/#x15.9.5.43
      // This function returns a String value represent the instance in time
      // represented by this Date object. The format of the String is the Date Time
      // string format defined in 15.9.1.15. All fields are present in the String.
      // The time zone is always UTC, denoted by the suffix Z. If the time value of
      // this object is not a finite Number a RangeError exception is thrown.
      var negativeDate = -62198755200000;
      var negativeYearString = '-000001';
      var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1; // eslint-disable-line max-len
      var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

      var getTime = call.bind(Date.prototype.getTime);

      defineProperties(Date.prototype, {
          toISOString: function toISOString() {
              if (!isFinite(this) || !isFinite(getTime(this))) {
                  // Adope Photoshop requires the second check.
                  throw new RangeError('Date.prototype.toISOString called on non-finite value.');
              }

              var year = originalGetUTCFullYear(this);

              var month = originalGetUTCMonth(this);
              // see https://github.com/es-shims/es5-shim/issues/111
              year += Math.floor(month / 12);
              month = ((month % 12) + 12) % 12;

              // the date time string format is specified in 15.9.1.15.
              var result = [
                  month + 1,
                  originalGetUTCDate(this),
                  originalGetUTCHours(this),
                  originalGetUTCMinutes(this),
                  originalGetUTCSeconds(this)
              ];
              year = (
                  (year < 0 ? '-' : (year > 9999 ? '+' : ''))
                  + strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
              );

              for (var i = 0; i < result.length; ++i) {
                  // pad months, days, hours, minutes, and seconds to have two digits.
                  result[i] = strSlice('00' + result[i], -2);
              }
              // pad milliseconds to have three digits.
              return (
                  year + '-' + arraySlice(result, 0, 2).join('-')
                  + 'T' + arraySlice(result, 2).join(':') + '.'
                  + strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
              );
          }
      }, hasNegativeDateBug || hasSafari51DateBug);

      // ES5 15.9.5.44
      // http://es5.github.com/#x15.9.5.44
      // This function provides a String representation of a Date object for use by
      // JSON.stringify (15.12.3).
      var dateToJSONIsSupported = (function () {
          try {
              return Date.prototype.toJSON
                  && new Date(NaN).toJSON() === null
                  && new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1
                  && Date.prototype.toJSON.call({ // generic
                      toISOString: function () { return true; }
                  });
          } catch (e) {
              return false;
          }
      }());
      if (!dateToJSONIsSupported) {
          Date.prototype.toJSON = function toJSON(key) {
              // When the toJSON method is called with argument key, the following
              // steps are taken:

              // 1.  Let O be the result of calling ToObject, giving it the this
              // value as its argument.
              // 2. Let tv be ES.ToPrimitive(O, hint Number).
              var O = $Object(this);
              var tv = ES.ToPrimitive(O);
              // 3. If tv is a Number and is not finite, return null.
              if (typeof tv === 'number' && !isFinite(tv)) {
                  return null;
              }
              // 4. Let toISO be the result of calling the [[Get]] internal method of
              // O with argument "toISOString".
              var toISO = O.toISOString;
              // 5. If IsCallable(toISO) is false, throw a TypeError exception.
              if (!isCallable(toISO)) {
                  throw new TypeError('toISOString property is not callable');
              }
              // 6. Return the result of calling the [[Call]] internal method of
              //  toISO with O as the this value and an empty argument list.
              return toISO.call(O);

              // NOTE 1 The argument is ignored.

              // NOTE 2 The toJSON function is intentionally generic; it does not
              // require that its this value be a Date object. Therefore, it can be
              // transferred to other kinds of objects for use as a method. However,
              // it does require that any such object have a toISOString method. An
              // object is free to use the argument key to filter its
              // stringification.
          };
      }

      // ES5 15.9.4.2
      // http://es5.github.com/#x15.9.4.2
      // based on work shared by Daniel Friesen (dantman)
      // http://gist.github.com/303249
      var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
      var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
      var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
      if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
          // XXX global assignment won't work in embeddings that use
          // an alternate object for the context.
          /* global Date: true */
          var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
          var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
          // eslint-disable-next-line no-implicit-globals, no-global-assign
          Date = (function (NativeDate) {
              // Date.length === 7
              var DateShim = function Date(Y, M, D, h, m, s, ms) {
                  var length = arguments.length;
                  var date;
                  if (this instanceof NativeDate) {
                      var seconds = s;
                      var millis = ms;
                      if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                          // work around a Safari 8/9 bug where it treats the seconds as signed
                          var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                          var sToShift = Math.floor(msToShift / 1e3);
                          seconds += sToShift;
                          millis -= sToShift * 1e3;
                      }
                      date = length === 1 && $String(Y) === Y // isString(Y)
                          // We explicitly pass it through parse:
                          ? new NativeDate(DateShim.parse(Y))
                          // We have to manually make calls depending on argument
                          // length here
                          : length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis)
                              : length >= 6 ? new NativeDate(Y, M, D, h, m, seconds)
                                  : length >= 5 ? new NativeDate(Y, M, D, h, m)
                                      : length >= 4 ? new NativeDate(Y, M, D, h)
                                          : length >= 3 ? new NativeDate(Y, M, D)
                                              : length >= 2 ? new NativeDate(Y, M)
                                                  : length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y)
                                                      : new NativeDate();
                  } else {
                      date = NativeDate.apply(this, arguments);
                  }
                  if (!isPrimitive(date)) {
                      // Prevent mixups with unfixed Date object
                      defineProperties(date, { constructor: DateShim }, true);
                  }
                  return date;
              };

              // 15.9.1.15 Date Time String Format.
              var isoDateExpression = new RegExp('^'
                  + '(\\d{4}|[+-]\\d{6})' // four-digit year capture or sign + 6-digit extended year
                  + '(?:-(\\d{2})' // optional month capture
                  + '(?:-(\\d{2})' // optional day capture
                  + '(?:' // capture hours:minutes:seconds.milliseconds
                      + 'T(\\d{2})' // hours capture
                      + ':(\\d{2})' // minutes capture
                      + '(?:' // optional :seconds.milliseconds
                          + ':(\\d{2})' // seconds capture
                          + '(?:(\\.\\d{1,}))?' // milliseconds capture
                      + ')?'
                  + '(' // capture UTC offset component
                      + 'Z|' // UTC capture
                      + '(?:' // offset specifier +/-hours:minutes
                          + '([-+])' // sign capture
                          + '(\\d{2})' // hours offset capture
                          + ':(\\d{2})' // minutes offset capture
                      + ')'
                  + ')?)?)?)?'
              + '$');

              var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

              var dayFromMonth = function dayFromMonth(year, month) {
                  var t = month > 1 ? 1 : 0;
                  return (
                      months[month]
                      + Math.floor((year - 1969 + t) / 4)
                      - Math.floor((year - 1901 + t) / 100)
                      + Math.floor((year - 1601 + t) / 400)
                      + (365 * (year - 1970))
                  );
              };

              var toUTC = function toUTC(t) {
                  var s = 0;
                  var ms = t;
                  if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                      // work around a Safari 8/9 bug where it treats the seconds as signed
                      var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                      var sToShift = Math.floor(msToShift / 1e3);
                      s += sToShift;
                      ms -= sToShift * 1e3;
                  }
                  return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
              };

              // Copy any custom methods a 3rd party library may have added
              for (var key in NativeDate) {
                  if (owns(NativeDate, key)) {
                      DateShim[key] = NativeDate[key];
                  }
              }

              // Copy "native" methods explicitly; they may be non-enumerable
              defineProperties(DateShim, {
                  now: NativeDate.now,
                  UTC: NativeDate.UTC
              }, true);
              DateShim.prototype = NativeDate.prototype;
              defineProperties(DateShim.prototype, { constructor: DateShim }, true);

              // Upgrade Date.parse to handle simplified ISO 8601 strings
              var parseShim = function parse(string) {
                  var match = isoDateExpression.exec(string);
                  if (match) {
                      // parse months, days, hours, minutes, seconds, and milliseconds
                      // provide default values if necessary
                      // parse the UTC offset component
                      var year = $Number(match[1]),
                          month = $Number(match[2] || 1) - 1,
                          day = $Number(match[3] || 1) - 1,
                          hour = $Number(match[4] || 0),
                          minute = $Number(match[5] || 0),
                          second = $Number(match[6] || 0),
                          millisecond = Math.floor($Number(match[7] || 0) * 1000),
                          // When time zone is missed, local offset should be used
                          // (ES 5.1 bug)
                          // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                          isLocalTime = Boolean(match[4] && !match[8]),
                          signOffset = match[9] === '-' ? 1 : -1,
                          hourOffset = $Number(match[10] || 0),
                          minuteOffset = $Number(match[11] || 0),
                          result;
                      var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                      if (
                          hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25)
                          && minute < 60 && second < 60 && millisecond < 1000
                          && month > -1 && month < 12 && hourOffset < 24
                          && minuteOffset < 60 // detect invalid offsets
                          && day > -1
                          && day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                      ) {
                          result = (
                              ((dayFromMonth(year, month) + day) * 24)
                              + hour
                              + (hourOffset * signOffset)
                          ) * 60;
                          result = ((
                              ((result + minute + (minuteOffset * signOffset)) * 60)
                              + second
                          ) * 1000) + millisecond;
                          if (isLocalTime) {
                              result = toUTC(result);
                          }
                          if (-8.64e15 <= result && result <= 8.64e15) {
                              return result;
                          }
                      }
                      return NaN;
                  }
                  return NativeDate.parse.apply(this, arguments);
              };
              defineProperties(DateShim, { parse: parseShim });

              return DateShim;
          }(Date));
          /* global Date: false */
      }

      // ES5 15.9.4.4
      // http://es5.github.com/#x15.9.4.4
      if (!Date.now) {
          Date.now = function now() {
              return new Date().getTime();
          };
      }

      //
      // Number
      // ======
      //

      // ES5.1 15.7.4.5
      // http://es5.github.com/#x15.7.4.5
      var hasToFixedBugs = NumberPrototype.toFixed && (
          (0.00008).toFixed(3) !== '0.000'
          || (0.9).toFixed(0) !== '1'
          || (1.255).toFixed(2) !== '1.25'
          || (1000000000000000128).toFixed(0) !== '1000000000000000128'
      );

      var toFixedHelpers = {
          base: 1e7,
          size: 6,
          data: [0, 0, 0, 0, 0, 0],
          multiply: function multiply(n, c) {
              var i = -1;
              var c2 = c;
              while (++i < toFixedHelpers.size) {
                  c2 += n * toFixedHelpers.data[i];
                  toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                  c2 = Math.floor(c2 / toFixedHelpers.base);
              }
          },
          divide: function divide(n) {
              var i = toFixedHelpers.size;
              var c = 0;
              while (--i >= 0) {
                  c += toFixedHelpers.data[i];
                  toFixedHelpers.data[i] = Math.floor(c / n);
                  c = (c % n) * toFixedHelpers.base;
              }
          },
          numToString: function numToString() {
              var i = toFixedHelpers.size;
              var s = '';
              while (--i >= 0) {
                  if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                      var t = $String(toFixedHelpers.data[i]);
                      if (s === '') {
                          s = t;
                      } else {
                          s += strSlice('0000000', 0, 7 - t.length) + t;
                      }
                  }
              }
              return s;
          },
          pow: function pow(x, n, acc) {
              return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
          },
          log: function log(x) {
              var n = 0;
              var x2 = x;
              while (x2 >= 4096) {
                  n += 12;
                  x2 /= 4096;
              }
              while (x2 >= 2) {
                  n += 1;
                  x2 /= 2;
              }
              return n;
          }
      };

      var toFixedShim = function toFixed(fractionDigits) {
          var f, x, s, m, e, z, j, k;

          // Test for NaN and round fractionDigits down
          f = $Number(fractionDigits);
          f = isActualNaN(f) ? 0 : Math.floor(f);

          if (f < 0 || f > 20) {
              throw new RangeError('Number.toFixed called with invalid number of decimals');
          }

          x = $Number(this);

          if (isActualNaN(x)) {
              return 'NaN';
          }

          // If it is too big or small, return the string value of the number
          if (x <= -1e21 || x >= 1e21) {
              return $String(x);
          }

          s = '';

          if (x < 0) {
              s = '-';
              x = -x;
          }

          m = '0';

          if (x > 1e-21) {
              // 1e-21 < x < 1e21
              // -70 < log2(x) < 70
              e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
              z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
              z *= 0x10000000000000; // Math.pow(2, 52);
              e = 52 - e;

              // -18 < e < 122
              // x = z / 2 ^ e
              if (e > 0) {
                  toFixedHelpers.multiply(0, z);
                  j = f;

                  while (j >= 7) {
                      toFixedHelpers.multiply(1e7, 0);
                      j -= 7;
                  }

                  toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                  j = e - 1;

                  while (j >= 23) {
                      toFixedHelpers.divide(1 << 23);
                      j -= 23;
                  }

                  toFixedHelpers.divide(1 << j);
                  toFixedHelpers.multiply(1, 1);
                  toFixedHelpers.divide(2);
                  m = toFixedHelpers.numToString();
              } else {
                  toFixedHelpers.multiply(0, z);
                  toFixedHelpers.multiply(1 << (-e), 0);
                  m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
              }
          }

          if (f > 0) {
              k = m.length;

              if (k <= f) {
                  m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
              } else {
                  m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
              }
          } else {
              m = s + m;
          }

          return m;
      };
      defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

      var hasToPrecisionUndefinedBug = (function () {
          try {
              return 1.0.toPrecision(undefined) === '1';
          } catch (e) {
              return true;
          }
      }());
      var originalToPrecision = NumberPrototype.toPrecision;
      defineProperties(NumberPrototype, {
          toPrecision: function toPrecision(precision) {
              return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
          }
      }, hasToPrecisionUndefinedBug);

      //
      // String
      // ======
      //

      // ES5 15.5.4.14
      // http://es5.github.com/#x15.5.4.14

      // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
      // Many browsers do not split properly with regular expressions or they
      // do not perform the split correctly under obscure conditions.
      // See http://blog.stevenlevithan.com/archives/cross-browser-split
      // I've tested in many browsers and this seems to cover the deviant ones:
      //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
      //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
      //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
      //       [undefined, "t", undefined, "e", ...]
      //    ''.split(/.?/) should be [], not [""]
      //    '.'.split(/()()/) should be ["."], not ["", "", "."]

      if (
          'ab'.split(/(?:ab)*/).length !== 2
          || '.'.split(/(.?)(.?)/).length !== 4
          || 'tesst'.split(/(s)*/)[1] === 't'
          || 'test'.split(/(?:)/, -1).length !== 4
          || ''.split(/.?/).length
          || '.'.split(/()()/).length > 1
      ) {
          (function () {
              var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
              var maxSafe32BitInt = Math.pow(2, 32) - 1;

              StringPrototype.split = function (separator, limit) {
                  var string = String(this);
                  if (typeof separator === 'undefined' && limit === 0) {
                      return [];
                  }

                  // If `separator` is not a regex, use native split
                  if (!isRegex(separator)) {
                      return strSplit(this, separator, limit);
                  }

                  var output = [];
                  var flags = (separator.ignoreCase ? 'i' : '')
                              + (separator.multiline ? 'm' : '')
                              + (separator.unicode ? 'u' : '') // in ES6
                              + (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                      lastLastIndex = 0,
                      // Make `global` and avoid `lastIndex` issues by working with a copy
                      separator2, match, lastIndex, lastLength;
                  var separatorCopy = new RegExp(separator.source, flags + 'g');
                  if (!compliantExecNpcg) {
                      // Doesn't need flags gy, but they don't hurt
                      separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                  }
                  /* Values for `limit`, per the spec:
                   * If undefined: 4294967295 // maxSafe32BitInt
                   * If 0, Infinity, or NaN: 0
                   * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                   * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                   * If other: Type-convert, then use the above rules
                   */
                  var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                  match = separatorCopy.exec(string);
                  while (match) {
                      // `separatorCopy.lastIndex` is not reliable cross-browser
                      lastIndex = match.index + match[0].length;
                      if (lastIndex > lastLastIndex) {
                          pushCall(output, strSlice(string, lastLastIndex, match.index));
                          // Fix browsers whose `exec` methods don't consistently return `undefined` for
                          // nonparticipating capturing groups
                          if (!compliantExecNpcg && match.length > 1) {
                              /* eslint-disable no-loop-func */
                              match[0].replace(separator2, function () {
                                  var arguments$1 = arguments;

                                  for (var i = 1; i < arguments.length - 2; i++) {
                                      if (typeof arguments$1[i] === 'undefined') {
                                          match[i] = void 0;
                                      }
                                  }
                              });
                              /* eslint-enable no-loop-func */
                          }
                          if (match.length > 1 && match.index < string.length) {
                              array_push.apply(output, arraySlice(match, 1));
                          }
                          lastLength = match[0].length;
                          lastLastIndex = lastIndex;
                          if (output.length >= splitLimit) {
                              break;
                          }
                      }
                      if (separatorCopy.lastIndex === match.index) {
                          separatorCopy.lastIndex++; // Avoid an infinite loop
                      }
                      match = separatorCopy.exec(string);
                  }
                  if (lastLastIndex === string.length) {
                      if (lastLength || !separatorCopy.test('')) {
                          pushCall(output, '');
                      }
                  } else {
                      pushCall(output, strSlice(string, lastLastIndex));
                  }
                  return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
              };
          }());

      // [bugfix, chrome]
      // If separator is undefined, then the result array contains just one String,
      // which is the this value (converted to a String). If limit is not undefined,
      // then the output array is truncated so that it contains no more than limit
      // elements.
      // "0".split(undefined, 0) -> []
      } else if ('0'.split(void 0, 0).length) {
          StringPrototype.split = function split(separator, limit) {
              if (typeof separator === 'undefined' && limit === 0) {
                  return [];
              }
              return strSplit(this, separator, limit);
          };
      }

      var str_replace = StringPrototype.replace;
      var replaceReportsGroupsCorrectly = (function () {
          var groups = [];
          'x'.replace(/x(.)?/g, function (match, group) {
              pushCall(groups, group);
          });
          return groups.length === 1 && typeof groups[0] === 'undefined';
      }());

      if (!replaceReportsGroupsCorrectly) {
          StringPrototype.replace = function replace(searchValue, replaceValue) {
              var isFn = isCallable(replaceValue);
              var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
              if (!isFn || !hasCapturingGroups) {
                  return str_replace.call(this, searchValue, replaceValue);
              } else {
                  var wrappedReplaceValue = function (match) {
                      var length = arguments.length;
                      var originalLastIndex = searchValue.lastIndex;
                      searchValue.lastIndex = 0;
                      var args = searchValue.exec(match) || [];
                      searchValue.lastIndex = originalLastIndex;
                      pushCall(args, arguments[length - 2], arguments[length - 1]);
                      return replaceValue.apply(this, args);
                  };
                  return str_replace.call(this, searchValue, wrappedReplaceValue);
              }
          };
      }

      // ECMA-262, 3rd B.2.3
      // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
      // non-normative section suggesting uniform semantics and it should be
      // normalized across all browsers
      // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
      var string_substr = StringPrototype.substr;
      var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
      defineProperties(StringPrototype, {
          substr: function substr(start, length) {
              var normalizedStart = start;
              if (start < 0) {
                  normalizedStart = max(this.length + start, 0);
              }
              return string_substr.call(this, normalizedStart, length);
          }
      }, hasNegativeSubstrBug);

      // ES5 15.5.4.20
      // whitespace from: http://es5.github.io/#x15.5.4.20
      var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003'
          + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028'
          + '\u2029\uFEFF';
      var zeroWidth = '\u200b';
      var wsRegexChars = '[' + ws + ']';
      var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
      var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
      var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
      defineProperties(StringPrototype, {
          // http://blog.stevenlevithan.com/archives/faster-trim-javascript
          // http://perfectionkills.com/whitespace-deviations/
          trim: function trim() {
              if (typeof this === 'undefined' || this === null) {
                  throw new TypeError("can't convert " + this + ' to object');
              }
              return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
          }
      }, hasTrimWhitespaceBug);
      var trim = call.bind(String.prototype.trim);

      var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcあい'.lastIndexOf('あい', 2) !== -1;
      defineProperties(StringPrototype, {
          lastIndexOf: function lastIndexOf(searchString) {
              if (typeof this === 'undefined' || this === null) {
                  throw new TypeError("can't convert " + this + ' to object');
              }
              var S = $String(this);
              var searchStr = $String(searchString);
              var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
              var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
              var start = min(max(pos, 0), S.length);
              var searchLen = searchStr.length;
              var k = start + searchLen;
              while (k > 0) {
                  k = max(0, k - searchLen);
                  var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                  if (index !== -1) {
                      return k + index;
                  }
              }
              return -1;
          }
      }, hasLastIndexBug);

      var originalLastIndexOf = StringPrototype.lastIndexOf;
      defineProperties(StringPrototype, {
          lastIndexOf: function lastIndexOf(searchString) {
              return originalLastIndexOf.apply(this, arguments);
          }
      }, StringPrototype.lastIndexOf.length !== 1);

      // ES-5 15.1.2.2
      // eslint-disable-next-line radix
      if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
          /* global parseInt: true */
          parseInt = (function (origParseInt) {
              var hexRegex = /^[-+]?0[xX]/;
              return function parseInt(str, radix) {
                  if (typeof str === 'symbol') {
                      // handle Symbols in node 8.3/8.4
                      // eslint-disable-next-line no-implicit-coercion, no-unused-expressions
                      '' + str; // jscs:ignore disallowImplicitTypeConversion
                  }

                  var string = trim(String(str));
                  var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                  return origParseInt(string, defaultedRadix);
              };
          }(parseInt));
      }

      // https://es5.github.io/#x15.1.2.3
      if (1 / parseFloat('-0') !== -Infinity) {
          /* global parseFloat: true */
          parseFloat = (function (origParseFloat) {
              return function parseFloat(string) {
                  var inputString = trim(String(string));
                  var result = origParseFloat(inputString);
                  return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
              };
          }(parseFloat));
      }

      if (String(new RangeError('test')) !== 'RangeError: test') {
          var errorToStringShim = function toString() {
              if (typeof this === 'undefined' || this === null) {
                  throw new TypeError("can't convert " + this + ' to object');
              }
              var name = this.name;
              if (typeof name === 'undefined') {
                  name = 'Error';
              } else if (typeof name !== 'string') {
                  name = $String(name);
              }
              var msg = this.message;
              if (typeof msg === 'undefined') {
                  msg = '';
              } else if (typeof msg !== 'string') {
                  msg = $String(msg);
              }
              if (!name) {
                  return msg;
              }
              if (!msg) {
                  return name;
              }
              return name + ': ' + msg;
          };
          // can't use defineProperties here because of toString enumeration issue in IE <= 8
          Error.prototype.toString = errorToStringShim;
      }

      if (supportsDescriptors) {
          var ensureNonEnumerable = function (obj, prop) {
              if (isEnum(obj, prop)) {
                  var desc = Object.getOwnPropertyDescriptor(obj, prop);
                  if (desc.configurable) {
                      desc.enumerable = false;
                      Object.defineProperty(obj, prop, desc);
                  }
              }
          };
          ensureNonEnumerable(Error.prototype, 'message');
          if (Error.prototype.message !== '') {
              Error.prototype.message = '';
          }
          ensureNonEnumerable(Error.prototype, 'name');
      }

      if (String(/a/mig) !== '/a/gim') {
          var regexToString = function toString() {
              var str = '/' + this.source + '/';
              if (this.global) {
                  str += 'g';
              }
              if (this.ignoreCase) {
                  str += 'i';
              }
              if (this.multiline) {
                  str += 'm';
              }
              return str;
          };
          // can't use defineProperties here because of toString enumeration issue in IE <= 8
          RegExp.prototype.toString = regexToString;
      }
  }));
  });

  var es6Shim = createCommonjsModule(function (module, exports) {
  /*!
   * https://github.com/paulmillr/es6-shim
   * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
   *   and contributors,  MIT License
   * es6-shim: v0.35.4
   * see https://github.com/paulmillr/es6-shim/blob/0.35.3/LICENSE
   * Details and documentation:
   * https://github.com/paulmillr/es6-shim/
   */

  // UMD (Universal Module Definition)
  // see https://github.com/umdjs/umd/blob/master/returnExports.js
  (function (root, factory) {
    /*global define, module, exports */
    {
      // Node. Does not work with strict CommonJS, but
      // only CommonJS-like environments that support module.exports,
      // like Node.
      module.exports = factory();
    }
  }(commonjsGlobal, function () {

    var _apply = Function.call.bind(Function.apply);
    var _call = Function.call.bind(Function.call);
    var isArray = Array.isArray;
    var keys = Object.keys;

    var not = function notThunker(func) {
      return function notThunk() {
        return !_apply(func, this, arguments);
      };
    };
    var throwsError = function (func) {
      try {
        func();
        return false;
      } catch (e) {
        return true;
      }
    };
    var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {
      try {
        return func();
      } catch (e) {
        return false;
      }
    };

    var isCallableWithoutNew = not(throwsError);
    var arePropertyDescriptorsSupported = function () {
      // if Object.defineProperty exists but throws, it's IE 8
      return !throwsError(function () {
        return Object.defineProperty({}, 'x', { get: function () { } }); // eslint-disable-line getter-return
      });
    };
    var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
    var functionsHaveNames = (function foo() {}).name === 'foo'; // eslint-disable-line no-extra-parens

    var _forEach = Function.call.bind(Array.prototype.forEach);
    var _reduce = Function.call.bind(Array.prototype.reduce);
    var _filter = Function.call.bind(Array.prototype.filter);
    var _some = Function.call.bind(Array.prototype.some);

    var defineProperty = function (object, name, value, force) {
      if (!force && name in object) { return; }
      if (supportsDescriptors) {
        Object.defineProperty(object, name, {
          configurable: true,
          enumerable: false,
          writable: true,
          value: value
        });
      } else {
        object[name] = value;
      }
    };

    // Define configurable, writable and non-enumerable props
    // if they don’t exist.
    var defineProperties = function (object, map, forceOverride) {
      _forEach(keys(map), function (name) {
        var method = map[name];
        defineProperty(object, name, method, !!forceOverride);
      });
    };

    var _toString = Function.call.bind(Object.prototype.toString);
    var isCallable = typeof /abc/ === 'function' ? function IsCallableSlow(x) {
      // Some old browsers (IE, FF) say that typeof /abc/ === 'function'
      return typeof x === 'function' && _toString(x) === '[object Function]';
    } : function IsCallableFast(x) { return typeof x === 'function'; };

    var Value = {
      getter: function (object, name, getter) {
        if (!supportsDescriptors) {
          throw new TypeError('getters require true ES5 support');
        }
        Object.defineProperty(object, name, {
          configurable: true,
          enumerable: false,
          get: getter
        });
      },
      proxy: function (originalObject, key, targetObject) {
        if (!supportsDescriptors) {
          throw new TypeError('getters require true ES5 support');
        }
        var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
        Object.defineProperty(targetObject, key, {
          configurable: originalDescriptor.configurable,
          enumerable: originalDescriptor.enumerable,
          get: function getKey() { return originalObject[key]; },
          set: function setKey(value) { originalObject[key] = value; }
        });
      },
      redefine: function (object, property, newValue) {
        if (supportsDescriptors) {
          var descriptor = Object.getOwnPropertyDescriptor(object, property);
          descriptor.value = newValue;
          Object.defineProperty(object, property, descriptor);
        } else {
          object[property] = newValue;
        }
      },
      defineByDescriptor: function (object, property, descriptor) {
        if (supportsDescriptors) {
          Object.defineProperty(object, property, descriptor);
        } else if ('value' in descriptor) {
          object[property] = descriptor.value;
        }
      },
      preserveToString: function (target, source) {
        if (source && isCallable(source.toString)) {
          defineProperty(target, 'toString', source.toString.bind(source), true);
        }
      }
    };

    // Simple shim for Object.create on ES3 browsers
    // (unlike real shim, no attempt to support `prototype === null`)
    var create = Object.create || function (prototype, properties) {
      var Prototype = function Prototype() {};
      Prototype.prototype = prototype;
      var object = new Prototype();
      if (typeof properties !== 'undefined') {
        keys(properties).forEach(function (key) {
          Value.defineByDescriptor(object, key, properties[key]);
        });
      }
      return object;
    };

    var supportsSubclassing = function (C, f) {
      if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }
      return valueOrFalseIfThrows(function () {
        var Sub = function Subclass(arg) {
          var o = new C(arg);
          Object.setPrototypeOf(o, Subclass.prototype);
          return o;
        };
        Object.setPrototypeOf(Sub, C);
        Sub.prototype = create(C.prototype, {
          constructor: { value: Sub }
        });
        return f(Sub);
      });
    };

    var getGlobal = function () {
      /* global self, window, global */
      // the only reliable means to get the global object is
      // `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof self !== 'undefined') { return self; }
      if (typeof window !== 'undefined') { return window; }
      if (typeof commonjsGlobal !== 'undefined') { return commonjsGlobal; }
      throw new Error('unable to locate global object');
    };

    var globals = getGlobal();
    var globalIsFinite = globals.isFinite;
    var _indexOf = Function.call.bind(String.prototype.indexOf);
    var _arrayIndexOfApply = Function.apply.bind(Array.prototype.indexOf);
    var _concat = Function.call.bind(Array.prototype.concat);
    // var _sort = Function.call.bind(Array.prototype.sort);
    var _strSlice = Function.call.bind(String.prototype.slice);
    var _push = Function.call.bind(Array.prototype.push);
    var _pushApply = Function.apply.bind(Array.prototype.push);
    var _shift = Function.call.bind(Array.prototype.shift);
    var _max = Math.max;
    var _min = Math.min;
    var _floor = Math.floor;
    var _abs = Math.abs;
    var _exp = Math.exp;
    var _log = Math.log;
    var _sqrt = Math.sqrt;
    var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
    var ArrayIterator; // make our implementation private
    var noop = function () {};

    var OrigMap = globals.Map;
    var origMapDelete = OrigMap && OrigMap.prototype['delete'];
    var origMapGet = OrigMap && OrigMap.prototype.get;
    var origMapHas = OrigMap && OrigMap.prototype.has;
    var origMapSet = OrigMap && OrigMap.prototype.set;

    var Symbol = globals.Symbol || {};
    var symbolSpecies = Symbol.species || '@@species';

    var numberIsNaN = Number.isNaN || function isNaN(value) {
      // NaN !== NaN, but they are identical.
      // NaNs are the only non-reflexive value, i.e., if x !== x,
      // then x is NaN.
      // isNaN is broken: it converts its argument to number, so
      // isNaN('foo') => true
      return value !== value;
    };
    var numberIsFinite = Number.isFinite || function isFinite(value) {
      return typeof value === 'number' && globalIsFinite(value);
    };
    var _sign = isCallable(Math.sign) ? Math.sign : function sign(value) {
      var number = Number(value);
      if (number === 0) { return number; }
      if (numberIsNaN(number)) { return number; }
      return number < 0 ? -1 : 1;
    };
    var _log1p = function log1p(value) {
      var x = Number(value);
      if (x < -1 || numberIsNaN(x)) { return NaN; }
      if (x === 0 || x === Infinity) { return x; }
      if (x === -1) { return -Infinity; }

      return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));
    };

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
      return _toString(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
      return value !== null &&
        typeof value === 'object' &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        _toString(value) !== '[object Array]' &&
        _toString(value.callee) === '[object Function]';
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    var Type = {
      primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },
      string: function (x) { return _toString(x) === '[object String]'; },
      regex: function (x) { return _toString(x) === '[object RegExp]'; },
      symbol: function (x) {
        return typeof globals.Symbol === 'function' && typeof x === 'symbol';
      }
    };

    var overrideNative = function overrideNative(object, property, replacement) {
      var original = object[property];
      defineProperty(object, property, replacement, true);
      Value.preserveToString(object[property], original);
    };

    // eslint-disable-next-line no-restricted-properties
    var hasSymbols = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' && Type.symbol(Symbol());

    // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
    // we're going to use an arbitrary _-prefixed name to make our shims
    // work properly with each other, even though we don't have full Iterator
    // support.  That is, `Array.from(map.keys())` will work, but we don't
    // pretend to export a "real" Iterator interface.
    var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
    // Firefox ships a partial implementation using the name @@iterator.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
    // So use that name if we detect it.
    if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
      $iterator$ = '@@iterator';
    }

    // Reflect
    if (!globals.Reflect) {
      defineProperty(globals, 'Reflect', {}, true);
    }
    var Reflect = globals.Reflect;

    var $String = String;

    /* global document */
    var domAll = (typeof document === 'undefined' || !document) ? null : document.all;
    var isNullOrUndefined = domAll == null ? function isNullOrUndefined(x) {
      return x == null;
    } : function isNullOrUndefinedAndNotDocumentAll(x) {
      return x == null && x !== domAll;
    };

    var ES = {
      // http://www.ecma-international.org/ecma-262/6.0/#sec-call
      Call: function Call(F, V) {
        var args = arguments.length > 2 ? arguments[2] : [];
        if (!ES.IsCallable(F)) {
          throw new TypeError(F + ' is not a function');
        }
        return _apply(F, V, args);
      },

      RequireObjectCoercible: function (x, optMessage) {
        if (isNullOrUndefined(x)) {
          throw new TypeError(optMessage || 'Cannot call method on ' + x);
        }
        return x;
      },

      // This might miss the "(non-standard exotic and does not implement
      // [[Call]])" case from
      // http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation
      // but we can't find any evidence these objects exist in practice.
      // If we find some in the future, you could test `Object(x) === x`,
      // which is reliable according to
      // http://www.ecma-international.org/ecma-262/6.0/#sec-toobject
      // but is not well optimized by runtimes and creates an object
      // whenever it returns false, and thus is very slow.
      TypeIsObject: function (x) {
        if (x === void 0 || x === null || x === true || x === false) {
          return false;
        }
        return typeof x === 'function' || typeof x === 'object' || x === domAll;
      },

      ToObject: function (o, optMessage) {
        return Object(ES.RequireObjectCoercible(o, optMessage));
      },

      IsCallable: isCallable,

      IsConstructor: function (x) {
        // We can't tell callables from constructors in ES5
        return ES.IsCallable(x);
      },

      ToInt32: function (x) {
        return ES.ToNumber(x) >> 0;
      },

      ToUint32: function (x) {
        return ES.ToNumber(x) >>> 0;
      },

      ToNumber: function (value) {
        if (_toString(value) === '[object Symbol]') {
          throw new TypeError('Cannot convert a Symbol value to a number');
        }
        return +value;
      },

      ToInteger: function (value) {
        var number = ES.ToNumber(value);
        if (numberIsNaN(number)) { return 0; }
        if (number === 0 || !numberIsFinite(number)) { return number; }
        return (number > 0 ? 1 : -1) * _floor(_abs(number));
      },

      ToLength: function (value) {
        var len = ES.ToInteger(value);
        if (len <= 0) { return 0; } // includes converting -0 to +0
        if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
        return len;
      },

      SameValue: function (a, b) {
        if (a === b) {
          // 0 === -0, but they are not identical.
          if (a === 0) { return 1 / a === 1 / b; }
          return true;
        }
        return numberIsNaN(a) && numberIsNaN(b);
      },

      SameValueZero: function (a, b) {
        // same as SameValue except for SameValueZero(+0, -0) == true
        return (a === b) || (numberIsNaN(a) && numberIsNaN(b));
      },

      IsIterable: function (o) {
        return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
      },

      GetIterator: function (o) {
        if (isArguments(o)) {
          // special case support for `arguments`
          return new ArrayIterator(o, 'value');
        }
        var itFn = ES.GetMethod(o, $iterator$);
        if (!ES.IsCallable(itFn)) {
          // Better diagnostics if itFn is null or undefined
          throw new TypeError('value is not an iterable');
        }
        var it = ES.Call(itFn, o);
        if (!ES.TypeIsObject(it)) {
          throw new TypeError('bad iterator');
        }
        return it;
      },

      GetMethod: function (o, p) {
        var func = ES.ToObject(o)[p];
        if (isNullOrUndefined(func)) {
          return void 0;
        }
        if (!ES.IsCallable(func)) {
          throw new TypeError('Method not callable: ' + p);
        }
        return func;
      },

      IteratorComplete: function (iterResult) {
        return !!iterResult.done;
      },

      IteratorClose: function (iterator, completionIsThrow) {
        var returnMethod = ES.GetMethod(iterator, 'return');
        if (returnMethod === void 0) {
          return;
        }
        var innerResult, innerException;
        try {
          innerResult = ES.Call(returnMethod, iterator);
        } catch (e) {
          innerException = e;
        }
        if (completionIsThrow) {
          return;
        }
        if (innerException) {
          throw innerException;
        }
        if (!ES.TypeIsObject(innerResult)) {
          throw new TypeError("Iterator's return method returned a non-object.");
        }
      },

      IteratorNext: function (it) {
        var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
        if (!ES.TypeIsObject(result)) {
          throw new TypeError('bad iterator');
        }
        return result;
      },

      IteratorStep: function (it) {
        var result = ES.IteratorNext(it);
        var done = ES.IteratorComplete(result);
        return done ? false : result;
      },

      Construct: function (C, args, newTarget, isES6internal) {
        var target = typeof newTarget === 'undefined' ? C : newTarget;

        if (!isES6internal && Reflect.construct) {
          // Try to use Reflect.construct if available
          return Reflect.construct(C, args, target);
        }
        // OK, we have to fake it.  This will only work if the
        // C.[[ConstructorKind]] == "base" -- but that's the only
        // kind we can make in ES5 code anyway.

        // OrdinaryCreateFromConstructor(target, "%ObjectPrototype%")
        var proto = target.prototype;
        if (!ES.TypeIsObject(proto)) {
          proto = Object.prototype;
        }
        var obj = create(proto);
        // Call the constructor.
        var result = ES.Call(C, obj, args);
        return ES.TypeIsObject(result) ? result : obj;
      },

      SpeciesConstructor: function (O, defaultConstructor) {
        var C = O.constructor;
        if (C === void 0) {
          return defaultConstructor;
        }
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad constructor');
        }
        var S = C[symbolSpecies];
        if (isNullOrUndefined(S)) {
          return defaultConstructor;
        }
        if (!ES.IsConstructor(S)) {
          throw new TypeError('Bad @@species');
        }
        return S;
      },

      CreateHTML: function (string, tag, attribute, value) {
        var S = ES.ToString(string);
        var p1 = '<' + tag;
        if (attribute !== '') {
          var V = ES.ToString(value);
          var escapedV = V.replace(/"/g, '&quot;');
          p1 += ' ' + attribute + '="' + escapedV + '"';
        }
        var p2 = p1 + '>';
        var p3 = p2 + S;
        return p3 + '</' + tag + '>';
      },

      IsRegExp: function IsRegExp(argument) {
        if (!ES.TypeIsObject(argument)) {
          return false;
        }
        var isRegExp = argument[Symbol.match];
        if (typeof isRegExp !== 'undefined') {
          return !!isRegExp;
        }
        return Type.regex(argument);
      },

      ToString: function ToString(string) {
        return $String(string);
      }
    };

    // Well-known Symbol shims
    if (supportsDescriptors && hasSymbols) {
      var defineWellKnownSymbol = function defineWellKnownSymbol(name) {
        if (Type.symbol(Symbol[name])) {
          return Symbol[name];
        }
        // eslint-disable-next-line no-restricted-properties
        var sym = Symbol['for']('Symbol.' + name);
        Object.defineProperty(Symbol, name, {
          configurable: false,
          enumerable: false,
          writable: false,
          value: sym
        });
        return sym;
      };
      if (!Type.symbol(Symbol.search)) {
        var symbolSearch = defineWellKnownSymbol('search');
        var originalSearch = String.prototype.search;
        defineProperty(RegExp.prototype, symbolSearch, function search(string) {
          return ES.Call(originalSearch, string, [this]);
        });
        var searchShim = function search(regexp) {
          var O = ES.RequireObjectCoercible(this);
          if (!isNullOrUndefined(regexp)) {
            var searcher = ES.GetMethod(regexp, symbolSearch);
            if (typeof searcher !== 'undefined') {
              return ES.Call(searcher, regexp, [O]);
            }
          }
          return ES.Call(originalSearch, O, [ES.ToString(regexp)]);
        };
        overrideNative(String.prototype, 'search', searchShim);
      }
      if (!Type.symbol(Symbol.replace)) {
        var symbolReplace = defineWellKnownSymbol('replace');
        var originalReplace = String.prototype.replace;
        defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {
          return ES.Call(originalReplace, string, [this, replaceValue]);
        });
        var replaceShim = function replace(searchValue, replaceValue) {
          var O = ES.RequireObjectCoercible(this);
          if (!isNullOrUndefined(searchValue)) {
            var replacer = ES.GetMethod(searchValue, symbolReplace);
            if (typeof replacer !== 'undefined') {
              return ES.Call(replacer, searchValue, [O, replaceValue]);
            }
          }
          return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);
        };
        overrideNative(String.prototype, 'replace', replaceShim);
      }
      if (!Type.symbol(Symbol.split)) {
        var symbolSplit = defineWellKnownSymbol('split');
        var originalSplit = String.prototype.split;
        defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {
          return ES.Call(originalSplit, string, [this, limit]);
        });
        var splitShim = function split(separator, limit) {
          var O = ES.RequireObjectCoercible(this);
          if (!isNullOrUndefined(separator)) {
            var splitter = ES.GetMethod(separator, symbolSplit);
            if (typeof splitter !== 'undefined') {
              return ES.Call(splitter, separator, [O, limit]);
            }
          }
          return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);
        };
        overrideNative(String.prototype, 'split', splitShim);
      }
      var symbolMatchExists = Type.symbol(Symbol.match);
      var stringMatchIgnoresSymbolMatch = symbolMatchExists && (function () {
        // Firefox 41, through Nightly 45 has Symbol.match, but String#match ignores it.
        // Firefox 40 and below have Symbol.match but String#match works fine.
        var o = {};
        o[Symbol.match] = function () { return 42; };
        return 'a'.match(o) !== 42;
      }());
      if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {
        var symbolMatch = defineWellKnownSymbol('match');

        var originalMatch = String.prototype.match;
        defineProperty(RegExp.prototype, symbolMatch, function match(string) {
          return ES.Call(originalMatch, string, [this]);
        });

        var matchShim = function match(regexp) {
          var O = ES.RequireObjectCoercible(this);
          if (!isNullOrUndefined(regexp)) {
            var matcher = ES.GetMethod(regexp, symbolMatch);
            if (typeof matcher !== 'undefined') {
              return ES.Call(matcher, regexp, [O]);
            }
          }
          return ES.Call(originalMatch, O, [ES.ToString(regexp)]);
        };
        overrideNative(String.prototype, 'match', matchShim);
      }
    }

    var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {
      Value.preserveToString(replacement, original);
      if (Object.setPrototypeOf) {
        // sets up proper prototype chain where possible
        Object.setPrototypeOf(original, replacement);
      }
      if (supportsDescriptors) {
        _forEach(Object.getOwnPropertyNames(original), function (key) {
          if (key in noop || keysToSkip[key]) { return; }
          Value.proxy(original, key, replacement);
        });
      } else {
        _forEach(Object.keys(original), function (key) {
          if (key in noop || keysToSkip[key]) { return; }
          replacement[key] = original[key];
        });
      }
      replacement.prototype = original.prototype;
      Value.redefine(original.prototype, 'constructor', replacement);
    };

    var defaultSpeciesGetter = function () { return this; };
    var addDefaultSpecies = function (C) {
      if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
        Value.getter(C, symbolSpecies, defaultSpeciesGetter);
      }
    };

    var addIterator = function (prototype, impl) {
      var implementation = impl || function iterator() { return this; };
      defineProperty(prototype, $iterator$, implementation);
      if (!prototype[$iterator$] && Type.symbol($iterator$)) {
        // implementations are buggy when $iterator$ is a Symbol
        prototype[$iterator$] = implementation;
      }
    };

    var createDataProperty = function createDataProperty(object, name, value) {
      if (supportsDescriptors) {
        Object.defineProperty(object, name, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: value
        });
      } else {
        object[name] = value;
      }
    };
    var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {
      createDataProperty(object, name, value);
      if (!ES.SameValue(object[name], value)) {
        throw new TypeError('property is nonconfigurable');
      }
    };

    var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {
      // This is an es5 approximation to es6 construct semantics.  in es6,
      // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)
      // just sets the internal variable NewTarget (in es6 syntax `new.target`)
      // to Foo and then returns Foo().

      // Many ES6 object then have constructors of the form:
      // 1. If NewTarget is undefined, throw a TypeError exception
      // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)

      // So we're going to emulate those first two steps.
      if (!ES.TypeIsObject(o)) {
        throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);
      }
      var proto = defaultNewTarget.prototype;
      if (!ES.TypeIsObject(proto)) {
        proto = defaultProto;
      }
      var obj = create(proto);
      for (var name in slots) {
        if (_hasOwnProperty(slots, name)) {
          var value = slots[name];
          defineProperty(obj, name, value, true);
        }
      }
      return obj;
    };

    // Firefox 31 reports this function's length as 0
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
    if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
      var originalFromCodePoint = String.fromCodePoint;
      overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) {
        return ES.Call(originalFromCodePoint, this, arguments);
      });
    }

    var StringShims = {
      fromCodePoint: function fromCodePoint(codePoints) {
        var arguments$1 = arguments;

        var result = [];
        var next;
        for (var i = 0, length = arguments.length; i < length; i++) {
          next = Number(arguments$1[i]);
          if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
            throw new RangeError('Invalid code point ' + next);
          }

          if (next < 0x10000) {
            _push(result, String.fromCharCode(next));
          } else {
            next -= 0x10000;
            _push(result, String.fromCharCode((next >> 10) + 0xD800));
            _push(result, String.fromCharCode((next % 0x400) + 0xDC00));
          }
        }
        return result.join('');
      },

      raw: function raw(callSite) {
        var arguments$1 = arguments;

        var cooked = ES.ToObject(callSite, 'bad callSite');
        var rawString = ES.ToObject(cooked.raw, 'bad raw value');
        var len = rawString.length;
        var literalsegments = ES.ToLength(len);
        if (literalsegments <= 0) {
          return '';
        }

        var stringElements = [];
        var nextIndex = 0;
        var nextKey, next, nextSeg, nextSub;
        while (nextIndex < literalsegments) {
          nextKey = ES.ToString(nextIndex);
          nextSeg = ES.ToString(rawString[nextKey]);
          _push(stringElements, nextSeg);
          if (nextIndex + 1 >= literalsegments) {
            break;
          }
          next = nextIndex + 1 < arguments$1.length ? arguments$1[nextIndex + 1] : '';
          nextSub = ES.ToString(next);
          _push(stringElements, nextSub);
          nextIndex += 1;
        }
        return stringElements.join('');
      }
    };
    if (String.raw && String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {
      // IE 11 TP has a broken String.raw implementation
      overrideNative(String, 'raw', StringShims.raw);
    }
    defineProperties(String, StringShims);

    // Fast repeat, uses the `Exponentiation by squaring` algorithm.
    // Perf: http://jsperf.com/string-repeat2/2
    var stringRepeat = function repeat(s, times) {
      if (times < 1) { return ''; }
      if (times % 2) { return repeat(s, times - 1) + s; }
      var half = repeat(s, times / 2);
      return half + half;
    };
    var stringMaxLength = Infinity;

    var StringPrototypeShims = {
      repeat: function repeat(times) {
        var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
        var numTimes = ES.ToInteger(times);
        if (numTimes < 0 || numTimes >= stringMaxLength) {
          throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
        }
        return stringRepeat(thisStr, numTimes);
      },

      startsWith: function startsWith(searchString) {
        var S = ES.ToString(ES.RequireObjectCoercible(this));
        if (ES.IsRegExp(searchString)) {
          throw new TypeError('Cannot call method "startsWith" with a regex');
        }
        var searchStr = ES.ToString(searchString);
        var position;
        if (arguments.length > 1) {
          position = arguments[1];
        }
        var start = _max(ES.ToInteger(position), 0);
        return _strSlice(S, start, start + searchStr.length) === searchStr;
      },

      endsWith: function endsWith(searchString) {
        var S = ES.ToString(ES.RequireObjectCoercible(this));
        if (ES.IsRegExp(searchString)) {
          throw new TypeError('Cannot call method "endsWith" with a regex');
        }
        var searchStr = ES.ToString(searchString);
        var len = S.length;
        var endPosition;
        if (arguments.length > 1) {
          endPosition = arguments[1];
        }
        var pos = typeof endPosition === 'undefined' ? len : ES.ToInteger(endPosition);
        var end = _min(_max(pos, 0), len);
        return _strSlice(S, end - searchStr.length, end) === searchStr;
      },

      includes: function includes(searchString) {
        if (ES.IsRegExp(searchString)) {
          throw new TypeError('"includes" does not accept a RegExp');
        }
        var searchStr = ES.ToString(searchString);
        var position;
        if (arguments.length > 1) {
          position = arguments[1];
        }
        // Somehow this trick makes method 100% compat with the spec.
        return _indexOf(this, searchStr, position) !== -1;
      },

      codePointAt: function codePointAt(pos) {
        var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
        var position = ES.ToInteger(pos);
        var length = thisStr.length;
        if (position >= 0 && position < length) {
          var first = thisStr.charCodeAt(position);
          var isEnd = position + 1 === length;
          if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
          var second = thisStr.charCodeAt(position + 1);
          if (second < 0xDC00 || second > 0xDFFF) { return first; }
          return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
        }
      }
    };
    if (String.prototype.includes && 'a'.includes('a', Infinity) !== false) {
      overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
    }

    if (String.prototype.startsWith && String.prototype.endsWith) {
      var startsWithRejectsRegex = throwsError(function () {
        /* throws if spec-compliant */
        return '/a/'.startsWith(/a/);
      });
      var startsWithHandlesInfinity = valueOrFalseIfThrows(function () {
        return 'abc'.startsWith('a', Infinity) === false;
      });
      if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {
        // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation
        overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
        overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
      }
    }
    if (hasSymbols) {
      var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
        var re = /a/;
        re[Symbol.match] = false;
        return '/a/'.startsWith(re);
      });
      if (!startsWithSupportsSymbolMatch) {
        overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
      }
      var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
        var re = /a/;
        re[Symbol.match] = false;
        return '/a/'.endsWith(re);
      });
      if (!endsWithSupportsSymbolMatch) {
        overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
      }
      var includesSupportsSymbolMatch = valueOrFalseIfThrows(function () {
        var re = /a/;
        re[Symbol.match] = false;
        return '/a/'.includes(re);
      });
      if (!includesSupportsSymbolMatch) {
        overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
      }
    }

    defineProperties(String.prototype, StringPrototypeShims);

    // whitespace from: http://es5.github.io/#x15.5.4.20
    // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
    var ws = [
      '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
      '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
      '\u2029\uFEFF'
    ].join('');
    var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
    var trimShim = function trim() {
      return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, '');
    };
    var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
    var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
    var isBadHexRegex = /^[-+]0x[0-9a-f]+$/i;
    var hasStringTrimBug = nonWS.trim().length !== nonWS.length;
    defineProperty(String.prototype, 'trim', trimShim, hasStringTrimBug);

    // Given an argument x, it will return an IteratorResult object,
    // with value set to x and done to false.
    // Given no arguments, it will return an iterator completion object.
    var iteratorResult = function (x) {
      return { value: x, done: arguments.length === 0 };
    };

    // see http://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype-@@iterator
    var StringIterator = function (s) {
      ES.RequireObjectCoercible(s);
      this._s = ES.ToString(s);
      this._i = 0;
    };
    StringIterator.prototype.next = function () {
      var s = this._s;
      var i = this._i;
      if (typeof s === 'undefined' || i >= s.length) {
        this._s = void 0;
        return iteratorResult();
      }
      var first = s.charCodeAt(i);
      var second, len;
      if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
        len = 1;
      } else {
        second = s.charCodeAt(i + 1);
        len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
      }
      this._i = i + len;
      return iteratorResult(s.substr(i, len));
    };
    addIterator(StringIterator.prototype);
    addIterator(String.prototype, function () {
      return new StringIterator(this);
    });

    var ArrayShims = {
      from: function from(items) {
        var C = this;
        var mapFn;
        if (arguments.length > 1) {
          mapFn = arguments[1];
        }
        var mapping, T;
        if (typeof mapFn === 'undefined') {
          mapping = false;
        } else {
          if (!ES.IsCallable(mapFn)) {
            throw new TypeError('Array.from: when provided, the second argument must be a function');
          }
          if (arguments.length > 2) {
            T = arguments[2];
          }
          mapping = true;
        }

        // Note that that Arrays will use ArrayIterator:
        // https://bugs.ecmascript.org/show_bug.cgi?id=2416
        var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== 'undefined';

        var length, result, i;
        if (usingIterator) {
          result = ES.IsConstructor(C) ? Object(new C()) : [];
          var iterator = ES.GetIterator(items);
          var next, nextValue;

          i = 0;
          while (true) {
            next = ES.IteratorStep(iterator);
            if (next === false) {
              break;
            }
            nextValue = next.value;
            try {
              if (mapping) {
                nextValue = typeof T === 'undefined' ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);
              }
              result[i] = nextValue;
            } catch (e) {
              ES.IteratorClose(iterator, true);
              throw e;
            }
            i += 1;
          }
          length = i;
        } else {
          var arrayLike = ES.ToObject(items);
          length = ES.ToLength(arrayLike.length);
          result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
          var value;
          for (i = 0; i < length; ++i) {
            value = arrayLike[i];
            if (mapping) {
              value = typeof T === 'undefined' ? mapFn(value, i) : _call(mapFn, T, value, i);
            }
            createDataPropertyOrThrow(result, i, value);
          }
        }

        result.length = length;
        return result;
      },

      of: function of() {
        var arguments$1 = arguments;

        var len = arguments.length;
        var C = this;
        var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
        for (var k = 0; k < len; ++k) {
          createDataPropertyOrThrow(A, k, arguments$1[k]);
        }
        A.length = len;
        return A;
      }
    };
    defineProperties(Array, ArrayShims);
    addDefaultSpecies(Array);

    // Our ArrayIterator is private; see
    // https://github.com/paulmillr/es6-shim/issues/252
    ArrayIterator = function (array, kind) {
      this.i = 0;
      this.array = array;
      this.kind = kind;
    };

    defineProperties(ArrayIterator.prototype, {
      next: function () {
        var i = this.i;
        var array = this.array;
        if (!(this instanceof ArrayIterator)) {
          throw new TypeError('Not an ArrayIterator');
        }
        if (typeof array !== 'undefined') {
          var len = ES.ToLength(array.length);
          for (; i < len; i++) {
            var kind = this.kind;
            var retval;
            if (kind === 'key') {
              retval = i;
            } else if (kind === 'value') {
              retval = array[i];
            } else if (kind === 'entry') {
              retval = [i, array[i]];
            }
            this.i = i + 1;
            return iteratorResult(retval);
          }
        }
        this.array = void 0;
        return iteratorResult();
      }
    });
    addIterator(ArrayIterator.prototype);

    /*
    var orderKeys = function orderKeys(a, b) {
      var aNumeric = String(ES.ToInteger(a)) === a;
      var bNumeric = String(ES.ToInteger(b)) === b;
      if (aNumeric && bNumeric) {
        return b - a;
      } else if (aNumeric && !bNumeric) {
        return -1;
      } else if (!aNumeric && bNumeric) {
        return 1;
      } else {
        return a.localeCompare(b);
      }
    };

    var getAllKeys = function getAllKeys(object) {
      var ownKeys = [];
      var keys = [];

      for (var key in object) {
        _push(_hasOwnProperty(object, key) ? ownKeys : keys, key);
      }
      _sort(ownKeys, orderKeys);
      _sort(keys, orderKeys);

      return _concat(ownKeys, keys);
    };
    */

    // note: this is positioned here because it depends on ArrayIterator
    var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {
      // Detects a bug in Webkit nightly r181886
      var Foo = function Foo(len) { this.length = len; };
      Foo.prototype = [];
      var fooArr = Array.of.apply(Foo, [1, 2]);
      return fooArr instanceof Foo && fooArr.length === 2;
    }());
    if (!arrayOfSupportsSubclassing) {
      overrideNative(Array, 'of', ArrayShims.of);
    }

    var ArrayPrototypeShims = {
      copyWithin: function copyWithin(target, start) {
        var o = ES.ToObject(this);
        var len = ES.ToLength(o.length);
        var relativeTarget = ES.ToInteger(target);
        var relativeStart = ES.ToInteger(start);
        var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
        var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
        var end;
        if (arguments.length > 2) {
          end = arguments[2];
        }
        var relativeEnd = typeof end === 'undefined' ? len : ES.ToInteger(end);
        var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);
        var count = _min(finalItem - from, len - to);
        var direction = 1;
        if (from < to && to < (from + count)) {
          direction = -1;
          from += count - 1;
          to += count - 1;
        }
        while (count > 0) {
          if (from in o) {
            o[to] = o[from];
          } else {
            delete o[to];
          }
          from += direction;
          to += direction;
          count -= 1;
        }
        return o;
      },

      fill: function fill(value) {
        var start;
        if (arguments.length > 1) {
          start = arguments[1];
        }
        var end;
        if (arguments.length > 2) {
          end = arguments[2];
        }
        var O = ES.ToObject(this);
        var len = ES.ToLength(O.length);
        start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
        end = ES.ToInteger(typeof end === 'undefined' ? len : end);

        var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
        var relativeEnd = end < 0 ? len + end : end;

        for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
          O[i] = value;
        }
        return O;
      },

      find: function find(predicate) {
        var list = ES.ToObject(this);
        var length = ES.ToLength(list.length);
        if (!ES.IsCallable(predicate)) {
          throw new TypeError('Array#find: predicate must be a function');
        }
        var thisArg = arguments.length > 1 ? arguments[1] : null;
        for (var i = 0, value; i < length; i++) {
          value = list[i];
          if (thisArg) {
            if (_call(predicate, thisArg, value, i, list)) {
              return value;
            }
          } else if (predicate(value, i, list)) {
            return value;
          }
        }
      },

      findIndex: function findIndex(predicate) {
        var list = ES.ToObject(this);
        var length = ES.ToLength(list.length);
        if (!ES.IsCallable(predicate)) {
          throw new TypeError('Array#findIndex: predicate must be a function');
        }
        var thisArg = arguments.length > 1 ? arguments[1] : null;
        for (var i = 0; i < length; i++) {
          if (thisArg) {
            if (_call(predicate, thisArg, list[i], i, list)) {
              return i;
            }
          } else if (predicate(list[i], i, list)) {
            return i;
          }
        }
        return -1;
      },

      keys: function keys() {
        return new ArrayIterator(this, 'key');
      },

      values: function values() {
        return new ArrayIterator(this, 'value');
      },

      entries: function entries() {
        return new ArrayIterator(this, 'entry');
      }
    };
    // Safari 7.1 defines Array#keys and Array#entries natively,
    // but the resulting ArrayIterator objects don't have a "next" method.
    if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
      delete Array.prototype.keys;
    }
    if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
      delete Array.prototype.entries;
    }

    // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
    if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
      defineProperties(Array.prototype, {
        values: Array.prototype[$iterator$]
      });
      if (Type.symbol(Symbol.unscopables)) {
        Array.prototype[Symbol.unscopables].values = true;
      }
    }
    // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
    if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {
      var originalArrayPrototypeValues = Array.prototype.values;
      overrideNative(Array.prototype, 'values', function values() { return ES.Call(originalArrayPrototypeValues, this, arguments); });
      defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
    }
    defineProperties(Array.prototype, ArrayPrototypeShims);

    if (1 / [true].indexOf(true, -0) < 0) {
      // indexOf when given a position arg of -0 should return +0.
      // https://github.com/tc39/ecma262/pull/316
      defineProperty(Array.prototype, 'indexOf', function indexOf(searchElement) {
        var value = _arrayIndexOfApply(this, arguments);
        if (value === 0 && (1 / value) < 0) {
          return 0;
        }
        return value;
      }, true);
    }

    addIterator(Array.prototype, function () { return this.values(); });
    // Chrome defines keys/values/entries on Array, but doesn't give us
    // any way to identify its iterator.  So add our own shimmed field.
    if (Object.getPrototypeOf) {
      addIterator(Object.getPrototypeOf([].values()));
    }

    // note: this is positioned here because it relies on Array#entries
    var arrayFromSwallowsNegativeLengths = (function () {
      // Detects a Firefox bug in v32
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
      return valueOrFalseIfThrows(function () {
        return Array.from({ length: -1 }).length === 0;
      });
    }());
    var arrayFromHandlesIterables = (function () {
      // Detects a bug in Webkit nightly r181886
      var arr = Array.from([0].entries());
      return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
    }());
    if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
      overrideNative(Array, 'from', ArrayShims.from);
    }
    var arrayFromHandlesUndefinedMapFunction = (function () {
      // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,
      // but the spec doesn't care if it's provided or not - undefined doesn't throw.
      return valueOrFalseIfThrows(function () {
        return Array.from([0], void 0);
      });
    }());
    if (!arrayFromHandlesUndefinedMapFunction) {
      var origArrayFrom = Array.from;
      overrideNative(Array, 'from', function from(items) {
        if (arguments.length > 1 && typeof arguments[1] !== 'undefined') {
          return ES.Call(origArrayFrom, this, arguments);
        } else {
          return _call(origArrayFrom, this, items);
        }
      });
    }

    var int32sAsOne = -(Math.pow(2, 32) - 1);
    var toLengthsCorrectly = function (method, reversed) {
      var obj = { length: int32sAsOne };
      obj[reversed ? (obj.length >>> 0) - 1 : 0] = true;
      return valueOrFalseIfThrows(function () {
        _call(method, obj, function () {
          // note: in nonconforming browsers, this will be called
          // -1 >>> 0 times, which is 4294967295, so the throw matters.
          throw new RangeError('should not reach here');
        }, []);
        return true;
      });
    };
    if (!toLengthsCorrectly(Array.prototype.forEach)) {
      var originalForEach = Array.prototype.forEach;
      overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {
        return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);
      });
    }
    if (!toLengthsCorrectly(Array.prototype.map)) {
      var originalMap = Array.prototype.map;
      overrideNative(Array.prototype, 'map', function map(callbackFn) {
        return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);
      });
    }
    if (!toLengthsCorrectly(Array.prototype.filter)) {
      var originalFilter = Array.prototype.filter;
      overrideNative(Array.prototype, 'filter', function filter(callbackFn) {
        return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);
      });
    }
    if (!toLengthsCorrectly(Array.prototype.some)) {
      var originalSome = Array.prototype.some;
      overrideNative(Array.prototype, 'some', function some(callbackFn) {
        return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);
      });
    }
    if (!toLengthsCorrectly(Array.prototype.every)) {
      var originalEvery = Array.prototype.every;
      overrideNative(Array.prototype, 'every', function every(callbackFn) {
        return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);
      });
    }
    if (!toLengthsCorrectly(Array.prototype.reduce)) {
      var originalReduce = Array.prototype.reduce;
      overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {
        return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);
      });
    }
    if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
      var originalReduceRight = Array.prototype.reduceRight;
      overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {
        return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);
      });
    }

    var lacksOctalSupport = Number('0o10') !== 8;
    var lacksBinarySupport = Number('0b10') !== 2;
    var trimsNonWhitespace = _some(nonWS, function (c) {
      return Number(c + 0 + c) === 0;
    });
    if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {
      var OrigNumber = Number;
      var binaryRegex = /^0b[01]+$/i;
      var octalRegex = /^0o[0-7]+$/i;
      // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
      var isBinary = binaryRegex.test.bind(binaryRegex);
      var isOctal = octalRegex.test.bind(octalRegex);
      var toPrimitive = function (O) { // need to replace this with `es-to-primitive/es6`
        var result;
        if (typeof O.valueOf === 'function') {
          result = O.valueOf();
          if (Type.primitive(result)) {
            return result;
          }
        }
        if (typeof O.toString === 'function') {
          result = O.toString();
          if (Type.primitive(result)) {
            return result;
          }
        }
        throw new TypeError('No default value');
      };
      var hasNonWS = nonWSregex.test.bind(nonWSregex);
      var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);
      var NumberShim = (function () {
        // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.
        var NumberShim = function Number(value) {
          var primValue;
          if (arguments.length > 0) {
            primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');
          } else {
            primValue = 0;
          }
          if (typeof primValue === 'string') {
            primValue = ES.Call(trimShim, primValue);
            if (isBinary(primValue)) {
              primValue = parseInt(_strSlice(primValue, 2), 2);
            } else if (isOctal(primValue)) {
              primValue = parseInt(_strSlice(primValue, 2), 8);
            } else if (hasNonWS(primValue) || isBadHex(primValue)) {
              primValue = NaN;
            }
          }
          var receiver = this;
          var valueOfSucceeds = valueOrFalseIfThrows(function () {
            OrigNumber.prototype.valueOf.call(receiver);
            return true;
          });
          if (receiver instanceof NumberShim && !valueOfSucceeds) {
            return new OrigNumber(primValue);
          }
          return OrigNumber(primValue);
        };
        return NumberShim;
      }());
      wrapConstructor(OrigNumber, NumberShim, {});
      // this is necessary for ES3 browsers, where these properties are non-enumerable.
      defineProperties(NumberShim, {
        NaN: OrigNumber.NaN,
        MAX_VALUE: OrigNumber.MAX_VALUE,
        MIN_VALUE: OrigNumber.MIN_VALUE,
        NEGATIVE_INFINITY: OrigNumber.NEGATIVE_INFINITY,
        POSITIVE_INFINITY: OrigNumber.POSITIVE_INFINITY
      });
      /* globals Number: true */
      /* eslint-disable no-undef, no-global-assign */
      Number = NumberShim;
      Value.redefine(globals, 'Number', NumberShim);
      /* eslint-enable no-undef, no-global-assign */
      /* globals Number: false */
    }

    var maxSafeInteger = Math.pow(2, 53) - 1;
    defineProperties(Number, {
      MAX_SAFE_INTEGER: maxSafeInteger,
      MIN_SAFE_INTEGER: -maxSafeInteger,
      EPSILON: 2.220446049250313e-16,

      parseInt: globals.parseInt,
      parseFloat: globals.parseFloat,

      isFinite: numberIsFinite,

      isInteger: function isInteger(value) {
        return numberIsFinite(value) && ES.ToInteger(value) === value;
      },

      isSafeInteger: function isSafeInteger(value) {
        return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
      },

      isNaN: numberIsNaN
    });
    // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)
    defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);

    // Work around bugs in Array#find and Array#findIndex -- early
    // implementations skipped holes in sparse arrays. (Note that the
    // implementations of find/findIndex indirectly use shimmed
    // methods of Number, so this test has to happen down here.)
    /* eslint-disable no-sparse-arrays */
    if ([, 1].find(function () { return true; }) === 1) {
      overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);
    }
    if ([, 1].findIndex(function () { return true; }) !== 0) {
      overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);
    }
    /* eslint-enable no-sparse-arrays */

    var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
    var ensureEnumerable = function ensureEnumerable(obj, prop) {
      if (supportsDescriptors && isEnumerableOn(obj, prop)) {
        Object.defineProperty(obj, prop, { enumerable: false });
      }
    };
    var sliceArgs = function sliceArgs() {
      var arguments$1 = arguments;

      // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
      // and https://gist.github.com/WebReflection/4327762cb87a8c634a29
      var initial = Number(this);
      var len = arguments.length;
      var desiredArgCount = len - initial;
      var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
      for (var i = initial; i < len; ++i) {
        args[i - initial] = arguments$1[i];
      }
      return args;
    };
    var assignTo = function assignTo(source) {
      return function assignToSource(target, key) {
        target[key] = source[key];
        return target;
      };
    };
    var assignReducer = function (target, source) {
      var sourceKeys = keys(Object(source));
      var symbols;
      if (ES.IsCallable(Object.getOwnPropertySymbols)) {
        symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
      }
      return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);
    };

    var ObjectShims = {
      // 19.1.3.1
      assign: function (target, source) {
        var to = ES.ToObject(target, 'Cannot convert undefined or null to object');
        return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);
      },

      // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865
      is: function is(a, b) {
        return ES.SameValue(a, b);
      }
    };
    var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {
      // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
      // which is 72% slower than our shim, and Firefox 40's native implementation.
      var thrower = Object.preventExtensions({ 1: 2 });
      try {
        Object.assign(thrower, 'xy');
      } catch (e) {
        return thrower[1] === 'y';
      }
    }());
    if (assignHasPendingExceptions) {
      overrideNative(Object, 'assign', ObjectShims.assign);
    }
    defineProperties(Object, ObjectShims);

    if (supportsDescriptors) {
      var ES5ObjectShims = {
        // 19.1.3.9
        // shim from https://gist.github.com/WebReflection/5593554
        setPrototypeOf: (function (Object, magic) {
          var set;

          var checkArgs = function (O, proto) {
            if (!ES.TypeIsObject(O)) {
              throw new TypeError('cannot set prototype on a non-object');
            }
            if (!(proto === null || ES.TypeIsObject(proto))) {
              throw new TypeError('can only set prototype to an object or null' + proto);
            }
          };

          var setPrototypeOf = function (O, proto) {
            checkArgs(O, proto);
            _call(set, O, proto);
            return O;
          };

          try {
            // this works already in Firefox and Safari
            set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
            _call(set, {}, null);
          } catch (e) {
            if (Object.prototype !== {}[magic]) {
              // IE < 11 cannot be shimmed
              return;
            }
            // probably Chrome or some old Mobile stock browser
            set = function (proto) {
              this[magic] = proto;
            };
            // please note that this will **not** work
            // in those browsers that do not inherit
            // __proto__ by mistake from Object.prototype
            // in these cases we should probably throw an error
            // or at least be informed about the issue
            setPrototypeOf.polyfill = setPrototypeOf(
              setPrototypeOf({}, null),
              Object.prototype
            ) instanceof Object;
            // setPrototypeOf.polyfill === true means it works as meant
            // setPrototypeOf.polyfill === false means it's not 100% reliable
            // setPrototypeOf.polyfill === undefined
            // or
            // setPrototypeOf.polyfill ==  null means it's not a polyfill
            // which means it works as expected
            // we can even delete Object.prototype.__proto__;
          }
          return setPrototypeOf;
        }(Object, '__proto__'))
      };

      defineProperties(Object, ES5ObjectShims);
    }

    // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
    // but Object.create(null) does.
    if (Object.setPrototypeOf && Object.getPrototypeOf &&
        Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
        Object.getPrototypeOf(Object.create(null)) === null) {
      (function () {
        var FAKENULL = Object.create(null);
        var gpo = Object.getPrototypeOf;
        var spo = Object.setPrototypeOf;
        Object.getPrototypeOf = function (o) {
          var result = gpo(o);
          return result === FAKENULL ? null : result;
        };
        Object.setPrototypeOf = function (o, p) {
          var proto = p === null ? FAKENULL : p;
          return spo(o, proto);
        };
        Object.setPrototypeOf.polyfill = false;
      }());
    }

    var objectKeysAcceptsPrimitives = !throwsError(function () { return Object.keys('foo'); });
    if (!objectKeysAcceptsPrimitives) {
      var originalObjectKeys = Object.keys;
      overrideNative(Object, 'keys', function keys(value) {
        return originalObjectKeys(ES.ToObject(value));
      });
      keys = Object.keys;
    }
    var objectKeysRejectsRegex = throwsError(function () { return Object.keys(/a/g); });
    if (objectKeysRejectsRegex) {
      var regexRejectingObjectKeys = Object.keys;
      overrideNative(Object, 'keys', function keys(value) {
        if (Type.regex(value)) {
          var regexKeys = [];
          for (var k in value) {
            if (_hasOwnProperty(value, k)) {
              _push(regexKeys, k);
            }
          }
          return regexKeys;
        }
        return regexRejectingObjectKeys(value);
      });
      keys = Object.keys;
    }

    if (Object.getOwnPropertyNames) {
      var objectGOPNAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyNames('foo'); });
      if (!objectGOPNAcceptsPrimitives) {
        var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
        var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
        overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
          var val = ES.ToObject(value);
          if (_toString(val) === '[object Window]') {
            try {
              return originalObjectGetOwnPropertyNames(val);
            } catch (e) {
              // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
              return _concat([], cachedWindowNames);
            }
          }
          return originalObjectGetOwnPropertyNames(val);
        });
      }
    }
    if (Object.getOwnPropertyDescriptor) {
      var objectGOPDAcceptsPrimitives = !throwsError(function () { return Object.getOwnPropertyDescriptor('foo', 'bar'); });
      if (!objectGOPDAcceptsPrimitives) {
        var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
          return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
        });
      }
    }
    if (Object.seal) {
      var objectSealAcceptsPrimitives = !throwsError(function () { return Object.seal('foo'); });
      if (!objectSealAcceptsPrimitives) {
        var originalObjectSeal = Object.seal;
        overrideNative(Object, 'seal', function seal(value) {
          if (!ES.TypeIsObject(value)) { return value; }
          return originalObjectSeal(value);
        });
      }
    }
    if (Object.isSealed) {
      var objectIsSealedAcceptsPrimitives = !throwsError(function () { return Object.isSealed('foo'); });
      if (!objectIsSealedAcceptsPrimitives) {
        var originalObjectIsSealed = Object.isSealed;
        overrideNative(Object, 'isSealed', function isSealed(value) {
          if (!ES.TypeIsObject(value)) { return true; }
          return originalObjectIsSealed(value);
        });
      }
    }
    if (Object.freeze) {
      var objectFreezeAcceptsPrimitives = !throwsError(function () { return Object.freeze('foo'); });
      if (!objectFreezeAcceptsPrimitives) {
        var originalObjectFreeze = Object.freeze;
        overrideNative(Object, 'freeze', function freeze(value) {
          if (!ES.TypeIsObject(value)) { return value; }
          return originalObjectFreeze(value);
        });
      }
    }
    if (Object.isFrozen) {
      var objectIsFrozenAcceptsPrimitives = !throwsError(function () { return Object.isFrozen('foo'); });
      if (!objectIsFrozenAcceptsPrimitives) {
        var originalObjectIsFrozen = Object.isFrozen;
        overrideNative(Object, 'isFrozen', function isFrozen(value) {
          if (!ES.TypeIsObject(value)) { return true; }
          return originalObjectIsFrozen(value);
        });
      }
    }
    if (Object.preventExtensions) {
      var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { return Object.preventExtensions('foo'); });
      if (!objectPreventExtensionsAcceptsPrimitives) {
        var originalObjectPreventExtensions = Object.preventExtensions;
        overrideNative(Object, 'preventExtensions', function preventExtensions(value) {
          if (!ES.TypeIsObject(value)) { return value; }
          return originalObjectPreventExtensions(value);
        });
      }
    }
    if (Object.isExtensible) {
      var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { return Object.isExtensible('foo'); });
      if (!objectIsExtensibleAcceptsPrimitives) {
        var originalObjectIsExtensible = Object.isExtensible;
        overrideNative(Object, 'isExtensible', function isExtensible(value) {
          if (!ES.TypeIsObject(value)) { return false; }
          return originalObjectIsExtensible(value);
        });
      }
    }
    if (Object.getPrototypeOf) {
      var objectGetProtoAcceptsPrimitives = !throwsError(function () { return Object.getPrototypeOf('foo'); });
      if (!objectGetProtoAcceptsPrimitives) {
        var originalGetProto = Object.getPrototypeOf;
        overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {
          return originalGetProto(ES.ToObject(value));
        });
      }
    }

    var hasFlags = supportsDescriptors && (function () {
      var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');
      return desc && ES.IsCallable(desc.get);
    }());
    if (supportsDescriptors && !hasFlags) {
      var regExpFlagsGetter = function flags() {
        if (!ES.TypeIsObject(this)) {
          throw new TypeError('Method called on incompatible type: must be an object.');
        }
        var result = '';
        if (this.global) {
          result += 'g';
        }
        if (this.ignoreCase) {
          result += 'i';
        }
        if (this.multiline) {
          result += 'm';
        }
        if (this.unicode) {
          result += 'u';
        }
        if (this.sticky) {
          result += 'y';
        }
        return result;
      };

      Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
    }

    var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function () {
      return String(new RegExp(/a/g, 'i')) === '/a/i';
    });
    var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && (function () {
      // Edge 0.12 supports flags fully, but does not support Symbol.match
      var regex = /./;
      regex[Symbol.match] = false;
      return RegExp(regex) === regex;
    }());

    var regexToStringIsGeneric = valueOrFalseIfThrows(function () {
      return RegExp.prototype.toString.call({ source: 'abc' }) === '/abc/';
    });
    var regexToStringSupportsGenericFlags = regexToStringIsGeneric && valueOrFalseIfThrows(function () {
      return RegExp.prototype.toString.call({ source: 'a', flags: 'b' }) === '/a/b';
    });
    if (!regexToStringIsGeneric || !regexToStringSupportsGenericFlags) {
      var origRegExpToString = RegExp.prototype.toString;
      defineProperty(RegExp.prototype, 'toString', function toString() {
        var R = ES.RequireObjectCoercible(this);
        if (Type.regex(R)) {
          return _call(origRegExpToString, R);
        }
        var pattern = $String(R.source);
        var flags = $String(R.flags);
        return '/' + pattern + '/' + flags;
      }, true);
      Value.preserveToString(RegExp.prototype.toString, origRegExpToString);
    }

    if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {
      var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get;
      var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'source') || {};
      var legacySourceGetter = function () {
        // prior to it being a getter, it's own + nonconfigurable
        return this.source;
      };
      var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;

      var OrigRegExp = RegExp;
      var RegExpShim = (function () {
        return function RegExp(pattern, flags) {
          var patternIsRegExp = ES.IsRegExp(pattern);
          var calledWithNew = this instanceof RegExp;
          if (!calledWithNew && patternIsRegExp && typeof flags === 'undefined' && pattern.constructor === RegExp) {
            return pattern;
          }

          var P = pattern;
          var F = flags;
          if (Type.regex(pattern)) {
            P = ES.Call(sourceGetter, pattern);
            F = typeof flags === 'undefined' ? ES.Call(flagsGetter, pattern) : flags;
            return new RegExp(P, F);
          } else if (patternIsRegExp) {
            P = pattern.source;
            F = typeof flags === 'undefined' ? pattern.flags : flags;
          }
          return new OrigRegExp(pattern, flags);
        };
      }());
      wrapConstructor(OrigRegExp, RegExpShim, {
        $input: true // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
      });
      /* globals RegExp: true */
      /* eslint-disable no-undef, no-global-assign */
      RegExp = RegExpShim;
      Value.redefine(globals, 'RegExp', RegExpShim);
      /* eslint-enable no-undef, no-global-assign */
      /* globals RegExp: false */
    }

    if (supportsDescriptors) {
      var regexGlobals = {
        input: '$_',
        lastMatch: '$&',
        lastParen: '$+',
        leftContext: '$`',
        rightContext: '$\''
      };
      _forEach(keys(regexGlobals), function (prop) {
        if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
          Value.getter(RegExp, regexGlobals[prop], function get() {
            return RegExp[prop];
          });
        }
      });
    }
    addDefaultSpecies(RegExp);

    var inverseEpsilon = 1 / Number.EPSILON;
    var roundTiesToEven = function roundTiesToEven(n) {
      // Even though this reduces down to `return n`, it takes advantage of built-in rounding.
      return (n + inverseEpsilon) - inverseEpsilon;
    };
    var BINARY_32_EPSILON = Math.pow(2, -23);
    var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
    var BINARY_32_MIN_VALUE = Math.pow(2, -126);
    var E = Math.E;
    var LOG2E = Math.LOG2E;
    var LOG10E = Math.LOG10E;
    var numberCLZ = Number.prototype.clz;
    delete Number.prototype.clz; // Safari 8 has Number#clz

    var MathShims = {
      acosh: function acosh(value) {
        var x = Number(value);
        if (numberIsNaN(x) || value < 1) { return NaN; }
        if (x === 1) { return 0; }
        if (x === Infinity) { return x; }

        var xInvSquared = 1 / (x * x);
        if (x < 2) {
          return _log1p(x - 1 + (_sqrt(1 - xInvSquared) * x));
        }
        var halfX = x / 2;
        return _log1p(halfX + (_sqrt(1 - xInvSquared) * halfX) - 1) + (1 / LOG2E);
      },

      asinh: function asinh(value) {
        var x = Number(value);
        if (x === 0 || !globalIsFinite(x)) {
          return x;
        }

        var a = _abs(x);
        var aSquared = a * a;
        var s = _sign(x);
        if (a < 1) {
          return s * _log1p(a + (aSquared / (_sqrt(aSquared + 1) + 1)));
        }
        return s * (_log1p((a / 2) + (_sqrt(1 + (1 / aSquared)) * a / 2) - 1) + (1 / LOG2E));
      },

      atanh: function atanh(value) {
        var x = Number(value);

        if (x === 0) { return x; }
        if (x === -1) { return -Infinity; }
        if (x === 1) { return Infinity; }
        if (numberIsNaN(x) || x < -1 || x > 1) {
          return NaN;
        }

        var a = _abs(x);
        return _sign(x) * _log1p(2 * a / (1 - a)) / 2;
      },

      cbrt: function cbrt(value) {
        var x = Number(value);
        if (x === 0) { return x; }
        var negate = x < 0;
        var result;
        if (negate) { x = -x; }
        if (x === Infinity) {
          result = Infinity;
        } else {
          result = _exp(_log(x) / 3);
          // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
          result = ((x / (result * result)) + (2 * result)) / 3;
        }
        return negate ? -result : result;
      },

      clz32: function clz32(value) {
        // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
        var x = Number(value);
        var number = ES.ToUint32(x);
        if (number === 0) {
          return 32;
        }
        return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * LOG2E);
      },

      cosh: function cosh(value) {
        var x = Number(value);
        if (x === 0) { return 1; } // +0 or -0
        if (numberIsNaN(x)) { return NaN; }
        if (!globalIsFinite(x)) { return Infinity; }

        var t = _exp(_abs(x) - 1);
        return (t + (1 / (t * E * E))) * (E / 2);
      },

      expm1: function expm1(value) {
        var x = Number(value);
        if (x === -Infinity) { return -1; }
        if (!globalIsFinite(x) || x === 0) { return x; }
        if (_abs(x) > 0.5) {
          return _exp(x) - 1;
        }
        // A more precise approximation using Taylor series expansion
        // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
        var t = x;
        var sum = 0;
        var n = 1;
        while (sum + t !== sum) {
          sum += t;
          n += 1;
          t *= x / n;
        }
        return sum;
      },

      hypot: function hypot(x, y) {
        var arguments$1 = arguments;

        var result = 0;
        var largest = 0;
        for (var i = 0; i < arguments.length; ++i) {
          var value = _abs(Number(arguments$1[i]));
          if (largest < value) {
            result *= (largest / value) * (largest / value);
            result += 1;
            largest = value;
          } else {
            result += value > 0 ? (value / largest) * (value / largest) : value;
          }
        }
        return largest === Infinity ? Infinity : largest * _sqrt(result);
      },

      log2: function log2(value) {
        return _log(value) * LOG2E;
      },

      log10: function log10(value) {
        return _log(value) * LOG10E;
      },

      log1p: _log1p,

      sign: _sign,

      sinh: function sinh(value) {
        var x = Number(value);
        if (!globalIsFinite(x) || x === 0) { return x; }

        var a = _abs(x);
        if (a < 1) {
          var u = Math.expm1(a);
          return _sign(x) * u * (1 + (1 / (u + 1))) / 2;
        }
        var t = _exp(a - 1);
        return _sign(x) * (t - (1 / (t * E * E))) * (E / 2);
      },

      tanh: function tanh(value) {
        var x = Number(value);
        if (numberIsNaN(x) || x === 0) { return x; }
        // can exit early at +-20 as JS loses precision for true value at this integer
        if (x >= 20) { return 1; }
        if (x <= -20) { return -1; }

        return (Math.expm1(x) - Math.expm1(-x)) / (_exp(x) + _exp(-x));
      },

      trunc: function trunc(value) {
        var x = Number(value);
        return x < 0 ? -_floor(-x) : _floor(x);
      },

      imul: function imul(x, y) {
        // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
        var a = ES.ToUint32(x);
        var b = ES.ToUint32(y);
        var ah = (a >>> 16) & 0xffff;
        var al = a & 0xffff;
        var bh = (b >>> 16) & 0xffff;
        var bl = b & 0xffff;
        // the shift by 0 fixes the sign on the high part
        // the final |0 converts the unsigned value into a signed value
        return (al * bl) + ((((ah * bl) + (al * bh)) << 16) >>> 0) | 0;
      },

      fround: function fround(x) {
        var v = Number(x);
        if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
          return v;
        }
        var sign = _sign(v);
        var abs = _abs(v);
        if (abs < BINARY_32_MIN_VALUE) {
          return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
        }
        // Veltkamp's splitting (?)
        var a = (1 + (BINARY_32_EPSILON / Number.EPSILON)) * abs;
        var result = a - (a - abs);
        if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
          return sign * Infinity;
        }
        return sign * result;
      }
    };

    var withinULPDistance = function withinULPDistance(result, expected, distance) {
      return _abs(1 - (result / expected)) / Number.EPSILON < (distance || 8);
    };

    defineProperties(Math, MathShims);
    // Chrome < 40 sinh returns ∞ for large numbers
    defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(710) === Infinity);
    // Chrome < 40 cosh returns ∞ for large numbers
    defineProperty(Math, 'cosh', MathShims.cosh, Math.cosh(710) === Infinity);
    // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0
    defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
    // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)
    defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
    // Chrome < 54 asinh returns ∞ for large numbers and should not
    defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(1e+300) === Infinity);
    // Chrome < 54 atanh incorrectly returns 0 for large numbers
    defineProperty(Math, 'atanh', MathShims.atanh, Math.atanh(1e-300) === 0);
    // Chrome 40 has an imprecise Math.tanh with very small numbers
    defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
    // Chrome 40 loses Math.acosh precision with high numbers
    defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
    // Chrome < 54 has an inaccurate acosh for EPSILON deltas
    defineProperty(Math, 'acosh', MathShims.acosh, !withinULPDistance(Math.acosh(1 + Number.EPSILON), Math.sqrt(2 * Number.EPSILON)));
    // Firefox 38 on Windows
    defineProperty(Math, 'cbrt', MathShims.cbrt, !withinULPDistance(Math.cbrt(1e-300), 1e-100));
    // node 0.11 has an imprecise Math.sinh with very small numbers
    defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
    // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
    var expm1OfTen = Math.expm1(10);
    defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);

    var origMathRound = Math.round;
    // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12
    var roundHandlesBoundaryConditions = Math.round(0.5 - (Number.EPSILON / 4)) === 0 &&
      Math.round(-0.5 + (Number.EPSILON / 3.99)) === 1;

    // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.
    // This behavior should be governed by "round to nearest, ties to even mode"
    // see http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-type
    // These are the boundary cases where it breaks.
    var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
    var largestPositiveNumberWhereRoundBreaks = (2 * inverseEpsilon) - 1;
    var roundDoesNotIncreaseIntegers = [
      smallestPositiveNumberWhereRoundBreaks,
      largestPositiveNumberWhereRoundBreaks
    ].every(function (num) {
      return Math.round(num) === num;
    });
    defineProperty(Math, 'round', function round(x) {
      var floor = _floor(x);
      var ceil = floor === -1 ? -0 : floor + 1;
      return x - floor < 0.5 ? floor : ceil;
    }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
    Value.preserveToString(Math.round, origMathRound);

    var origImul = Math.imul;
    if (Math.imul(0xffffffff, 5) !== -5) {
      // Safari 6.1, at least, reports "0" for this value
      Math.imul = MathShims.imul;
      Value.preserveToString(Math.imul, origImul);
    }
    if (Math.imul.length !== 2) {
      // Safari 8.0.4 has a length of 1
      // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658
      overrideNative(Math, 'imul', function imul(x, y) {
        return ES.Call(origImul, Math, arguments);
      });
    }

    // Promises
    // Simplest possible implementation; use a 3rd-party library if you
    // want the best possible speed and/or long stack traces.
    var PromiseShim = (function () {
      var setTimeout = globals.setTimeout;
      // some environments don't have setTimeout - no way to shim here.
      if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }

      ES.IsPromise = function (promise) {
        if (!ES.TypeIsObject(promise)) {
          return false;
        }
        if (typeof promise._promise === 'undefined') {
          return false; // uninitialized, or missing our hidden field.
        }
        return true;
      };

      // "PromiseCapability" in the spec is what most promise implementations
      // call a "deferred".
      var PromiseCapability = function (C) {
        if (!ES.IsConstructor(C)) {
          throw new TypeError('Bad promise constructor');
        }
        var capability = this;
        var resolver = function (resolve, reject) {
          if (capability.resolve !== void 0 || capability.reject !== void 0) {
            throw new TypeError('Bad Promise implementation!');
          }
          capability.resolve = resolve;
          capability.reject = reject;
        };
        // Initialize fields to inform optimizers about the object shape.
        capability.resolve = void 0;
        capability.reject = void 0;
        capability.promise = new C(resolver);
        if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
          throw new TypeError('Bad promise constructor');
        }
      };

      // find an appropriate setImmediate-alike
      var makeZeroTimeout;
      /*global window */
      if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
        makeZeroTimeout = function () {
          // from http://dbaron.org/log/20100309-faster-timeouts
          var timeouts = [];
          var messageName = 'zero-timeout-message';
          var setZeroTimeout = function (fn) {
            _push(timeouts, fn);
            window.postMessage(messageName, '*');
          };
          var handleMessage = function (event) {
            if (event.source === window && event.data === messageName) {
              event.stopPropagation();
              if (timeouts.length === 0) { return; }
              var fn = _shift(timeouts);
              fn();
            }
          };
          window.addEventListener('message', handleMessage, true);
          return setZeroTimeout;
        };
      }
      var makePromiseAsap = function () {
        // An efficient task-scheduler based on a pre-existing Promise
        // implementation, which we can use even if we override the
        // global Promise below (in order to workaround bugs)
        // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
        var P = globals.Promise;
        var pr = P && P.resolve && P.resolve();
        return pr && function (task) {
          return pr.then(task);
        };
      };
      /*global process */
      var enqueue = ES.IsCallable(globals.setImmediate) ?
        globals.setImmediate :
        typeof process === 'object' && process.nextTick ? process.nextTick : makePromiseAsap() ||
        (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() : function (task) { setTimeout(task, 0); }); // fallback

      // Constants for Promise implementation
      var PROMISE_IDENTITY = function (x) { return x; };
      var PROMISE_THROWER = function (e) { throw e; };
      var PROMISE_PENDING = 0;
      var PROMISE_FULFILLED = 1;
      var PROMISE_REJECTED = 2;
      // We store fulfill/reject handlers and capabilities in a single array.
      var PROMISE_FULFILL_OFFSET = 0;
      var PROMISE_REJECT_OFFSET = 1;
      var PROMISE_CAPABILITY_OFFSET = 2;
      // This is used in an optimization for chaining promises via then.
      var PROMISE_FAKE_CAPABILITY = {};

      var enqueuePromiseReactionJob = function (handler, capability, argument) {
        enqueue(function () {
          promiseReactionJob(handler, capability, argument);
        });
      };

      var promiseReactionJob = function (handler, promiseCapability, argument) {
        var handlerResult, f;
        if (promiseCapability === PROMISE_FAKE_CAPABILITY) {
          // Fast case, when we don't actually need to chain through to a
          // (real) promiseCapability.
          return handler(argument);
        }
        try {
          handlerResult = handler(argument);
          f = promiseCapability.resolve;
        } catch (e) {
          handlerResult = e;
          f = promiseCapability.reject;
        }
        f(handlerResult);
      };

      var fulfillPromise = function (promise, value) {
        var _promise = promise._promise;
        var length = _promise.reactionLength;
        if (length > 0) {
          enqueuePromiseReactionJob(
            _promise.fulfillReactionHandler0,
            _promise.reactionCapability0,
            value
          );
          _promise.fulfillReactionHandler0 = void 0;
          _promise.rejectReactions0 = void 0;
          _promise.reactionCapability0 = void 0;
          if (length > 1) {
            for (var i = 1, idx = 0; i < length; i++, idx += 3) {
              enqueuePromiseReactionJob(
                _promise[idx + PROMISE_FULFILL_OFFSET],
                _promise[idx + PROMISE_CAPABILITY_OFFSET],
                value
              );
              promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
              promise[idx + PROMISE_REJECT_OFFSET] = void 0;
              promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
            }
          }
        }
        _promise.result = value;
        _promise.state = PROMISE_FULFILLED;
        _promise.reactionLength = 0;
      };

      var rejectPromise = function (promise, reason) {
        var _promise = promise._promise;
        var length = _promise.reactionLength;
        if (length > 0) {
          enqueuePromiseReactionJob(
            _promise.rejectReactionHandler0,
            _promise.reactionCapability0,
            reason
          );
          _promise.fulfillReactionHandler0 = void 0;
          _promise.rejectReactions0 = void 0;
          _promise.reactionCapability0 = void 0;
          if (length > 1) {
            for (var i = 1, idx = 0; i < length; i++, idx += 3) {
              enqueuePromiseReactionJob(
                _promise[idx + PROMISE_REJECT_OFFSET],
                _promise[idx + PROMISE_CAPABILITY_OFFSET],
                reason
              );
              promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
              promise[idx + PROMISE_REJECT_OFFSET] = void 0;
              promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
            }
          }
        }
        _promise.result = reason;
        _promise.state = PROMISE_REJECTED;
        _promise.reactionLength = 0;
      };

      var createResolvingFunctions = function (promise) {
        var alreadyResolved = false;
        var resolve = function (resolution) {
          var then;
          if (alreadyResolved) { return; }
          alreadyResolved = true;
          if (resolution === promise) {
            return rejectPromise(promise, new TypeError('Self resolution'));
          }
          if (!ES.TypeIsObject(resolution)) {
            return fulfillPromise(promise, resolution);
          }
          try {
            then = resolution.then;
          } catch (e) {
            return rejectPromise(promise, e);
          }
          if (!ES.IsCallable(then)) {
            return fulfillPromise(promise, resolution);
          }
          enqueue(function () {
            promiseResolveThenableJob(promise, resolution, then);
          });
        };
        var reject = function (reason) {
          if (alreadyResolved) { return; }
          alreadyResolved = true;
          return rejectPromise(promise, reason);
        };
        return { resolve: resolve, reject: reject };
      };

      var optimizedThen = function (then, thenable, resolve, reject) {
        // Optimization: since we discard the result, we can pass our
        // own then implementation a special hint to let it know it
        // doesn't have to create it.  (The PROMISE_FAKE_CAPABILITY
        // object is local to this implementation and unforgeable outside.)
        if (then === Promise$prototype$then) {
          _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);
        } else {
          _call(then, thenable, resolve, reject);
        }
      };
      var promiseResolveThenableJob = function (promise, thenable, then) {
        var resolvingFunctions = createResolvingFunctions(promise);
        var resolve = resolvingFunctions.resolve;
        var reject = resolvingFunctions.reject;
        try {
          optimizedThen(then, thenable, resolve, reject);
        } catch (e) {
          reject(e);
        }
      };

      var Promise$prototype, Promise$prototype$then;
      var Promise = (function () {
        var PromiseShim = function Promise(resolver) {
          if (!(this instanceof PromiseShim)) {
            throw new TypeError('Constructor Promise requires "new"');
          }
          if (this && this._promise) {
            throw new TypeError('Bad construction');
          }
          // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
          if (!ES.IsCallable(resolver)) {
            throw new TypeError('not a valid resolver');
          }
          var promise = emulateES6construct(this, PromiseShim, Promise$prototype, {
            _promise: {
              result: void 0,
              state: PROMISE_PENDING,
              // The first member of the "reactions" array is inlined here,
              // since most promises only have one reaction.
              // We've also exploded the 'reaction' object to inline the
              // "handler" and "capability" fields, since both fulfill and
              // reject reactions share the same capability.
              reactionLength: 0,
              fulfillReactionHandler0: void 0,
              rejectReactionHandler0: void 0,
              reactionCapability0: void 0
            }
          });
          var resolvingFunctions = createResolvingFunctions(promise);
          var reject = resolvingFunctions.reject;
          try {
            resolver(resolvingFunctions.resolve, reject);
          } catch (e) {
            reject(e);
          }
          return promise;
        };
        return PromiseShim;
      }());
      Promise$prototype = Promise.prototype;

      var _promiseAllResolver = function (index, values, capability, remaining) {
        var alreadyCalled = false;
        return function (x) {
          if (alreadyCalled) { return; }
          alreadyCalled = true;
          values[index] = x;
          if ((--remaining.count) === 0) {
            var resolve = capability.resolve;
            resolve(values); // call w/ this===undefined
          }
        };
      };

      var performPromiseAll = function (iteratorRecord, C, resultCapability) {
        var it = iteratorRecord.iterator;
        var values = [];
        var remaining = { count: 1 };
        var next, nextValue;
        var index = 0;
        while (true) {
          try {
            next = ES.IteratorStep(it);
            if (next === false) {
              iteratorRecord.done = true;
              break;
            }
            nextValue = next.value;
          } catch (e) {
            iteratorRecord.done = true;
            throw e;
          }
          values[index] = void 0;
          var nextPromise = C.resolve(nextValue);
          var resolveElement = _promiseAllResolver(
            index,
            values,
            resultCapability,
            remaining
          );
          remaining.count += 1;
          optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);
          index += 1;
        }
        if ((--remaining.count) === 0) {
          var resolve = resultCapability.resolve;
          resolve(values); // call w/ this===undefined
        }
        return resultCapability.promise;
      };

      var performPromiseRace = function (iteratorRecord, C, resultCapability) {
        var it = iteratorRecord.iterator;
        var next, nextValue, nextPromise;
        while (true) {
          try {
            next = ES.IteratorStep(it);
            if (next === false) {
              // NOTE: If iterable has no items, resulting promise will never
              // resolve; see:
              // https://github.com/domenic/promises-unwrapping/issues/75
              // https://bugs.ecmascript.org/show_bug.cgi?id=2515
              iteratorRecord.done = true;
              break;
            }
            nextValue = next.value;
          } catch (e) {
            iteratorRecord.done = true;
            throw e;
          }
          nextPromise = C.resolve(nextValue);
          optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);
        }
        return resultCapability.promise;
      };

      defineProperties(Promise, {
        all: function all(iterable) {
          var C = this;
          if (!ES.TypeIsObject(C)) {
            throw new TypeError('Promise is not object');
          }
          var capability = new PromiseCapability(C);
          var iterator, iteratorRecord;
          try {
            iterator = ES.GetIterator(iterable);
            iteratorRecord = { iterator: iterator, done: false };
            return performPromiseAll(iteratorRecord, C, capability);
          } catch (e) {
            var exception = e;
            if (iteratorRecord && !iteratorRecord.done) {
              try {
                ES.IteratorClose(iterator, true);
              } catch (ee) {
                exception = ee;
              }
            }
            var reject = capability.reject;
            reject(exception);
            return capability.promise;
          }
        },

        race: function race(iterable) {
          var C = this;
          if (!ES.TypeIsObject(C)) {
            throw new TypeError('Promise is not object');
          }
          var capability = new PromiseCapability(C);
          var iterator, iteratorRecord;
          try {
            iterator = ES.GetIterator(iterable);
            iteratorRecord = { iterator: iterator, done: false };
            return performPromiseRace(iteratorRecord, C, capability);
          } catch (e) {
            var exception = e;
            if (iteratorRecord && !iteratorRecord.done) {
              try {
                ES.IteratorClose(iterator, true);
              } catch (ee) {
                exception = ee;
              }
            }
            var reject = capability.reject;
            reject(exception);
            return capability.promise;
          }
        },

        reject: function reject(reason) {
          var C = this;
          if (!ES.TypeIsObject(C)) {
            throw new TypeError('Bad promise constructor');
          }
          var capability = new PromiseCapability(C);
          var rejectFunc = capability.reject;
          rejectFunc(reason); // call with this===undefined
          return capability.promise;
        },

        resolve: function resolve(v) {
          // See https://esdiscuss.org/topic/fixing-promise-resolve for spec
          var C = this;
          if (!ES.TypeIsObject(C)) {
            throw new TypeError('Bad promise constructor');
          }
          if (ES.IsPromise(v)) {
            var constructor = v.constructor;
            if (constructor === C) {
              return v;
            }
          }
          var capability = new PromiseCapability(C);
          var resolveFunc = capability.resolve;
          resolveFunc(v); // call with this===undefined
          return capability.promise;
        }
      });

      defineProperties(Promise$prototype, {
        'catch': function (onRejected) {
          return this.then(null, onRejected);
        },

        then: function then(onFulfilled, onRejected) {
          var promise = this;
          if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
          var C = ES.SpeciesConstructor(promise, Promise);
          var resultCapability;
          var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;
          if (returnValueIsIgnored && C === Promise) {
            resultCapability = PROMISE_FAKE_CAPABILITY;
          } else {
            resultCapability = new PromiseCapability(C);
          }
          // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)
          // Note that we've split the 'reaction' object into its two
          // components, "capabilities" and "handler"
          // "capabilities" is always equal to `resultCapability`
          var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;
          var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;
          var _promise = promise._promise;
          var value;
          if (_promise.state === PROMISE_PENDING) {
            if (_promise.reactionLength === 0) {
              _promise.fulfillReactionHandler0 = fulfillReactionHandler;
              _promise.rejectReactionHandler0 = rejectReactionHandler;
              _promise.reactionCapability0 = resultCapability;
            } else {
              var idx = 3 * (_promise.reactionLength - 1);
              _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;
              _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;
              _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;
            }
            _promise.reactionLength += 1;
          } else if (_promise.state === PROMISE_FULFILLED) {
            value = _promise.result;
            enqueuePromiseReactionJob(
              fulfillReactionHandler,
              resultCapability,
              value
            );
          } else if (_promise.state === PROMISE_REJECTED) {
            value = _promise.result;
            enqueuePromiseReactionJob(
              rejectReactionHandler,
              resultCapability,
              value
            );
          } else {
            throw new TypeError('unexpected Promise state');
          }
          return resultCapability.promise;
        }
      });
      // This helps the optimizer by ensuring that methods which take
      // capabilities aren't polymorphic.
      PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise);
      Promise$prototype$then = Promise$prototype.then;

      return Promise;
    }());

    // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
    if (globals.Promise) {
      delete globals.Promise.accept;
      delete globals.Promise.defer;
      delete globals.Promise.prototype.chain;
    }

    if (typeof PromiseShim === 'function') {
      // export the Promise constructor.
      defineProperties(globals, { Promise: PromiseShim });
      // In Chrome 33 (and thereabouts) Promise is defined, but the
      // implementation is buggy in a number of ways.  Let's check subclassing
      // support to see if we have a buggy implementation.
      var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
        return S.resolve(42).then(function () {}) instanceof S;
      });
      var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () {
        return globals.Promise.reject(42).then(null, 5).then(null, noop);
      });
      var promiseRequiresObjectContext = throwsError(function () { return globals.Promise.call(3, noop); });
      // Promise.resolve() was errata'ed late in the ES6 process.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742
      //      https://code.google.com/p/v8/issues/detail?id=4161
      // It serves as a proxy for a number of other bugs in early Promise
      // implementations.
      var promiseResolveBroken = (function (Promise) {
        var p = Promise.resolve(5);
        p.constructor = {};
        var p2 = Promise.resolve(p);
        try {
          p2.then(null, noop).then(null, noop); // avoid "uncaught rejection" warnings in console
        } catch (e) {
          return true; // v8 native Promises break here https://code.google.com/p/chromium/issues/detail?id=575314
        }
        return p === p2; // This *should* be false!
      }(globals.Promise));

      // Chrome 46 (probably older too) does not retrieve a thenable's .then synchronously
      var getsThenSynchronously = supportsDescriptors && (function () {
        var count = 0;
        // eslint-disable-next-line getter-return
        var thenable = Object.defineProperty({}, 'then', { get: function () { count += 1; } });
        return count === 1;
      }());

      var BadResolverPromise = function BadResolverPromise(executor) {
        var p = new Promise(executor);
        executor(3, function () {});
        this.then = p.then;
        this.constructor = BadResolverPromise;
      };
      BadResolverPromise.prototype = Promise.prototype;
      BadResolverPromise.all = Promise.all;
      // Chrome Canary 49 (probably older too) has some implementation bugs
      var hasBadResolverPromise = valueOrFalseIfThrows(function () {
        return !!BadResolverPromise.all([1, 2]);
      });

      if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||
          !promiseRequiresObjectContext || promiseResolveBroken ||
          !getsThenSynchronously || hasBadResolverPromise) {
        /* globals Promise: true */
        /* eslint-disable no-undef, no-global-assign */
        Promise = PromiseShim;
        /* eslint-enable no-undef, no-global-assign */
        /* globals Promise: false */
        overrideNative(globals, 'Promise', PromiseShim);
      }
      if (Promise.all.length !== 1) {
        var origAll = Promise.all;
        overrideNative(Promise, 'all', function all(iterable) {
          return ES.Call(origAll, this, arguments);
        });
      }
      if (Promise.race.length !== 1) {
        var origRace = Promise.race;
        overrideNative(Promise, 'race', function race(iterable) {
          return ES.Call(origRace, this, arguments);
        });
      }
      if (Promise.resolve.length !== 1) {
        var origResolve = Promise.resolve;
        overrideNative(Promise, 'resolve', function resolve(x) {
          return ES.Call(origResolve, this, arguments);
        });
      }
      if (Promise.reject.length !== 1) {
        var origReject = Promise.reject;
        overrideNative(Promise, 'reject', function reject(r) {
          return ES.Call(origReject, this, arguments);
        });
      }
      ensureEnumerable(Promise, 'all');
      ensureEnumerable(Promise, 'race');
      ensureEnumerable(Promise, 'resolve');
      ensureEnumerable(Promise, 'reject');
      addDefaultSpecies(Promise);
    }

    // Map and Set require a true ES5 environment
    // Their fast path also requires that the environment preserve
    // property insertion order, which is not guaranteed by the spec.
    var testOrder = function (a) {
      var b = keys(_reduce(a, function (o, k) {
        o[k] = true;
        return o;
      }, {}));
      return a.join(':') === b.join(':');
    };
    var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
    // some engines (eg, Chrome) only preserve insertion order for string keys
    var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

    if (supportsDescriptors) {

      var fastkey = function fastkey(key, skipInsertionOrderCheck) {
        if (!skipInsertionOrderCheck && !preservesInsertionOrder) {
          return null;
        }
        if (isNullOrUndefined(key)) {
          return '^' + ES.ToString(key);
        } else if (typeof key === 'string') {
          return '$' + key;
        } else if (typeof key === 'number') {
          // note that -0 will get coerced to "0" when used as a property key
          if (!preservesNumericInsertionOrder) {
            return 'n' + key;
          }
          return key;
        } else if (typeof key === 'boolean') {
          return 'b' + key;
        }
        return null;
      };

      var emptyObject = function emptyObject() {
        // accomodate some older not-quite-ES5 browsers
        return Object.create ? Object.create(null) : {};
      };

      var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {
        if (isArray(iterable) || Type.string(iterable)) {
          _forEach(iterable, function (entry) {
            if (!ES.TypeIsObject(entry)) {
              throw new TypeError('Iterator value ' + entry + ' is not an entry object');
            }
            map.set(entry[0], entry[1]);
          });
        } else if (iterable instanceof MapConstructor) {
          _call(MapConstructor.prototype.forEach, iterable, function (value, key) {
            map.set(key, value);
          });
        } else {
          var iter, adder;
          if (!isNullOrUndefined(iterable)) {
            adder = map.set;
            if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
            iter = ES.GetIterator(iterable);
          }
          if (typeof iter !== 'undefined') {
            while (true) {
              var next = ES.IteratorStep(iter);
              if (next === false) { break; }
              var nextItem = next.value;
              try {
                if (!ES.TypeIsObject(nextItem)) {
                  throw new TypeError('Iterator value ' + nextItem + ' is not an entry object');
                }
                _call(adder, map, nextItem[0], nextItem[1]);
              } catch (e) {
                ES.IteratorClose(iter, true);
                throw e;
              }
            }
          }
        }
      };
      var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {
        if (isArray(iterable) || Type.string(iterable)) {
          _forEach(iterable, function (value) {
            set.add(value);
          });
        } else if (iterable instanceof SetConstructor) {
          _call(SetConstructor.prototype.forEach, iterable, function (value) {
            set.add(value);
          });
        } else {
          var iter, adder;
          if (!isNullOrUndefined(iterable)) {
            adder = set.add;
            if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
            iter = ES.GetIterator(iterable);
          }
          if (typeof iter !== 'undefined') {
            while (true) {
              var next = ES.IteratorStep(iter);
              if (next === false) { break; }
              var nextValue = next.value;
              try {
                _call(adder, set, nextValue);
              } catch (e) {
                ES.IteratorClose(iter, true);
                throw e;
              }
            }
          }
        }
      };

      var collectionShims = {
        Map: (function () {

          var empty = {};

          var MapEntry = function MapEntry(key, value) {
            this.key = key;
            this.value = value;
            this.next = null;
            this.prev = null;
          };

          MapEntry.prototype.isRemoved = function isRemoved() {
            return this.key === empty;
          };

          var isMap = function isMap(map) {
            return !!map._es6map;
          };

          var requireMapSlot = function requireMapSlot(map, method) {
            if (!ES.TypeIsObject(map) || !isMap(map)) {
              throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(map));
            }
          };

          var MapIterator = function MapIterator(map, kind) {
            requireMapSlot(map, '[[MapIterator]]');
            this.head = map._head;
            this.i = this.head;
            this.kind = kind;
          };

          MapIterator.prototype = {
            isMapIterator: true,
            next: function next() {
              if (!this.isMapIterator) {
                throw new TypeError('Not a MapIterator');
              }
              var i = this.i;
              var kind = this.kind;
              var head = this.head;
              if (typeof this.i === 'undefined') {
                return iteratorResult();
              }
              while (i.isRemoved() && i !== head) {
                // back up off of removed entries
                i = i.prev;
              }
              // advance to next unreturned element.
              var result;
              while (i.next !== head) {
                i = i.next;
                if (!i.isRemoved()) {
                  if (kind === 'key') {
                    result = i.key;
                  } else if (kind === 'value') {
                    result = i.value;
                  } else {
                    result = [i.key, i.value];
                  }
                  this.i = i;
                  return iteratorResult(result);
                }
              }
              // once the iterator is done, it is done forever.
              this.i = void 0;
              return iteratorResult();
            }
          };
          addIterator(MapIterator.prototype);

          var Map$prototype;
          var MapShim = function Map() {
            if (!(this instanceof Map)) {
              throw new TypeError('Constructor Map requires "new"');
            }
            if (this && this._es6map) {
              throw new TypeError('Bad construction');
            }
            var map = emulateES6construct(this, Map, Map$prototype, {
              _es6map: true,
              _head: null,
              _map: OrigMap ? new OrigMap() : null,
              _size: 0,
              _storage: emptyObject()
            });

            var head = new MapEntry(null, null);
            // circular doubly-linked list.
            /* eslint no-multi-assign: 1 */
            head.next = head.prev = head;
            map._head = head;

            // Optionally initialize map from iterable
            if (arguments.length > 0) {
              addIterableToMap(Map, map, arguments[0]);
            }
            return map;
          };
          Map$prototype = MapShim.prototype;

          Value.getter(Map$prototype, 'size', function () {
            if (typeof this._size === 'undefined') {
              throw new TypeError('size method called on incompatible Map');
            }
            return this._size;
          });

          defineProperties(Map$prototype, {
            get: function get(key) {
              requireMapSlot(this, 'get');
              var entry;
              var fkey = fastkey(key, true);
              if (fkey !== null) {
                // fast O(1) path
                entry = this._storage[fkey];
                if (entry) {
                  return entry.value;
                } else {
                  return;
                }
              }
              if (this._map) {
                // fast object key path
                entry = origMapGet.call(this._map, key);
                if (entry) {
                  return entry.value;
                } else {
                  return;
                }
              }
              var head = this._head;
              var i = head;
              while ((i = i.next) !== head) {
                if (ES.SameValueZero(i.key, key)) {
                  return i.value;
                }
              }
            },

            has: function has(key) {
              requireMapSlot(this, 'has');
              var fkey = fastkey(key, true);
              if (fkey !== null) {
                // fast O(1) path
                return typeof this._storage[fkey] !== 'undefined';
              }
              if (this._map) {
                // fast object key path
                return origMapHas.call(this._map, key);
              }
              var head = this._head;
              var i = head;
              while ((i = i.next) !== head) {
                if (ES.SameValueZero(i.key, key)) {
                  return true;
                }
              }
              return false;
            },

            set: function set(key, value) {
              requireMapSlot(this, 'set');
              var head = this._head;
              var i = head;
              var entry;
              var fkey = fastkey(key, true);
              if (fkey !== null) {
                // fast O(1) path
                if (typeof this._storage[fkey] !== 'undefined') {
                  this._storage[fkey].value = value;
                  return this;
                } else {
                  entry = this._storage[fkey] = new MapEntry(key, value); /* eslint no-multi-assign: 1 */
                  i = head.prev;
                  // fall through
                }
              } else if (this._map) {
                // fast object key path
                if (origMapHas.call(this._map, key)) {
                  origMapGet.call(this._map, key).value = value;
                } else {
                  entry = new MapEntry(key, value);
                  origMapSet.call(this._map, key, entry);
                  i = head.prev;
                  // fall through
                }
              }
              while ((i = i.next) !== head) {
                if (ES.SameValueZero(i.key, key)) {
                  i.value = value;
                  return this;
                }
              }
              entry = entry || new MapEntry(key, value);
              if (ES.SameValue(-0, key)) {
                entry.key = +0; // coerce -0 to +0 in entry
              }
              entry.next = this._head;
              entry.prev = this._head.prev;
              entry.prev.next = entry;
              entry.next.prev = entry;
              this._size += 1;
              return this;
            },

            'delete': function (key) {
              requireMapSlot(this, 'delete');
              var head = this._head;
              var i = head;
              var fkey = fastkey(key, true);
              if (fkey !== null) {
                // fast O(1) path
                if (typeof this._storage[fkey] === 'undefined') {
                  return false;
                }
                i = this._storage[fkey].prev;
                delete this._storage[fkey];
                // fall through
              } else if (this._map) {
                // fast object key path
                if (!origMapHas.call(this._map, key)) {
                  return false;
                }
                i = origMapGet.call(this._map, key).prev;
                origMapDelete.call(this._map, key);
                // fall through
              }
              while ((i = i.next) !== head) {
                if (ES.SameValueZero(i.key, key)) {
                  i.key = empty;
                  i.value = empty;
                  i.prev.next = i.next;
                  i.next.prev = i.prev;
                  this._size -= 1;
                  return true;
                }
              }
              return false;
            },

            clear: function clear() {
              /* eslint no-multi-assign: 1 */
              requireMapSlot(this, 'clear');
              this._map = OrigMap ? new OrigMap() : null;
              this._size = 0;
              this._storage = emptyObject();
              var head = this._head;
              var i = head;
              var p = i.next;
              while ((i = p) !== head) {
                i.key = empty;
                i.value = empty;
                p = i.next;
                i.next = i.prev = head;
              }
              head.next = head.prev = head;
            },

            keys: function keys() {
              requireMapSlot(this, 'keys');
              return new MapIterator(this, 'key');
            },

            values: function values() {
              requireMapSlot(this, 'values');
              return new MapIterator(this, 'value');
            },

            entries: function entries() {
              requireMapSlot(this, 'entries');
              return new MapIterator(this, 'key+value');
            },

            forEach: function forEach(callback) {
              requireMapSlot(this, 'forEach');
              var context = arguments.length > 1 ? arguments[1] : null;
              var it = this.entries();
              for (var entry = it.next(); !entry.done; entry = it.next()) {
                if (context) {
                  _call(callback, context, entry.value[1], entry.value[0], this);
                } else {
                  callback(entry.value[1], entry.value[0], this);
                }
              }
            }
          });
          addIterator(Map$prototype, Map$prototype.entries);

          return MapShim;
        }()),

        Set: (function () {
          var isSet = function isSet(set) {
            return set._es6set && typeof set._storage !== 'undefined';
          };
          var requireSetSlot = function requireSetSlot(set, method) {
            if (!ES.TypeIsObject(set) || !isSet(set)) {
              // https://github.com/paulmillr/es6-shim/issues/176
              throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(set));
            }
          };

          // Creating a Map is expensive.  To speed up the common case of
          // Sets containing only string or numeric keys, we use an object
          // as backing storage and lazily create a full Map only when
          // required.
          var Set$prototype;
          var SetShim = function Set() {
            if (!(this instanceof Set)) {
              throw new TypeError('Constructor Set requires "new"');
            }
            if (this && this._es6set) {
              throw new TypeError('Bad construction');
            }
            var set = emulateES6construct(this, Set, Set$prototype, {
              _es6set: true,
              '[[SetData]]': null,
              _storage: emptyObject()
            });
            if (!set._es6set) {
              throw new TypeError('bad set');
            }

            // Optionally initialize Set from iterable
            if (arguments.length > 0) {
              addIterableToSet(Set, set, arguments[0]);
            }
            return set;
          };
          Set$prototype = SetShim.prototype;

          var decodeKey = function (key) {
            var k = key;
            if (k === '^null') {
              return null;
            } else if (k === '^undefined') {
              return void 0;
            } else {
              var first = k.charAt(0);
              if (first === '$') {
                return _strSlice(k, 1);
              } else if (first === 'n') {
                return +_strSlice(k, 1);
              } else if (first === 'b') {
                return k === 'btrue';
              }
            }
            return +k;
          };
          // Switch from the object backing storage to a full Map.
          var ensureMap = function ensureMap(set) {
            if (!set['[[SetData]]']) {
              var m = new collectionShims.Map();
              set['[[SetData]]'] = m;
              _forEach(keys(set._storage), function (key) {
                var k = decodeKey(key);
                m.set(k, k);
              });
              set['[[SetData]]'] = m;
            }
            set._storage = null; // free old backing storage
          };

          Value.getter(SetShim.prototype, 'size', function () {
            requireSetSlot(this, 'size');
            if (this._storage) {
              return keys(this._storage).length;
            }
            ensureMap(this);
            return this['[[SetData]]'].size;
          });

          defineProperties(SetShim.prototype, {
            has: function has(key) {
              requireSetSlot(this, 'has');
              var fkey;
              if (this._storage && (fkey = fastkey(key)) !== null) {
                return !!this._storage[fkey];
              }
              ensureMap(this);
              return this['[[SetData]]'].has(key);
            },

            add: function add(key) {
              requireSetSlot(this, 'add');
              var fkey;
              if (this._storage && (fkey = fastkey(key)) !== null) {
                this._storage[fkey] = true;
                return this;
              }
              ensureMap(this);
              this['[[SetData]]'].set(key, key);
              return this;
            },

            'delete': function (key) {
              requireSetSlot(this, 'delete');
              var fkey;
              if (this._storage && (fkey = fastkey(key)) !== null) {
                var hasFKey = _hasOwnProperty(this._storage, fkey);
                return (delete this._storage[fkey]) && hasFKey;
              }
              ensureMap(this);
              return this['[[SetData]]']['delete'](key);
            },

            clear: function clear() {
              requireSetSlot(this, 'clear');
              if (this._storage) {
                this._storage = emptyObject();
              }
              if (this['[[SetData]]']) {
                this['[[SetData]]'].clear();
              }
            },

            values: function values() {
              requireSetSlot(this, 'values');
              ensureMap(this);
              return new SetIterator(this['[[SetData]]'].values());
            },

            entries: function entries() {
              requireSetSlot(this, 'entries');
              ensureMap(this);
              return new SetIterator(this['[[SetData]]'].entries());
            },

            forEach: function forEach(callback) {
              requireSetSlot(this, 'forEach');
              var context = arguments.length > 1 ? arguments[1] : null;
              var entireSet = this;
              ensureMap(entireSet);
              this['[[SetData]]'].forEach(function (value, key) {
                if (context) {
                  _call(callback, context, key, key, entireSet);
                } else {
                  callback(key, key, entireSet);
                }
              });
            }
          });
          defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);
          addIterator(SetShim.prototype, SetShim.prototype.values);

          var SetIterator = function SetIterator(it) {
            this.it = it;
          };
          SetIterator.prototype = {
            isSetIterator: true,
            next: function next() {
              if (!this.isSetIterator) {
                throw new TypeError('Not a SetIterator');
              }
              return this.it.next();
            }
          };
          addIterator(SetIterator.prototype);

          return SetShim;
        }())
      };

      var isGoogleTranslate = globals.Set && !Set.prototype['delete'] && Set.prototype.remove && Set.prototype.items && Set.prototype.map && Array.isArray(new Set().keys);
      if (isGoogleTranslate) {
        // special-case force removal of wildly invalid Set implementation in Google Translate iframes
        // see https://github.com/paulmillr/es6-shim/issues/438 / https://twitter.com/ljharb/status/849335573114363904
        globals.Set = collectionShims.Set;
      }
      if (globals.Map || globals.Set) {
        // Safari 8, for example, doesn't accept an iterable.
        var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });
        if (!mapAcceptsArguments) {
          globals.Map = function Map() {
            if (!(this instanceof Map)) {
              throw new TypeError('Constructor Map requires "new"');
            }
            var m = new OrigMap();
            if (arguments.length > 0) {
              addIterableToMap(Map, m, arguments[0]);
            }
            delete m.constructor;
            Object.setPrototypeOf(m, globals.Map.prototype);
            return m;
          };
          globals.Map.prototype = create(OrigMap.prototype);
          defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
          Value.preserveToString(globals.Map, OrigMap);
        }
        var testMap = new Map();
        var mapUsesSameValueZero = (function () {
          // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4
          var m = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);
          m.set(-0, m);
          return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);
        }());
        var mapSupportsChaining = testMap.set(1, 2) === testMap;
        if (!mapUsesSameValueZero || !mapSupportsChaining) {
          overrideNative(Map.prototype, 'set', function set(k, v) {
            _call(origMapSet, this, k === 0 ? 0 : k, v);
            return this;
          });
        }
        if (!mapUsesSameValueZero) {
          defineProperties(Map.prototype, {
            get: function get(k) {
              return _call(origMapGet, this, k === 0 ? 0 : k);
            },
            has: function has(k) {
              return _call(origMapHas, this, k === 0 ? 0 : k);
            }
          }, true);
          Value.preserveToString(Map.prototype.get, origMapGet);
          Value.preserveToString(Map.prototype.has, origMapHas);
        }
        var testSet = new Set();
        var setUsesSameValueZero = Set.prototype['delete'] && Set.prototype.add && Set.prototype.has && (function (s) {
          s['delete'](0);
          s.add(-0);
          return !s.has(0);
        }(testSet));
        var setSupportsChaining = testSet.add(1) === testSet;
        if (!setUsesSameValueZero || !setSupportsChaining) {
          var origSetAdd = Set.prototype.add;
          Set.prototype.add = function add(v) {
            _call(origSetAdd, this, v === 0 ? 0 : v);
            return this;
          };
          Value.preserveToString(Set.prototype.add, origSetAdd);
        }
        if (!setUsesSameValueZero) {
          var origSetHas = Set.prototype.has;
          Set.prototype.has = function has(v) {
            return _call(origSetHas, this, v === 0 ? 0 : v);
          };
          Value.preserveToString(Set.prototype.has, origSetHas);
          var origSetDel = Set.prototype['delete'];
          Set.prototype['delete'] = function SetDelete(v) {
            return _call(origSetDel, this, v === 0 ? 0 : v);
          };
          Value.preserveToString(Set.prototype['delete'], origSetDel);
        }
        var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {
          var m = new M([]);
          // Firefox 32 is ok with the instantiating the subclass but will
          // throw when the map is used.
          m.set(42, 42);
          return m instanceof M;
        });
        // without Object.setPrototypeOf, subclassing is not possible
        var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing;
        var mapRequiresNew = (function () {
          try {
            return !(globals.Map() instanceof globals.Map);
          } catch (e) {
            return e instanceof TypeError;
          }
        }());
        if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
          globals.Map = function Map() {
            if (!(this instanceof Map)) {
              throw new TypeError('Constructor Map requires "new"');
            }
            var m = new OrigMap();
            if (arguments.length > 0) {
              addIterableToMap(Map, m, arguments[0]);
            }
            delete m.constructor;
            Object.setPrototypeOf(m, Map.prototype);
            return m;
          };
          globals.Map.prototype = OrigMap.prototype;
          defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
          Value.preserveToString(globals.Map, OrigMap);
        }
        var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {
          var s = new S([]);
          s.add(42, 42);
          return s instanceof S;
        });
        // without Object.setPrototypeOf, subclassing is not possible
        var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing;
        var setRequiresNew = (function () {
          try {
            return !(globals.Set() instanceof globals.Set);
          } catch (e) {
            return e instanceof TypeError;
          }
        }());
        if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
          var OrigSet = globals.Set;
          globals.Set = function Set() {
            if (!(this instanceof Set)) {
              throw new TypeError('Constructor Set requires "new"');
            }
            var s = new OrigSet();
            if (arguments.length > 0) {
              addIterableToSet(Set, s, arguments[0]);
            }
            delete s.constructor;
            Object.setPrototypeOf(s, Set.prototype);
            return s;
          };
          globals.Set.prototype = OrigSet.prototype;
          defineProperty(globals.Set.prototype, 'constructor', globals.Set, true);
          Value.preserveToString(globals.Set, OrigSet);
        }
        var newMap = new globals.Map();
        var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {
          return newMap.keys().next().done;
        });
        /*
          - In Firefox < 23, Map#size is a function.
          - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
          - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
          - In Firefox 24, Map and Set do not implement forEach
          - In Firefox 25 at least, Map and Set are callable without "new"
        */
        if (
          typeof globals.Map.prototype.clear !== 'function' ||
          new globals.Set().size !== 0 ||
          newMap.size !== 0 ||
          typeof globals.Map.prototype.keys !== 'function' ||
          typeof globals.Set.prototype.keys !== 'function' ||
          typeof globals.Map.prototype.forEach !== 'function' ||
          typeof globals.Set.prototype.forEach !== 'function' ||
          isCallableWithoutNew(globals.Map) ||
          isCallableWithoutNew(globals.Set) ||
          typeof newMap.keys().next !== 'function' || // Safari 8
          mapIterationThrowsStopIterator || // Firefox 25
          !mapSupportsSubclassing
        ) {
          defineProperties(globals, {
            Map: collectionShims.Map,
            Set: collectionShims.Set
          }, true);
        }

        if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
          // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190
          defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
        }

        // Shim incomplete iterator implementations.
        addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
        addIterator(Object.getPrototypeOf((new globals.Set()).keys()));

        if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {
          // Microsoft Edge v0.11.10074.0 is missing a name on Set#has
          var anonymousSetHas = globals.Set.prototype.has;
          overrideNative(globals.Set.prototype, 'has', function has(key) {
            return _call(anonymousSetHas, this, key);
          });
        }
      }
      defineProperties(globals, collectionShims);
      addDefaultSpecies(globals.Map);
      addDefaultSpecies(globals.Set);
    }

    var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
      if (!ES.TypeIsObject(target)) {
        throw new TypeError('target must be an object');
      }
    };

    // Some Reflect methods are basically the same as
    // those on the Object global, except that a TypeError is thrown if
    // target isn't an object. As well as returning a boolean indicating
    // the success of the operation.
    var ReflectShims = {
      // Apply method in a functional form.
      apply: function apply() {
        return ES.Call(ES.Call, null, arguments);
      },

      // New operator in a functional form.
      construct: function construct(constructor, args) {
        if (!ES.IsConstructor(constructor)) {
          throw new TypeError('First argument must be a constructor.');
        }
        var newTarget = arguments.length > 2 ? arguments[2] : constructor;
        if (!ES.IsConstructor(newTarget)) {
          throw new TypeError('new.target must be a constructor.');
        }
        return ES.Construct(constructor, args, newTarget, 'internal');
      },

      // When deleting a non-existent or configurable property,
      // true is returned.
      // When attempting to delete a non-configurable property,
      // it will return false.
      deleteProperty: function deleteProperty(target, key) {
        throwUnlessTargetIsObject(target);
        if (supportsDescriptors) {
          var desc = Object.getOwnPropertyDescriptor(target, key);

          if (desc && !desc.configurable) {
            return false;
          }
        }

        // Will return true.
        return delete target[key];
      },

      has: function has(target, key) {
        throwUnlessTargetIsObject(target);
        return key in target;
      }
    };

    if (Object.getOwnPropertyNames) {
      Object.assign(ReflectShims, {
        // Basically the result of calling the internal [[OwnPropertyKeys]].
        // Concatenating propertyNames and propertySymbols should do the trick.
        // This should continue to work together with a Symbol shim
        // which overrides Object.getOwnPropertyNames and implements
        // Object.getOwnPropertySymbols.
        ownKeys: function ownKeys(target) {
          throwUnlessTargetIsObject(target);
          var keys = Object.getOwnPropertyNames(target);

          if (ES.IsCallable(Object.getOwnPropertySymbols)) {
            _pushApply(keys, Object.getOwnPropertySymbols(target));
          }

          return keys;
        }
      });
    }

    var callAndCatchException = function ConvertExceptionToBoolean(func) {
      return !throwsError(func);
    };

    if (Object.preventExtensions) {
      Object.assign(ReflectShims, {
        isExtensible: function isExtensible(target) {
          throwUnlessTargetIsObject(target);
          return Object.isExtensible(target);
        },
        preventExtensions: function preventExtensions(target) {
          throwUnlessTargetIsObject(target);
          return callAndCatchException(function () {
            return Object.preventExtensions(target);
          });
        }
      });
    }

    if (supportsDescriptors) {
      var internalGet = function get(target, key, receiver) {
        var desc = Object.getOwnPropertyDescriptor(target, key);

        if (!desc) {
          var parent = Object.getPrototypeOf(target);

          if (parent === null) {
            return void 0;
          }

          return internalGet(parent, key, receiver);
        }

        if ('value' in desc) {
          return desc.value;
        }

        if (desc.get) {
          return ES.Call(desc.get, receiver);
        }

        return void 0;
      };

      var internalSet = function set(target, key, value, receiver) {
        var desc = Object.getOwnPropertyDescriptor(target, key);

        if (!desc) {
          var parent = Object.getPrototypeOf(target);

          if (parent !== null) {
            return internalSet(parent, key, value, receiver);
          }

          desc = {
            value: void 0,
            writable: true,
            enumerable: true,
            configurable: true
          };
        }

        if ('value' in desc) {
          if (!desc.writable) {
            return false;
          }

          if (!ES.TypeIsObject(receiver)) {
            return false;
          }

          var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

          if (existingDesc) {
            return Reflect.defineProperty(receiver, key, {
              value: value
            });
          } else {
            return Reflect.defineProperty(receiver, key, {
              value: value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        }

        if (desc.set) {
          _call(desc.set, receiver, value);
          return true;
        }

        return false;
      };

      Object.assign(ReflectShims, {
        defineProperty: function defineProperty(target, propertyKey, attributes) {
          throwUnlessTargetIsObject(target);
          return callAndCatchException(function () {
            return Object.defineProperty(target, propertyKey, attributes);
          });
        },

        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
          throwUnlessTargetIsObject(target);
          return Object.getOwnPropertyDescriptor(target, propertyKey);
        },

        // Syntax in a functional form.
        get: function get(target, key) {
          throwUnlessTargetIsObject(target);
          var receiver = arguments.length > 2 ? arguments[2] : target;

          return internalGet(target, key, receiver);
        },

        set: function set(target, key, value) {
          throwUnlessTargetIsObject(target);
          var receiver = arguments.length > 3 ? arguments[3] : target;

          return internalSet(target, key, value, receiver);
        }
      });
    }

    if (Object.getPrototypeOf) {
      var objectDotGetPrototypeOf = Object.getPrototypeOf;
      ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
        throwUnlessTargetIsObject(target);
        return objectDotGetPrototypeOf(target);
      };
    }

    if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
      var willCreateCircularPrototype = function (object, lastProto) {
        var proto = lastProto;
        while (proto) {
          if (object === proto) {
            return true;
          }
          proto = ReflectShims.getPrototypeOf(proto);
        }
        return false;
      };

      Object.assign(ReflectShims, {
        // Sets the prototype of the given object.
        // Returns true on success, otherwise false.
        setPrototypeOf: function setPrototypeOf(object, proto) {
          throwUnlessTargetIsObject(object);
          if (proto !== null && !ES.TypeIsObject(proto)) {
            throw new TypeError('proto must be an object or null');
          }

          // If they already are the same, we're done.
          if (proto === Reflect.getPrototypeOf(object)) {
            return true;
          }

          // Cannot alter prototype if object not extensible.
          if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
            return false;
          }

          // Ensure that we do not create a circular prototype chain.
          if (willCreateCircularPrototype(object, proto)) {
            return false;
          }

          Object.setPrototypeOf(object, proto);

          return true;
        }
      });
    }
    var defineOrOverrideReflectProperty = function (key, shim) {
      if (!ES.IsCallable(globals.Reflect[key])) {
        defineProperty(globals.Reflect, key, shim);
      } else {
        var acceptsPrimitives = valueOrFalseIfThrows(function () {
          globals.Reflect[key](1);
          globals.Reflect[key](NaN);
          globals.Reflect[key](true);
          return true;
        });
        if (acceptsPrimitives) {
          overrideNative(globals.Reflect, key, shim);
        }
      }
    };
    Object.keys(ReflectShims).forEach(function (key) {
      defineOrOverrideReflectProperty(key, ReflectShims[key]);
    });
    var originalReflectGetProto = globals.Reflect.getPrototypeOf;
    if (functionsHaveNames && originalReflectGetProto && originalReflectGetProto.name !== 'getPrototypeOf') {
      overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {
        return _call(originalReflectGetProto, globals.Reflect, target);
      });
    }
    if (globals.Reflect.setPrototypeOf) {
      if (valueOrFalseIfThrows(function () {
        globals.Reflect.setPrototypeOf(1, {});
        return true;
      })) {
        overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);
      }
    }
    if (globals.Reflect.defineProperty) {
      if (!valueOrFalseIfThrows(function () {
        var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });
        // "extensible" fails on Edge 0.12
        var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});
        return basic && extensible;
      })) {
        overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);
      }
    }
    if (globals.Reflect.construct) {
      if (!valueOrFalseIfThrows(function () {
        var F = function F() {};
        return globals.Reflect.construct(function () {}, [], F) instanceof F;
      })) {
        overrideNative(globals.Reflect, 'construct', ReflectShims.construct);
      }
    }

    if (String(new Date(NaN)) !== 'Invalid Date') {
      var dateToString = Date.prototype.toString;
      var shimmedDateToString = function toString() {
        var valueOf = +this;
        if (valueOf !== valueOf) {
          return 'Invalid Date';
        }
        return ES.Call(dateToString, this);
      };
      overrideNative(Date.prototype, 'toString', shimmedDateToString);
    }

    // Annex B HTML methods
    // http://www.ecma-international.org/ecma-262/6.0/#sec-additional-properties-of-the-string.prototype-object
    var stringHTMLshims = {
      anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
      big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
      blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
      bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
      fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
      fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
      fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
      italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
      link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
      small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
      strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
      sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
      sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
    };
    _forEach(Object.keys(stringHTMLshims), function (key) {
      var method = String.prototype[key];
      var shouldOverwrite = false;
      if (ES.IsCallable(method)) {
        var output = _call(method, '', ' " ');
        var quotesCount = _concat([], output.match(/"/g)).length;
        shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
      } else {
        shouldOverwrite = true;
      }
      if (shouldOverwrite) {
        overrideNative(String.prototype, key, stringHTMLshims[key]);
      }
    });

    var JSONstringifiesSymbols = (function () {
      // Microsoft Edge v0.12 stringifies Symbols incorrectly
      if (!hasSymbols) { return false; } // Symbols are not supported
      var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;
      if (!stringify) { return false; } // JSON.stringify is not supported
      if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`
      if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`
      var obj = { a: Symbol() };
      obj[Symbol()] = true;
      if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted
      return false;
    }());
    var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {
      // Chrome 45 throws on stringifying object symbols
      if (!hasSymbols) { return true; } // Symbols are not supported
      return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';
    });
    if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
      var origStringify = JSON.stringify;
      overrideNative(JSON, 'stringify', function stringify(value) {
        if (typeof value === 'symbol') { return; }
        var replacer;
        if (arguments.length > 1) {
          replacer = arguments[1];
        }
        var args = [value];
        if (!isArray(replacer)) {
          var replaceFn = ES.IsCallable(replacer) ? replacer : null;
          var wrappedReplacer = function (key, val) {
            var parsedValue = replaceFn ? _call(replaceFn, this, key, val) : val;
            if (typeof parsedValue !== 'symbol') {
              if (Type.symbol(parsedValue)) {
                return assignTo({})(parsedValue);
              } else {
                return parsedValue;
              }
            }
          };
          args.push(wrappedReplacer);
        } else {
          // create wrapped replacer that handles an array replacer?
          args.push(replacer);
        }
        if (arguments.length > 2) {
          args.push(arguments[2]);
        }
        return origStringify.apply(this, args);
      });
    }

    return globals;
  }));
  });

  var validTypes = { object: true, symbol: true };

  var isImplemented = function () {
  	var symbol;
  	if (typeof Symbol !== 'function') { return false; }
  	symbol = Symbol('test symbol');
  	try { String(symbol); } catch (e) { return false; }

  	// Return 'true' also for polyfills
  	if (!validTypes[typeof Symbol.iterator]) { return false; }
  	if (!validTypes[typeof Symbol.toPrimitive]) { return false; }
  	if (!validTypes[typeof Symbol.toStringTag]) { return false; }

  	return true;
  };

  var global$1 = (function () {
  	if (this) { return this; }

  	// Unexpected strict mode (may happen if e.g. bundled into ESM module) be nice

  	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
  	// In all ES5 engines global object inherits from Object.prototype
  	// (if you approached one that doesn't please report)
  	Object.defineProperty(Object.prototype, "__global__", {
  		get: function () { return this; },
  		configurable: true
  	});
  	try { return __global__; }
  	finally { delete Object.prototype.__global__; }
  })();

  // ES3 safe
  var _undefined = void 0;

  var is = function (value) { return value !== _undefined && value !== null; };

  // prettier-ignore
  var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

  var is$1 = function (value) {
  	if (!is(value)) { return false; }
  	return hasOwnProperty.call(possibleTypes, typeof value);
  };

  var is$2 = function (value) {
  	if (!is$1(value)) { return false; }
  	try {
  		if (!value.constructor) { return false; }
  		return value.constructor.prototype === value;
  	} catch (error) {
  		return false;
  	}
  };

  var is$3 = function (value) {
  	if (typeof value !== "function") { return false; }

  	if (!hasOwnProperty.call(value, "length")) { return false; }

  	try {
  		if (typeof value.length !== "number") { return false; }
  		if (typeof value.call !== "function") { return false; }
  		if (typeof value.apply !== "function") { return false; }
  	} catch (error) {
  		return false;
  	}

  	return !is$2(value);
  };

  var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;

  var is$4 = function (value) {
  	if (!is$3(value)) { return false; }
  	if (classRe.test(functionToString.call(value))) { return false; }
  	return true;
  };

  var isImplemented$1 = function () {
  	var assign = Object.assign, obj;
  	if (typeof assign !== "function") { return false; }
  	obj = { foo: "raz" };
  	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
  	return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
  };

  var isImplemented$2 = function () {
  	try {
  		Object.keys("primitive");
  		return true;
  	} catch (e) {
  		return false;
  	}
  };

  // eslint-disable-next-line no-empty-function
  var noop$2 = function () {};

  var _undefined$1 = noop$2(); // Support ES3 engines

  var isValue = function (val) {
   return (val !== _undefined$1) && (val !== null);
  };

  var keys = Object.keys;

  var shim = function (object) { return keys(isValue(object) ? Object(object) : object); };

  var keys$1 = isImplemented$2() ? Object.keys : shim;

  var validValue = function (value) {
  	if (!isValue(value)) { throw new TypeError("Cannot use null or undefined"); }
  	return value;
  };

  var max   = Math.max;

  var shim$1 = function (dest, src /*, …srcn*/) {
  	var arguments$1 = arguments;

  	var error, i, length = max(arguments.length, 2), assign;
  	dest = Object(validValue(dest));
  	assign = function (key) {
  		try {
  			dest[key] = src[key];
  		} catch (e) {
  			if (!error) { error = e; }
  		}
  	};
  	for (i = 1; i < length; ++i) {
  		src = arguments$1[i];
  		keys$1(src).forEach(assign);
  	}
  	if (error !== undefined) { throw error; }
  	return dest;
  };

  var assign = isImplemented$1()
  	? Object.assign
  	: shim$1;

  var forEach = Array.prototype.forEach, create$1 = Object.create;

  var process$1 = function (src, obj) {
  	var key;
  	for (key in src) { obj[key] = src[key]; }
  };

  // eslint-disable-next-line no-unused-vars
  var normalizeOptions = function (opts1 /*, …options*/) {
  	var result = create$1(null);
  	forEach.call(arguments, function (options) {
  		if (!isValue(options)) { return; }
  		process$1(Object(options), result);
  	});
  	return result;
  };

  var str = "razdwatrzy";

  var isImplemented$3 = function () {
  	if (typeof str.contains !== "function") { return false; }
  	return (str.contains("dwa") === true) && (str.contains("foo") === false);
  };

  var indexOf = String.prototype.indexOf;

  var shim$2 = function (searchString/*, position*/) {
  	return indexOf.call(this, searchString, arguments[1]) > -1;
  };

  var contains = isImplemented$3()
  	? String.prototype.contains
  	: shim$2;

  var d_1 = createCommonjsModule(function (module) {



  var d = (module.exports = function (dscr, value/*, options*/) {
  	var c, e, w, options, desc;
  	if (arguments.length < 2 || typeof dscr !== "string") {
  		options = value;
  		value = dscr;
  		dscr = null;
  	} else {
  		options = arguments[2];
  	}
  	if (is(dscr)) {
  		c = contains.call(dscr, "c");
  		e = contains.call(dscr, "e");
  		w = contains.call(dscr, "w");
  	} else {
  		c = w = true;
  		e = false;
  	}

  	desc = { value: value, configurable: c, enumerable: e, writable: w };
  	return !options ? desc : assign(normalizeOptions(options), desc);
  });

  d.gs = function (dscr, get, set/*, options*/) {
  	var c, e, options, desc;
  	if (typeof dscr !== "string") {
  		options = set;
  		set = get;
  		get = dscr;
  		dscr = null;
  	} else {
  		options = arguments[3];
  	}
  	if (!is(get)) {
  		get = undefined;
  	} else if (!is$4(get)) {
  		options = get;
  		get = set = undefined;
  	} else if (!is(set)) {
  		set = undefined;
  	} else if (!is$4(set)) {
  		options = set;
  		set = undefined;
  	}
  	if (is(dscr)) {
  		c = contains.call(dscr, "c");
  		e = contains.call(dscr, "e");
  	} else {
  		c = true;
  		e = false;
  	}

  	desc = { get: get, set: set, configurable: c, enumerable: e };
  	return !options ? desc : assign(normalizeOptions(options), desc);
  };
  });

  var isSymbol$1 = function (x) {
  	if (!x) { return false; }
  	if (typeof x === 'symbol') { return true; }
  	if (!x.constructor) { return false; }
  	if (x.constructor.name !== 'Symbol') { return false; }
  	return (x[x.constructor.toStringTag] === 'Symbol');
  };

  var validateSymbol = function (value) {
  	if (!isSymbol$1(value)) { throw new TypeError(value + " is not a symbol"); }
  	return value;
  };

  var create$2 = Object.create, defineProperties = Object.defineProperties
    , defineProperty = Object.defineProperty, objPrototype = Object.prototype
    , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$2(null)
    , isNativeSafe;

  if (typeof Symbol === 'function') {
  	NativeSymbol = Symbol;
  	try {
  		String(NativeSymbol());
  		isNativeSafe = true;
  	} catch (ignore) {}
  }

  var generateName = (function () {
  	var created = create$2(null);
  	return function (desc) {
  		var postfix = 0, name, ie11BugWorkaround;
  		while (created[desc + (postfix || '')]) { ++postfix; }
  		desc += (postfix || '');
  		created[desc] = true;
  		name = '@@' + desc;
  		defineProperty(objPrototype, name, d_1.gs(null, function (value) {
  			// For IE11 issue see:
  			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
  			//    ie11-broken-getters-on-dom-objects
  			// https://github.com/medikoo/es6-symbol/issues/12
  			if (ie11BugWorkaround) { return; }
  			ie11BugWorkaround = true;
  			defineProperty(this, name, d_1(value));
  			ie11BugWorkaround = false;
  		}));
  		return name;
  	};
  }());

  // Internal constructor (not one exposed) for creating Symbol instances.
  // This one is used to ensure that `someSymbol instanceof Symbol` always return false
  HiddenSymbol = function Symbol(description) {
  	if (this instanceof HiddenSymbol) { throw new TypeError('Symbol is not a constructor'); }
  	return SymbolPolyfill(description);
  };

  // Exposed `Symbol` constructor
  // (returns instances of HiddenSymbol)
  var polyfill = SymbolPolyfill = function Symbol(description) {
  	var symbol;
  	if (this instanceof Symbol) { throw new TypeError('Symbol is not a constructor'); }
  	if (isNativeSafe) { return NativeSymbol(description); }
  	symbol = create$2(HiddenSymbol.prototype);
  	description = (description === undefined ? '' : String(description));
  	return defineProperties(symbol, {
  		__description__: d_1('', description),
  		__name__: d_1('', generateName(description))
  	});
  };
  defineProperties(SymbolPolyfill, {
  	for: d_1(function (key) {
  		if (globalSymbols[key]) { return globalSymbols[key]; }
  		return (globalSymbols[key] = SymbolPolyfill(String(key)));
  	}),
  	keyFor: d_1(function (s) {
  		var key;
  		validateSymbol(s);
  		for (key in globalSymbols) { if (globalSymbols[key] === s) { return key; } }
  	}),

  	// To ensure proper interoperability with other native functions (e.g. Array.from)
  	// fallback to eventual native implementation of given symbol
  	hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
  	isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
  		SymbolPolyfill('isConcatSpreadable')),
  	iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
  	match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
  	replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
  	search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
  	species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
  	split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
  	toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
  	toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
  	unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
  });

  // Internal tweaks for real symbol producer
  defineProperties(HiddenSymbol.prototype, {
  	constructor: d_1(SymbolPolyfill),
  	toString: d_1('', function () { return this.__name__; })
  });

  // Proper implementation of methods exposed on Symbol.prototype
  // They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
  defineProperties(SymbolPolyfill.prototype, {
  	toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
  	valueOf: d_1(function () { return validateSymbol(this); })
  });
  defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
  	var symbol = validateSymbol(this);
  	if (typeof symbol === 'symbol') { return symbol; }
  	return symbol.toString();
  }));
  defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

  // Proper implementaton of toPrimitive and toStringTag for returned symbol instances
  defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
  	d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

  // Note: It's important to define `toPrimitive` as last one, as some implementations
  // implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
  // And that may invoke error in definition flow:
  // See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
  defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
  	d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

  if (!isImplemented()) {
  	Object.defineProperty(global$1, 'Symbol',
  		{ value: polyfill, configurable: true, enumerable: false,
  			writable: true });
  }

  var toStr = Object.prototype.toString;

  var isArguments = function isArguments(value) {
  	var str = toStr.call(value);
  	var isArgs = str === '[object Arguments]';
  	if (!isArgs) {
  		isArgs = str !== '[object Array]' &&
  			value !== null &&
  			typeof value === 'object' &&
  			typeof value.length === 'number' &&
  			value.length >= 0 &&
  			toStr.call(value.callee) === '[object Function]';
  	}
  	return isArgs;
  };

  var keysShim;
  if (!Object.keys) {
  	// modified from https://github.com/es-shims/es5-shim
  	var has = Object.prototype.hasOwnProperty;
  	var toStr$1 = Object.prototype.toString;
  	var isArgs = isArguments; // eslint-disable-line global-require
  	var isEnumerable = Object.prototype.propertyIsEnumerable;
  	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
  	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  	var dontEnums = [
  		'toString',
  		'toLocaleString',
  		'valueOf',
  		'hasOwnProperty',
  		'isPrototypeOf',
  		'propertyIsEnumerable',
  		'constructor'
  	];
  	var equalsConstructorPrototype = function (o) {
  		var ctor = o.constructor;
  		return ctor && ctor.prototype === o;
  	};
  	var excludedKeys = {
  		$applicationCache: true,
  		$console: true,
  		$external: true,
  		$frame: true,
  		$frameElement: true,
  		$frames: true,
  		$innerHeight: true,
  		$innerWidth: true,
  		$onmozfullscreenchange: true,
  		$onmozfullscreenerror: true,
  		$outerHeight: true,
  		$outerWidth: true,
  		$pageXOffset: true,
  		$pageYOffset: true,
  		$parent: true,
  		$scrollLeft: true,
  		$scrollTop: true,
  		$scrollX: true,
  		$scrollY: true,
  		$self: true,
  		$webkitIndexedDB: true,
  		$webkitStorageInfo: true,
  		$window: true
  	};
  	var hasAutomationEqualityBug = (function () {
  		/* global window */
  		if (typeof window === 'undefined') { return false; }
  		for (var k in window) {
  			try {
  				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
  					try {
  						equalsConstructorPrototype(window[k]);
  					} catch (e) {
  						return true;
  					}
  				}
  			} catch (e) {
  				return true;
  			}
  		}
  		return false;
  	}());
  	var equalsConstructorPrototypeIfNotBuggy = function (o) {
  		/* global window */
  		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
  			return equalsConstructorPrototype(o);
  		}
  		try {
  			return equalsConstructorPrototype(o);
  		} catch (e) {
  			return false;
  		}
  	};

  	keysShim = function keys(object) {
  		var isObject = object !== null && typeof object === 'object';
  		var isFunction = toStr$1.call(object) === '[object Function]';
  		var isArguments = isArgs(object);
  		var isString = isObject && toStr$1.call(object) === '[object String]';
  		var theKeys = [];

  		if (!isObject && !isFunction && !isArguments) {
  			throw new TypeError('Object.keys called on a non-object');
  		}

  		var skipProto = hasProtoEnumBug && isFunction;
  		if (isString && object.length > 0 && !has.call(object, 0)) {
  			for (var i = 0; i < object.length; ++i) {
  				theKeys.push(String(i));
  			}
  		}

  		if (isArguments && object.length > 0) {
  			for (var j = 0; j < object.length; ++j) {
  				theKeys.push(String(j));
  			}
  		} else {
  			for (var name in object) {
  				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
  					theKeys.push(String(name));
  				}
  			}
  		}

  		if (hasDontEnumBug) {
  			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

  			for (var k = 0; k < dontEnums.length; ++k) {
  				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
  					theKeys.push(dontEnums[k]);
  				}
  			}
  		}
  		return theKeys;
  	};
  }
  var implementation = keysShim;

  var slice = Array.prototype.slice;


  var origKeys = Object.keys;
  var keysShim$1 = origKeys ? function keys(o) { return origKeys(o); } : implementation;

  var originalKeys = Object.keys;

  keysShim$1.shim = function shimObjectKeys() {
  	if (Object.keys) {
  		var keysWorksWithArguments = (function () {
  			// Safari 5.0 bug
  			var args = Object.keys(arguments);
  			return args && args.length === arguments.length;
  		}(1, 2));
  		if (!keysWorksWithArguments) {
  			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
  				if (isArguments(object)) {
  					return originalKeys(slice.call(object));
  				}
  				return originalKeys(object);
  			};
  		}
  	} else {
  		Object.keys = keysShim$1;
  	}
  	return Object.keys || keysShim$1;
  };

  var objectKeys = keysShim$1;

  var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

  var toStr$2 = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;

  var isFunction$1 = function (fn) {
  	return typeof fn === 'function' && toStr$2.call(fn) === '[object Function]';
  };

  var arePropertyDescriptorsSupported = function () {
  	var obj = {};
  	try {
  		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
  		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
  		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
  			return false;
  		}
  		return obj.x === obj;
  	} catch (e) { /* this is IE 8. */
  		return false;
  	}
  };
  var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

  var defineProperty$1 = function (object, name, value, predicate) {
  	if (name in object && (!isFunction$1(predicate) || !predicate())) {
  		return;
  	}
  	if (supportsDescriptors) {
  		origDefineProperty(object, name, {
  			configurable: true,
  			enumerable: false,
  			value: value,
  			writable: true
  		});
  	} else {
  		object[name] = value;
  	}
  };

  var defineProperties$1 = function (object, map) {
  	var predicates = arguments.length > 2 ? arguments[2] : {};
  	var props = objectKeys(map);
  	if (hasSymbols) {
  		props = concat.call(props, Object.getOwnPropertySymbols(map));
  	}
  	for (var i = 0; i < props.length; i += 1) {
  		defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
  	}
  };

  defineProperties$1.supportsDescriptors = !!supportsDescriptors;

  var defineProperties_1 = defineProperties$1;

  /* eslint no-invalid-this: 1 */

  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
  var slice$1 = Array.prototype.slice;
  var toStr$3 = Object.prototype.toString;
  var funcType = '[object Function]';

  var implementation$1 = function bind(that) {
      var target = this;
      if (typeof target !== 'function' || toStr$3.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice$1.call(arguments, 1);

      var bound;
      var binder = function () {
          if (this instanceof bound) {
              var result = target.apply(
                  this,
                  args.concat(slice$1.call(arguments))
              );
              if (Object(result) === result) {
                  return result;
              }
              return this;
          } else {
              return target.apply(
                  that,
                  args.concat(slice$1.call(arguments))
              );
          }
      };

      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
          boundArgs.push('$' + i);
      }

      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

      if (target.prototype) {
          var Empty = function Empty() {};
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
      }

      return bound;
  };

  var functionBind = Function.prototype.bind || implementation$1;

  var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

  var isPrimitive = function isPrimitive(value) {
  	return value === null || (typeof value !== 'function' && typeof value !== 'object');
  };

  var fnToStr = Function.prototype.toString;

  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
  	try {
  		var fnStr = fnToStr.call(value);
  		return constructorRegex.test(fnStr);
  	} catch (e) {
  		return false; // not a function
  	}
  };

  var tryFunctionObject = function tryFunctionToStr(value) {
  	try {
  		if (isES6ClassFn(value)) { return false; }
  		fnToStr.call(value);
  		return true;
  	} catch (e) {
  		return false;
  	}
  };
  var toStr$4 = Object.prototype.toString;
  var fnClass = '[object Function]';
  var genClass = '[object GeneratorFunction]';
  var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

  var isCallable = function isCallable(value) {
  	if (!value) { return false; }
  	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
  	if (typeof value === 'function' && !value.prototype) { return true; }
  	if (hasToStringTag) { return tryFunctionObject(value); }
  	if (isES6ClassFn(value)) { return false; }
  	var strClass = toStr$4.call(value);
  	return strClass === fnClass || strClass === genClass;
  };

  var getDay = Date.prototype.getDay;
  var tryDateObject = function tryDateObject(value) {
  	try {
  		getDay.call(value);
  		return true;
  	} catch (e) {
  		return false;
  	}
  };

  var toStr$5 = Object.prototype.toString;
  var dateClass = '[object Date]';
  var hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

  var isDateObject = function isDateObject(value) {
  	if (typeof value !== 'object' || value === null) { return false; }
  	return hasToStringTag$1 ? tryDateObject(value) : toStr$5.call(value) === dateClass;
  };

  /* eslint complexity: [2, 17], max-statements: [2, 33] */
  var shams = function hasSymbols() {
  	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
  	if (typeof Symbol.iterator === 'symbol') { return true; }

  	var obj = {};
  	var sym = Symbol('test');
  	var symObj = Object(sym);
  	if (typeof sym === 'string') { return false; }

  	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
  	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

  	// temp disabled per https://github.com/ljharb/object.assign/issues/17
  	// if (sym instanceof Symbol) { return false; }
  	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  	// if (!(symObj instanceof Symbol)) { return false; }

  	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
  	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  	var symVal = 42;
  	obj[sym] = symVal;
  	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
  	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

  	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

  	var syms = Object.getOwnPropertySymbols(obj);
  	if (syms.length !== 1 || syms[0] !== sym) { return false; }

  	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

  	if (typeof Object.getOwnPropertyDescriptor === 'function') {
  		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
  		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
  	}

  	return true;
  };

  var origSymbol = commonjsGlobal.Symbol;


  var hasSymbols$1 = function hasNativeSymbols() {
  	if (typeof origSymbol !== 'function') { return false; }
  	if (typeof Symbol !== 'function') { return false; }
  	if (typeof origSymbol('foo') !== 'symbol') { return false; }
  	if (typeof Symbol('bar') !== 'symbol') { return false; }

  	return shams();
  };

  var isSymbol$2 = createCommonjsModule(function (module) {

  var toStr = Object.prototype.toString;
  var hasSymbols = hasSymbols$1();

  if (hasSymbols) {
  	var symToStr = Symbol.prototype.toString;
  	var symStringRegex = /^Symbol\(.*\)$/;
  	var isSymbolObject = function isRealSymbolObject(value) {
  		if (typeof value.valueOf() !== 'symbol') {
  			return false;
  		}
  		return symStringRegex.test(symToStr.call(value));
  	};

  	module.exports = function isSymbol(value) {
  		if (typeof value === 'symbol') {
  			return true;
  		}
  		if (toStr.call(value) !== '[object Symbol]') {
  			return false;
  		}
  		try {
  			return isSymbolObject(value);
  		} catch (e) {
  			return false;
  		}
  	};
  } else {

  	module.exports = function isSymbol(value) {
  		// this environment does not support Symbols.
  		return false ;
  	};
  }
  });

  var hasSymbols$2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';






  var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
  	if (typeof O === 'undefined' || O === null) {
  		throw new TypeError('Cannot call method on ' + O);
  	}
  	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
  		throw new TypeError('hint must be "string" or "number"');
  	}
  	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
  	var method, result, i;
  	for (i = 0; i < methodNames.length; ++i) {
  		method = O[methodNames[i]];
  		if (isCallable(method)) {
  			result = method.call(O);
  			if (isPrimitive(result)) {
  				return result;
  			}
  		}
  	}
  	throw new TypeError('No default value');
  };

  var GetMethod = function GetMethod(O, P) {
  	var func = O[P];
  	if (func !== null && typeof func !== 'undefined') {
  		if (!isCallable(func)) {
  			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
  		}
  		return func;
  	}
  	return void 0;
  };

  // http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
  var es2015 = function ToPrimitive(input) {
  	if (isPrimitive(input)) {
  		return input;
  	}
  	var hint = 'default';
  	if (arguments.length > 1) {
  		if (arguments[1] === String) {
  			hint = 'string';
  		} else if (arguments[1] === Number) {
  			hint = 'number';
  		}
  	}

  	var exoticToPrim;
  	if (hasSymbols$2) {
  		if (Symbol.toPrimitive) {
  			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
  		} else if (isSymbol$2(input)) {
  			exoticToPrim = Symbol.prototype.valueOf;
  		}
  	}
  	if (typeof exoticToPrim !== 'undefined') {
  		var result = exoticToPrim.call(input, hint);
  		if (isPrimitive(result)) {
  			return result;
  		}
  		throw new TypeError('unable to convert exotic object to primitive');
  	}
  	if (hint === 'default' && (isDateObject(input) || isSymbol$2(input))) {
  		hint = 'string';
  	}
  	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
  };

  var es6 = es2015;

  /* globals
  	Set,
  	Map,
  	WeakSet,
  	WeakMap,

  	Promise,

  	Symbol,
  	Proxy,

  	Atomics,
  	SharedArrayBuffer,

  	ArrayBuffer,
  	DataView,
  	Uint8Array,
  	Float32Array,
  	Float64Array,
  	Int8Array,
  	Int16Array,
  	Int32Array,
  	Uint8ClampedArray,
  	Uint16Array,
  	Uint32Array,
  */

  var undefined$1; // eslint-disable-line no-shadow-restricted-names

  var ThrowTypeError = Object.getOwnPropertyDescriptor
  	? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())
  	: function () { throw new TypeError(); };

  var hasSymbols$3 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

  var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto
  var generatorFunction =  undefined$1;
  var asyncFunction =  undefined$1;
  var asyncGenFunction =  undefined$1;

  var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

  var INTRINSICS = {
  	'$ %Array%': Array,
  	'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
  	'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
  	'$ %ArrayIteratorPrototype%': hasSymbols$3 ? getProto([][Symbol.iterator]()) : undefined$1,
  	'$ %ArrayPrototype%': Array.prototype,
  	'$ %ArrayProto_entries%': Array.prototype.entries,
  	'$ %ArrayProto_forEach%': Array.prototype.forEach,
  	'$ %ArrayProto_keys%': Array.prototype.keys,
  	'$ %ArrayProto_values%': Array.prototype.values,
  	'$ %AsyncFromSyncIteratorPrototype%': undefined$1,
  	'$ %AsyncFunction%': asyncFunction,
  	'$ %AsyncFunctionPrototype%':  undefined$1,
  	'$ %AsyncGenerator%':  undefined$1,
  	'$ %AsyncGeneratorFunction%': asyncGenFunction,
  	'$ %AsyncGeneratorPrototype%':  undefined$1,
  	'$ %AsyncIteratorPrototype%':  undefined$1,
  	'$ %Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
  	'$ %Boolean%': Boolean,
  	'$ %BooleanPrototype%': Boolean.prototype,
  	'$ %DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
  	'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
  	'$ %Date%': Date,
  	'$ %DatePrototype%': Date.prototype,
  	'$ %decodeURI%': decodeURI,
  	'$ %decodeURIComponent%': decodeURIComponent,
  	'$ %encodeURI%': encodeURI,
  	'$ %encodeURIComponent%': encodeURIComponent,
  	'$ %Error%': Error,
  	'$ %ErrorPrototype%': Error.prototype,
  	'$ %eval%': eval, // eslint-disable-line no-eval
  	'$ %EvalError%': EvalError,
  	'$ %EvalErrorPrototype%': EvalError.prototype,
  	'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
  	'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
  	'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
  	'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
  	'$ %Function%': Function,
  	'$ %FunctionPrototype%': Function.prototype,
  	'$ %Generator%':  undefined$1,
  	'$ %GeneratorFunction%': generatorFunction,
  	'$ %GeneratorPrototype%':  undefined$1,
  	'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
  	'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
  	'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
  	'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
  	'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
  	'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
  	'$ %isFinite%': isFinite,
  	'$ %isNaN%': isNaN,
  	'$ %IteratorPrototype%': hasSymbols$3 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  	'$ %JSON%': JSON,
  	'$ %JSONParse%': JSON.parse,
  	'$ %Map%': typeof Map === 'undefined' ? undefined$1 : Map,
  	'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$3 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
  	'$ %MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
  	'$ %Math%': Math,
  	'$ %Number%': Number,
  	'$ %NumberPrototype%': Number.prototype,
  	'$ %Object%': Object,
  	'$ %ObjectPrototype%': Object.prototype,
  	'$ %ObjProto_toString%': Object.prototype.toString,
  	'$ %ObjProto_valueOf%': Object.prototype.valueOf,
  	'$ %parseFloat%': parseFloat,
  	'$ %parseInt%': parseInt,
  	'$ %Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
  	'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
  	'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
  	'$ %Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
  	'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
  	'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
  	'$ %Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
  	'$ %RangeError%': RangeError,
  	'$ %RangeErrorPrototype%': RangeError.prototype,
  	'$ %ReferenceError%': ReferenceError,
  	'$ %ReferenceErrorPrototype%': ReferenceError.prototype,
  	'$ %Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
  	'$ %RegExp%': RegExp,
  	'$ %RegExpPrototype%': RegExp.prototype,
  	'$ %Set%': typeof Set === 'undefined' ? undefined$1 : Set,
  	'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$3 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
  	'$ %SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
  	'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
  	'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
  	'$ %String%': String,
  	'$ %StringIteratorPrototype%': hasSymbols$3 ? getProto(''[Symbol.iterator]()) : undefined$1,
  	'$ %StringPrototype%': String.prototype,
  	'$ %Symbol%': hasSymbols$3 ? Symbol : undefined$1,
  	'$ %SymbolPrototype%': hasSymbols$3 ? Symbol.prototype : undefined$1,
  	'$ %SyntaxError%': SyntaxError,
  	'$ %SyntaxErrorPrototype%': SyntaxError.prototype,
  	'$ %ThrowTypeError%': ThrowTypeError,
  	'$ %TypedArray%': TypedArray,
  	'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
  	'$ %TypeError%': TypeError,
  	'$ %TypeErrorPrototype%': TypeError.prototype,
  	'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
  	'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
  	'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
  	'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
  	'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
  	'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
  	'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
  	'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
  	'$ %URIError%': URIError,
  	'$ %URIErrorPrototype%': URIError.prototype,
  	'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
  	'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
  	'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
  	'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
  };

  var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
  	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
  		throw new TypeError('"allowMissing" argument must be a boolean');
  	}

  	var key = '$ ' + name;
  	if (!(key in INTRINSICS)) {
  		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
  	}

  	// istanbul ignore if // hopefully this is impossible to test :-)
  	if (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {
  		throw new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
  	}
  	return INTRINSICS[key];
  };

  var $TypeError = GetIntrinsic('%TypeError%');
  var $SyntaxError = GetIntrinsic('%SyntaxError%');



  var predicates = {
    // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
    'Property Descriptor': function isPropertyDescriptor(ES, Desc) {
      if (ES.Type(Desc) !== 'Object') {
        return false;
      }
      var allowed = {
        '[[Configurable]]': true,
        '[[Enumerable]]': true,
        '[[Get]]': true,
        '[[Set]]': true,
        '[[Value]]': true,
        '[[Writable]]': true
      };

      for (var key in Desc) { // eslint-disable-line
        if (src(Desc, key) && !allowed[key]) {
          return false;
        }
      }

      var isData = src(Desc, '[[Value]]');
      var IsAccessor = src(Desc, '[[Get]]') || src(Desc, '[[Set]]');
      if (isData && IsAccessor) {
        throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
      }
      return true;
    }
  };

  var assertRecord = function assertRecord(ES, recordType, argumentName, value) {
    var predicate = predicates[recordType];
    if (typeof predicate !== 'function') {
      throw new $SyntaxError('unknown record type: ' + recordType);
    }
    if (!predicate(ES, value)) {
      throw new $TypeError(argumentName + ' must be a ' + recordType);
    }
    console.log(predicate(ES, value), value);
  };

  var _isNaN = Number.isNaN || function isNaN(a) {
  	return a !== a;
  };

  var $isNaN = Number.isNaN || function (a) { return a !== a; };

  var _isFinite = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

  var has$1 = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

  var $assign = Object.assign;

  var assign$1 = function assign(target, source) {
  	if ($assign) {
  		return $assign(target, source);
  	}

  	for (var key in source) {
  		if (has$1(source, key)) {
  			target[key] = source[key];
  		}
  	}
  	return target;
  };

  var sign$1 = function sign(number) {
  	return number >= 0 ? 1 : -1;
  };

  var mod = function mod(number, modulo) {
  	var remain = number % modulo;
  	return Math.floor(remain >= 0 ? remain : remain + modulo);
  };

  var isPrimitive$1 = function isPrimitive(value) {
  	return value === null || (typeof value !== 'function' && typeof value !== 'object');
  };

  var toStr$6 = Object.prototype.toString;





  // http://ecma-international.org/ecma-262/5.1/#sec-8.12.8
  var ES5internalSlots = {
  	'[[DefaultValue]]': function (O) {
  		var actualHint;
  		if (arguments.length > 1) {
  			actualHint = arguments[1];
  		} else {
  			actualHint = toStr$6.call(O) === '[object Date]' ? String : Number;
  		}

  		if (actualHint === String || actualHint === Number) {
  			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
  			var value, i;
  			for (i = 0; i < methods.length; ++i) {
  				if (isCallable(O[methods[i]])) {
  					value = O[methods[i]]();
  					if (isPrimitive(value)) {
  						return value;
  					}
  				}
  			}
  			throw new TypeError('No default value');
  		}
  		throw new TypeError('invalid [[DefaultValue]] hint supplied');
  	}
  };

  // http://ecma-international.org/ecma-262/5.1/#sec-9.1
  var es5 = function ToPrimitive(input) {
  	if (isPrimitive(input)) {
  		return input;
  	}
  	if (arguments.length > 1) {
  		return ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);
  	}
  	return ES5internalSlots['[[DefaultValue]]'](input);
  };

  var $Object = GetIntrinsic('%Object%');
  var $TypeError$1 = GetIntrinsic('%TypeError%');
  var $String = GetIntrinsic('%String%');













  // https://es5.github.io/#x9
  var ES5 = {
  	ToPrimitive: es5,

  	ToBoolean: function ToBoolean(value) {
  		return !!value;
  	},
  	ToNumber: function ToNumber(value) {
  		return +value; // eslint-disable-line no-implicit-coercion
  	},
  	ToInteger: function ToInteger(value) {
  		var number = this.ToNumber(value);
  		if (_isNaN(number)) { return 0; }
  		if (number === 0 || !_isFinite(number)) { return number; }
  		return sign$1(number) * Math.floor(Math.abs(number));
  	},
  	ToInt32: function ToInt32(x) {
  		return this.ToNumber(x) >> 0;
  	},
  	ToUint32: function ToUint32(x) {
  		return this.ToNumber(x) >>> 0;
  	},
  	ToUint16: function ToUint16(value) {
  		var number = this.ToNumber(value);
  		if (_isNaN(number) || number === 0 || !_isFinite(number)) { return 0; }
  		var posInt = sign$1(number) * Math.floor(Math.abs(number));
  		return mod(posInt, 0x10000);
  	},
  	ToString: function ToString(value) {
  		return $String(value);
  	},
  	ToObject: function ToObject(value) {
  		this.CheckObjectCoercible(value);
  		return $Object(value);
  	},
  	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
  		/* jshint eqnull:true */
  		if (value == null) {
  			throw new $TypeError$1(optMessage || 'Cannot call method on ' + value);
  		}
  		return value;
  	},
  	IsCallable: isCallable,
  	SameValue: function SameValue(x, y) {
  		if (x === y) { // 0 === -0, but they are not identical.
  			if (x === 0) { return 1 / x === 1 / y; }
  			return true;
  		}
  		return _isNaN(x) && _isNaN(y);
  	},

  	// https://www.ecma-international.org/ecma-262/5.1/#sec-8
  	Type: function Type(x) {
  		if (x === null) {
  			return 'Null';
  		}
  		if (typeof x === 'undefined') {
  			return 'Undefined';
  		}
  		if (typeof x === 'function' || typeof x === 'object') {
  			return 'Object';
  		}
  		if (typeof x === 'number') {
  			return 'Number';
  		}
  		if (typeof x === 'boolean') {
  			return 'Boolean';
  		}
  		if (typeof x === 'string') {
  			return 'String';
  		}
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
  	IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
  		if (this.Type(Desc) !== 'Object') {
  			return false;
  		}
  		var allowed = {
  			'[[Configurable]]': true,
  			'[[Enumerable]]': true,
  			'[[Get]]': true,
  			'[[Set]]': true,
  			'[[Value]]': true,
  			'[[Writable]]': true
  		};

  		for (var key in Desc) { // eslint-disable-line
  			if (src(Desc, key) && !allowed[key]) {
  				return false;
  			}
  		}

  		var isData = src(Desc, '[[Value]]');
  		var IsAccessor = src(Desc, '[[Get]]') || src(Desc, '[[Set]]');
  		if (isData && IsAccessor) {
  			throw new $TypeError$1('Property Descriptors may not be both accessor and data descriptors');
  		}
  		return true;
  	},

  	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1
  	IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
  		if (typeof Desc === 'undefined') {
  			return false;
  		}

  		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

  		if (!src(Desc, '[[Get]]') && !src(Desc, '[[Set]]')) {
  			return false;
  		}

  		return true;
  	},

  	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2
  	IsDataDescriptor: function IsDataDescriptor(Desc) {
  		if (typeof Desc === 'undefined') {
  			return false;
  		}

  		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

  		if (!src(Desc, '[[Value]]') && !src(Desc, '[[Writable]]')) {
  			return false;
  		}

  		return true;
  	},

  	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3
  	IsGenericDescriptor: function IsGenericDescriptor(Desc) {
  		if (typeof Desc === 'undefined') {
  			return false;
  		}

  		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

  		if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
  			return true;
  		}

  		return false;
  	},

  	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4
  	FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
  		if (typeof Desc === 'undefined') {
  			return Desc;
  		}

  		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

  		if (this.IsDataDescriptor(Desc)) {
  			return {
  				value: Desc['[[Value]]'],
  				writable: !!Desc['[[Writable]]'],
  				enumerable: !!Desc['[[Enumerable]]'],
  				configurable: !!Desc['[[Configurable]]']
  			};
  		} else if (this.IsAccessorDescriptor(Desc)) {
  			return {
  				get: Desc['[[Get]]'],
  				set: Desc['[[Set]]'],
  				enumerable: !!Desc['[[Enumerable]]'],
  				configurable: !!Desc['[[Configurable]]']
  			};
  		} else {
  			throw new $TypeError$1('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
  		}
  	},

  	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5
  	ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
  		if (this.Type(Obj) !== 'Object') {
  			throw new $TypeError$1('ToPropertyDescriptor requires an object');
  		}

  		var desc = {};
  		if (src(Obj, 'enumerable')) {
  			desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
  		}
  		if (src(Obj, 'configurable')) {
  			desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
  		}
  		if (src(Obj, 'value')) {
  			desc['[[Value]]'] = Obj.value;
  		}
  		if (src(Obj, 'writable')) {
  			desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
  		}
  		if (src(Obj, 'get')) {
  			var getter = Obj.get;
  			if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
  				throw new TypeError('getter must be a function');
  			}
  			desc['[[Get]]'] = getter;
  		}
  		if (src(Obj, 'set')) {
  			var setter = Obj.set;
  			if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
  				throw new $TypeError$1('setter must be a function');
  			}
  			desc['[[Set]]'] = setter;
  		}

  		if ((src(desc, '[[Get]]') || src(desc, '[[Set]]')) && (src(desc, '[[Value]]') || src(desc, '[[Writable]]'))) {
  			throw new $TypeError$1('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
  		}
  		return desc;
  	}
  };

  var es5$1 = ES5;

  var regexExec = RegExp.prototype.exec;
  var gOPD = Object.getOwnPropertyDescriptor;

  var tryRegexExecCall = function tryRegexExec(value) {
  	try {
  		var lastIndex = value.lastIndex;
  		value.lastIndex = 0;

  		regexExec.call(value);
  		return true;
  	} catch (e) {
  		return false;
  	} finally {
  		value.lastIndex = lastIndex;
  	}
  };
  var toStr$7 = Object.prototype.toString;
  var regexClass = '[object RegExp]';
  var hasToStringTag$2 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

  var isRegex = function isRegex(value) {
  	if (!value || typeof value !== 'object') {
  		return false;
  	}
  	if (!hasToStringTag$2) {
  		return toStr$7.call(value) === regexClass;
  	}

  	var descriptor = gOPD(value, 'lastIndex');
  	var hasLastIndexDataProperty = descriptor && src(descriptor, 'value');
  	if (!hasLastIndexDataProperty) {
  		return false;
  	}

  	return tryRegexExecCall(value);
  };

  var $TypeError$2 = GetIntrinsic('%TypeError%');
  var $SyntaxError$1 = GetIntrinsic('%SyntaxError%');
  var $Array = GetIntrinsic('%Array%');
  var $String$1 = GetIntrinsic('%String%');
  var $Object$1 = GetIntrinsic('%Object%');
  var $Number = GetIntrinsic('%Number%');
  var $Symbol = GetIntrinsic('%Symbol%', true);
  var $RegExp = GetIntrinsic('%RegExp%');

  var hasSymbols$4 = !!$Symbol;




  var MAX_SAFE_INTEGER = $Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;





  var parseInteger = parseInt;

  var arraySlice = functionBind.call(Function.call, $Array.prototype.slice);
  var strSlice = functionBind.call(Function.call, $String$1.prototype.slice);
  var isBinary = functionBind.call(Function.call, $RegExp.prototype.test, /^0b[01]+$/i);
  var isOctal = functionBind.call(Function.call, $RegExp.prototype.test, /^0o[0-7]+$/i);
  var regexExec$1 = functionBind.call(Function.call, $RegExp.prototype.exec);
  var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
  var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
  var hasNonWS = functionBind.call(Function.call, $RegExp.prototype.test, nonWSregex);
  var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
  var isInvalidHexLiteral = functionBind.call(Function.call, $RegExp.prototype.test, invalidHexLiteral);
  var $charCodeAt = functionBind.call(Function.call, $String$1.prototype.charCodeAt);

  var toStr$8 = functionBind.call(Function.call, Object.prototype.toString);

  var $NumberValueOf = functionBind.call(Function.call, GetIntrinsic('%NumberPrototype%').valueOf);
  var $BooleanValueOf = functionBind.call(Function.call, GetIntrinsic('%BooleanPrototype%').valueOf);
  var $StringValueOf = functionBind.call(Function.call, GetIntrinsic('%StringPrototype%').valueOf);
  var $DateValueOf = functionBind.call(Function.call, GetIntrinsic('%DatePrototype%').valueOf);

  var $floor = Math.floor;
  var $abs = Math.abs;

  var $ObjectCreate = Object.create;
  var $gOPD = $Object$1.getOwnPropertyDescriptor;

  var $isExtensible = $Object$1.isExtensible;

  var $defineProperty = $Object$1.defineProperty;

  // whitespace from: http://es5.github.io/#x15.5.4.20
  // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
  var ws = [
  	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
  	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
  	'\u2029\uFEFF'
  ].join('');
  var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
  var replace = functionBind.call(Function.call, $String$1.prototype.replace);
  var trim$1 = function (value) {
  	return replace(value, trimRegex, '');
  };





  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
  var ES6 = assign$1(assign$1({}, es5$1), {

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
  	Call: function Call(F, V) {
  		var args = arguments.length > 2 ? arguments[2] : [];
  		if (!this.IsCallable(F)) {
  			throw new $TypeError$2(F + ' is not a function');
  		}
  		return F.apply(V, args);
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
  	ToPrimitive: es6,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
  	// ToBoolean: ES5.ToBoolean,

  	// https://ecma-international.org/ecma-262/6.0/#sec-tonumber
  	ToNumber: function ToNumber(argument) {
  		var value = isPrimitive$1(argument) ? argument : es6(argument, $Number);
  		if (typeof value === 'symbol') {
  			throw new $TypeError$2('Cannot convert a Symbol value to a number');
  		}
  		if (typeof value === 'string') {
  			if (isBinary(value)) {
  				return this.ToNumber(parseInteger(strSlice(value, 2), 2));
  			} else if (isOctal(value)) {
  				return this.ToNumber(parseInteger(strSlice(value, 2), 8));
  			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
  				return NaN;
  			} else {
  				var trimmed = trim$1(value);
  				if (trimmed !== value) {
  					return this.ToNumber(trimmed);
  				}
  			}
  		}
  		return $Number(value);
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
  	// ToInteger: ES5.ToNumber,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
  	// ToInt32: ES5.ToInt32,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
  	// ToUint32: ES5.ToUint32,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
  	ToInt16: function ToInt16(argument) {
  		var int16bit = this.ToUint16(argument);
  		return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
  	// ToUint16: ES5.ToUint16,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
  	ToInt8: function ToInt8(argument) {
  		var int8bit = this.ToUint8(argument);
  		return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
  	ToUint8: function ToUint8(argument) {
  		var number = this.ToNumber(argument);
  		if (_isNaN(number) || number === 0 || !_isFinite(number)) { return 0; }
  		var posInt = sign$1(number) * $floor($abs(number));
  		return mod(posInt, 0x100);
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
  	ToUint8Clamp: function ToUint8Clamp(argument) {
  		var number = this.ToNumber(argument);
  		if (_isNaN(number) || number <= 0) { return 0; }
  		if (number >= 0xFF) { return 0xFF; }
  		var f = $floor(argument);
  		if (f + 0.5 < number) { return f + 1; }
  		if (number < f + 0.5) { return f; }
  		if (f % 2 !== 0) { return f + 1; }
  		return f;
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
  	ToString: function ToString(argument) {
  		if (typeof argument === 'symbol') {
  			throw new $TypeError$2('Cannot convert a Symbol value to a string');
  		}
  		return $String$1(argument);
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
  	ToObject: function ToObject(value) {
  		this.RequireObjectCoercible(value);
  		return $Object$1(value);
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
  	ToPropertyKey: function ToPropertyKey(argument) {
  		var key = this.ToPrimitive(argument, $String$1);
  		return typeof key === 'symbol' ? key : this.ToString(key);
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  	ToLength: function ToLength(argument) {
  		var len = this.ToInteger(argument);
  		if (len <= 0) { return 0; } // includes converting -0 to +0
  		if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
  		return len;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
  	CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
  		if (toStr$8(argument) !== '[object String]') {
  			throw new $TypeError$2('must be a string');
  		}
  		if (argument === '-0') { return -0; }
  		var n = this.ToNumber(argument);
  		if (this.SameValue(this.ToString(n), argument)) { return n; }
  		return void 0;
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
  	RequireObjectCoercible: es5$1.CheckObjectCoercible,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
  	IsArray: $Array.isArray || function IsArray(argument) {
  		return toStr$8(argument) === '[object Array]';
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
  	// IsCallable: ES5.IsCallable,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
  	IsConstructor: function IsConstructor(argument) {
  		return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
  	IsExtensible: Object.preventExtensions
  		? function IsExtensible(obj) {
  			if (isPrimitive$1(obj)) {
  				return false;
  			}
  			return $isExtensible(obj);
  		}
  		: function isExtensible(obj) { return true; }, // eslint-disable-line no-unused-vars

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
  	IsInteger: function IsInteger(argument) {
  		if (typeof argument !== 'number' || _isNaN(argument) || !_isFinite(argument)) {
  			return false;
  		}
  		var abs = $abs(argument);
  		return $floor(abs) === abs;
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
  	IsPropertyKey: function IsPropertyKey(argument) {
  		return typeof argument === 'string' || typeof argument === 'symbol';
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-isregexp
  	IsRegExp: function IsRegExp(argument) {
  		if (!argument || typeof argument !== 'object') {
  			return false;
  		}
  		if (hasSymbols$4) {
  			var isRegExp = argument[$Symbol.match];
  			if (typeof isRegExp !== 'undefined') {
  				return es5$1.ToBoolean(isRegExp);
  			}
  		}
  		return isRegex(argument);
  	},

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
  	// SameValue: ES5.SameValue,

  	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
  	SameValueZero: function SameValueZero(x, y) {
  		return (x === y) || (_isNaN(x) && _isNaN(y));
  	},

  	/**
  	 * 7.3.2 GetV (V, P)
  	 * 1. Assert: IsPropertyKey(P) is true.
  	 * 2. Let O be ToObject(V).
  	 * 3. ReturnIfAbrupt(O).
  	 * 4. Return O.[[Get]](P, V).
  	 */
  	GetV: function GetV(V, P) {
  		// 7.3.2.1
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}

  		// 7.3.2.2-3
  		var O = this.ToObject(V);

  		// 7.3.2.4
  		return O[P];
  	},

  	/**
  	 * 7.3.9 - https://ecma-international.org/ecma-262/6.0/#sec-getmethod
  	 * 1. Assert: IsPropertyKey(P) is true.
  	 * 2. Let func be GetV(O, P).
  	 * 3. ReturnIfAbrupt(func).
  	 * 4. If func is either undefined or null, return undefined.
  	 * 5. If IsCallable(func) is false, throw a TypeError exception.
  	 * 6. Return func.
  	 */
  	GetMethod: function GetMethod(O, P) {
  		// 7.3.9.1
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}

  		// 7.3.9.2
  		var func = this.GetV(O, P);

  		// 7.3.9.4
  		if (func == null) {
  			return void 0;
  		}

  		// 7.3.9.5
  		if (!this.IsCallable(func)) {
  			throw new $TypeError$2(P + 'is not a function');
  		}

  		// 7.3.9.6
  		return func;
  	},

  	/**
  	 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
  	 * 1. Assert: Type(O) is Object.
  	 * 2. Assert: IsPropertyKey(P) is true.
  	 * 3. Return O.[[Get]](P, O).
  	 */
  	Get: function Get(O, P) {
  		// 7.3.1.1
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}
  		// 7.3.1.2
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}
  		// 7.3.1.3
  		return O[P];
  	},

  	Type: function Type(x) {
  		if (typeof x === 'symbol') {
  			return 'Symbol';
  		}
  		return es5$1.Type(x);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
  	SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}
  		var C = O.constructor;
  		if (typeof C === 'undefined') {
  			return defaultConstructor;
  		}
  		if (this.Type(C) !== 'Object') {
  			throw new $TypeError$2('O.constructor is not an Object');
  		}
  		var S = hasSymbols$4 && $Symbol.species ? C[$Symbol.species] : void 0;
  		if (S == null) {
  			return defaultConstructor;
  		}
  		if (this.IsConstructor(S)) {
  			return S;
  		}
  		throw new $TypeError$2('no constructor found');
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-completepropertydescriptor
  	CompletePropertyDescriptor: function CompletePropertyDescriptor(Desc) {
  		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

  		if (this.IsGenericDescriptor(Desc) || this.IsDataDescriptor(Desc)) {
  			if (!src(Desc, '[[Value]]')) {
  				Desc['[[Value]]'] = void 0;
  			}
  			if (!src(Desc, '[[Writable]]')) {
  				Desc['[[Writable]]'] = false;
  			}
  		} else {
  			if (!src(Desc, '[[Get]]')) {
  				Desc['[[Get]]'] = void 0;
  			}
  			if (!src(Desc, '[[Set]]')) {
  				Desc['[[Set]]'] = void 0;
  			}
  		}
  		if (!src(Desc, '[[Enumerable]]')) {
  			Desc['[[Enumerable]]'] = false;
  		}
  		if (!src(Desc, '[[Configurable]]')) {
  			Desc['[[Configurable]]'] = false;
  		}
  		return Desc;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-set-o-p-v-throw
  	Set: function Set(O, P, V, Throw) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('O must be an Object');
  		}
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('P must be a Property Key');
  		}
  		if (this.Type(Throw) !== 'Boolean') {
  			throw new $TypeError$2('Throw must be a Boolean');
  		}
  		if (Throw) {
  			O[P] = V;
  			return true;
  		} else {
  			try {
  				O[P] = V;
  			} catch (e) {
  				return false;
  			}
  		}
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-hasownproperty
  	HasOwnProperty: function HasOwnProperty(O, P) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('O must be an Object');
  		}
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('P must be a Property Key');
  		}
  		return src(O, P);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty
  	HasProperty: function HasProperty(O, P) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('O must be an Object');
  		}
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('P must be a Property Key');
  		}
  		return P in O;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
  	IsConcatSpreadable: function IsConcatSpreadable(O) {
  		if (this.Type(O) !== 'Object') {
  			return false;
  		}
  		if (hasSymbols$4 && typeof $Symbol.isConcatSpreadable === 'symbol') {
  			var spreadable = this.Get(O, Symbol.isConcatSpreadable);
  			if (typeof spreadable !== 'undefined') {
  				return this.ToBoolean(spreadable);
  			}
  		}
  		return this.IsArray(O);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-invoke
  	Invoke: function Invoke(O, P) {
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('P must be a Property Key');
  		}
  		var argumentsList = arraySlice(arguments, 2);
  		var func = this.GetV(O, P);
  		return this.Call(func, O, argumentsList);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-getiterator
  	GetIterator: function GetIterator(obj, method) {
  		if (!hasSymbols$4) {
  			throw new SyntaxError('ES.GetIterator depends on native iterator support.');
  		}

  		var actualMethod = method;
  		if (arguments.length < 2) {
  			actualMethod = this.GetMethod(obj, $Symbol.iterator);
  		}
  		var iterator = this.Call(actualMethod, obj);
  		if (this.Type(iterator) !== 'Object') {
  			throw new $TypeError$2('iterator must return an object');
  		}

  		return iterator;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-iteratornext
  	IteratorNext: function IteratorNext(iterator, value) {
  		var result = this.Invoke(iterator, 'next', arguments.length < 2 ? [] : [value]);
  		if (this.Type(result) !== 'Object') {
  			throw new $TypeError$2('iterator next must return an object');
  		}
  		return result;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorcomplete
  	IteratorComplete: function IteratorComplete(iterResult) {
  		if (this.Type(iterResult) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(iterResult) is not Object');
  		}
  		return this.ToBoolean(this.Get(iterResult, 'done'));
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorvalue
  	IteratorValue: function IteratorValue(iterResult) {
  		if (this.Type(iterResult) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(iterResult) is not Object');
  		}
  		return this.Get(iterResult, 'value');
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorstep
  	IteratorStep: function IteratorStep(iterator) {
  		var result = this.IteratorNext(iterator);
  		var done = this.IteratorComplete(result);
  		return done === true ? false : result;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-iteratorclose
  	IteratorClose: function IteratorClose(iterator, completion) {
  		if (this.Type(iterator) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(iterator) is not Object');
  		}
  		if (!this.IsCallable(completion)) {
  			throw new $TypeError$2('Assertion failed: completion is not a thunk for a Completion Record');
  		}
  		var completionThunk = completion;

  		var iteratorReturn = this.GetMethod(iterator, 'return');

  		if (typeof iteratorReturn === 'undefined') {
  			return completionThunk();
  		}

  		var completionRecord;
  		try {
  			var innerResult = this.Call(iteratorReturn, iterator, []);
  		} catch (e) {
  			// if we hit here, then "e" is the innerResult completion that needs re-throwing

  			// if the completion is of type "throw", this will throw.
  			completionRecord = completionThunk();
  			completionThunk = null; // ensure it's not called twice.

  			// if not, then return the innerResult completion
  			throw e;
  		}
  		completionRecord = completionThunk(); // if innerResult worked, then throw if the completion does
  		completionThunk = null; // ensure it's not called twice.

  		if (this.Type(innerResult) !== 'Object') {
  			throw new $TypeError$2('iterator .return must return an object');
  		}

  		return completionRecord;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-createiterresultobject
  	CreateIterResultObject: function CreateIterResultObject(value, done) {
  		if (this.Type(done) !== 'Boolean') {
  			throw new $TypeError$2('Assertion failed: Type(done) is not Boolean');
  		}
  		return {
  			value: value,
  			done: done
  		};
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-regexpexec
  	RegExpExec: function RegExpExec(R, S) {
  		if (this.Type(R) !== 'Object') {
  			throw new $TypeError$2('R must be an Object');
  		}
  		if (this.Type(S) !== 'String') {
  			throw new $TypeError$2('S must be a String');
  		}
  		var exec = this.Get(R, 'exec');
  		if (this.IsCallable(exec)) {
  			var result = this.Call(exec, R, [S]);
  			if (result === null || this.Type(result) === 'Object') {
  				return result;
  			}
  			throw new $TypeError$2('"exec" method must return `null` or an Object');
  		}
  		return regexExec$1(R, S);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate
  	ArraySpeciesCreate: function ArraySpeciesCreate(originalArray, length) {
  		if (!this.IsInteger(length) || length < 0) {
  			throw new $TypeError$2('Assertion failed: length must be an integer >= 0');
  		}
  		var len = length === 0 ? 0 : length;
  		var C;
  		var isArray = this.IsArray(originalArray);
  		if (isArray) {
  			C = this.Get(originalArray, 'constructor');
  			// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
  			// if (this.IsConstructor(C)) {
  			// 	if C is another realm's Array, C = undefined
  			// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
  			// }
  			if (this.Type(C) === 'Object' && hasSymbols$4 && $Symbol.species) {
  				C = this.Get(C, $Symbol.species);
  				if (C === null) {
  					C = void 0;
  				}
  			}
  		}
  		if (typeof C === 'undefined') {
  			return $Array(len);
  		}
  		if (!this.IsConstructor(C)) {
  			throw new $TypeError$2('C must be a constructor');
  		}
  		return new C(len); // this.Construct(C, len);
  	},

  	CreateDataProperty: function CreateDataProperty(O, P, V) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}
  		var oldDesc = $gOPD(O, P);
  		var extensible = oldDesc || (typeof $isExtensible !== 'function' || $isExtensible(O));
  		var immutable = oldDesc && (!oldDesc.writable || !oldDesc.configurable);
  		if (immutable || !extensible) {
  			return false;
  		}
  		var newDesc = {
  			configurable: true,
  			enumerable: true,
  			value: V,
  			writable: true
  		};
  		$defineProperty(O, P, newDesc);
  		return true;
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow
  	CreateDataPropertyOrThrow: function CreateDataPropertyOrThrow(O, P, V) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}
  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}
  		var success = this.CreateDataProperty(O, P, V);
  		if (!success) {
  			throw new $TypeError$2('unable to create data property');
  		}
  		return success;
  	},

  	// https://www.ecma-international.org/ecma-262/6.0/#sec-objectcreate
  	ObjectCreate: function ObjectCreate(proto, internalSlotsList) {
  		if (proto !== null && this.Type(proto) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: proto must be null or an object');
  		}
  		var slots = arguments.length < 2 ? [] : internalSlotsList;
  		if (slots.length > 0) {
  			throw new $SyntaxError$1('es-abstract does not yet support internal slots');
  		}

  		if (proto === null && !$ObjectCreate) {
  			throw new $SyntaxError$1('native Object.create support is required to create null objects');
  		}

  		return $ObjectCreate(proto);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-advancestringindex
  	AdvanceStringIndex: function AdvanceStringIndex(S, index, unicode) {
  		if (this.Type(S) !== 'String') {
  			throw new $TypeError$2('S must be a String');
  		}
  		if (!this.IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
  			throw new $TypeError$2('Assertion failed: length must be an integer >= 0 and <= 2**53');
  		}
  		if (this.Type(unicode) !== 'Boolean') {
  			throw new $TypeError$2('Assertion failed: unicode must be a Boolean');
  		}
  		if (!unicode) {
  			return index + 1;
  		}
  		var length = S.length;
  		if ((index + 1) >= length) {
  			return index + 1;
  		}

  		var first = $charCodeAt(S, index);
  		if (first < 0xD800 || first > 0xDBFF) {
  			return index + 1;
  		}

  		var second = $charCodeAt(S, index + 1);
  		if (second < 0xDC00 || second > 0xDFFF) {
  			return index + 1;
  		}

  		return index + 2;
  	},

  	// https://www.ecma-international.org/ecma-262/6.0/#sec-createmethodproperty
  	CreateMethodProperty: function CreateMethodProperty(O, P, V) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}

  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}

  		var newDesc = {
  			configurable: true,
  			enumerable: false,
  			value: V,
  			writable: true
  		};
  		return !!$defineProperty(O, P, newDesc);
  	},

  	// https://www.ecma-international.org/ecma-262/6.0/#sec-definepropertyorthrow
  	DefinePropertyOrThrow: function DefinePropertyOrThrow(O, P, desc) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}

  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}

  		return !!$defineProperty(O, P, desc);
  	},

  	// https://www.ecma-international.org/ecma-262/6.0/#sec-deletepropertyorthrow
  	DeletePropertyOrThrow: function DeletePropertyOrThrow(O, P) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}

  		if (!this.IsPropertyKey(P)) {
  			throw new $TypeError$2('Assertion failed: IsPropertyKey(P) is not true');
  		}

  		var success = delete O[P];
  		if (!success) {
  			throw new TypeError('Attempt to delete property failed.');
  		}
  		return success;
  	},

  	// https://www.ecma-international.org/ecma-262/6.0/#sec-enumerableownnames
  	EnumerableOwnNames: function EnumerableOwnNames(O) {
  		if (this.Type(O) !== 'Object') {
  			throw new $TypeError$2('Assertion failed: Type(O) is not Object');
  		}

  		return objectKeys(O);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-number-prototype-object
  	thisNumberValue: function thisNumberValue(value) {
  		if (this.Type(value) === 'Number') {
  			return value;
  		}

  		return $NumberValueOf(value);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-boolean-prototype-object
  	thisBooleanValue: function thisBooleanValue(value) {
  		if (this.Type(value) === 'Boolean') {
  			return value;
  		}

  		return $BooleanValueOf(value);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-string-prototype-object
  	thisStringValue: function thisStringValue(value) {
  		if (this.Type(value) === 'String') {
  			return value;
  		}

  		return $StringValueOf(value);
  	},

  	// https://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-date-prototype-object
  	thisTimeValue: function thisTimeValue(value) {
  		return $DateValueOf(value);
  	}
  });

  delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

  var es2015$1 = ES6;

  var es6$1 = es2015$1;

  var $isNaN$1 = Number.isNaN || function isNaN(a) {
  	return a !== a;
  };
  var $isFinite = Number.isFinite || function isFinite(n) {
  	return typeof n === 'number' && commonjsGlobal.isFinite(n);
  };
  var indexOf$1 = Array.prototype.indexOf;

  var implementation$2 = function includes(searchElement) {
  	var fromIndex = arguments.length > 1 ? es6$1.ToInteger(arguments[1]) : 0;
  	if (indexOf$1 && !$isNaN$1(searchElement) && $isFinite(fromIndex) && typeof searchElement !== 'undefined') {
  		return indexOf$1.apply(this, arguments) > -1;
  	}

  	var O = es6$1.ToObject(this);
  	var length = es6$1.ToLength(O.length);
  	if (length === 0) {
  		return false;
  	}
  	var k = fromIndex >= 0 ? fromIndex : Math.max(0, length + fromIndex);
  	while (k < length) {
  		if (es6$1.SameValueZero(searchElement, O[k])) {
  			return true;
  		}
  		k += 1;
  	}
  	return false;
  };

  var polyfill$1 = function getPolyfill() {
  	return Array.prototype.includes || implementation$2;
  };

  var shim$3 = function shimArrayPrototypeIncludes() {
  	var polyfill = polyfill$1();
  	defineProperties_1(
  		Array.prototype,
  		{ includes: polyfill },
  		{ includes: function () { return Array.prototype.includes !== polyfill; } }
  	);
  	return polyfill;
  };

  var polyfill$2 = polyfill$1();


  var slice$2 = Array.prototype.slice;

  /* eslint-disable no-unused-vars */
  var boundIncludesShim = function includes(array, searchElement) {
  /* eslint-enable no-unused-vars */
  	es6$1.RequireObjectCoercible(array);
  	return polyfill$2.apply(array, slice$2.call(arguments, 1));
  };
  defineProperties_1(boundIncludesShim, {
  	getPolyfill: polyfill$1,
  	implementation: implementation$2,
  	shim: shim$3
  });

  var arrayIncludes = boundIncludesShim;

  var Array_prototype_includes = arrayIncludes;

  var Array_prototype = {
  	includes: Array_prototype_includes,
  	shim: function shimArrayPrototype() {
  		Array_prototype_includes.shim();
  	}
  };

  var _Array = {
  	prototype: Array_prototype,
  	shim: function shimArray() {
  		Array_prototype.shim();
  	}
  };

  var ES2016 = assign$1(assign$1({}, es2015$1), {
  	// https://github.com/tc39/ecma262/pull/60
  	SameValueNonNumber: function SameValueNonNumber(x, y) {
  		if (typeof x === 'number' || typeof x !== typeof y) {
  			throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
  		}
  		return this.SameValue(x, y);
  	}
  });

  var es2016 = ES2016;

  var es7 = es2016;

  var defineProperty$2 = Object.defineProperty;
  var getDescriptor = Object.getOwnPropertyDescriptor;
  var getOwnNames = Object.getOwnPropertyNames;
  var getSymbols = Object.getOwnPropertySymbols;
  var concat$1 = Function.call.bind(Array.prototype.concat);
  var reduce = Function.call.bind(Array.prototype.reduce);
  var getAll = getSymbols ? function (obj) {
  	return concat$1(getOwnNames(obj), getSymbols(obj));
  } : getOwnNames;

  var isES5 = es7.IsCallable(getDescriptor) && es7.IsCallable(getOwnNames);

  var safePut = function put(obj, prop, val) { // eslint-disable-line max-params
  	if (defineProperty$2 && prop in obj) {
  		defineProperty$2(obj, prop, {
  			configurable: true,
  			enumerable: true,
  			value: val,
  			writable: true
  		});
  	} else {
  		obj[prop] = val;
  	}
  };

  var implementation$3 = function getOwnPropertyDescriptors(value) {
  	es7.RequireObjectCoercible(value);
  	if (!isES5) {
  		throw new TypeError('getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor');
  	}

  	var O = es7.ToObject(value);
  	return reduce(getAll(O), function (acc, key) {
  		var descriptor = getDescriptor(O, key);
  		if (typeof descriptor !== 'undefined') {
  			safePut(acc, key, descriptor);
  		}
  		return acc;
  	}, {});
  };

  var polyfill$3 = function getPolyfill() {
  	return typeof Object.getOwnPropertyDescriptors === 'function' ? Object.getOwnPropertyDescriptors : implementation$3;
  };

  var shim$4 = function shimGetOwnPropertyDescriptors() {
  	var polyfill = polyfill$3();
  	defineProperties_1(
  		Object,
  		{ getOwnPropertyDescriptors: polyfill },
  		{ getOwnPropertyDescriptors: function () { return Object.getOwnPropertyDescriptors !== polyfill; } }
  	);
  	return polyfill;
  };

  defineProperties_1(implementation$3, {
  	getPolyfill: polyfill$3,
  	implementation: implementation$3,
  	shim: shim$4
  });

  var object_getownpropertydescriptors = implementation$3;

  var isEnumerable$1 = functionBind.call(Function.call, Object.prototype.propertyIsEnumerable);

  var implementation$4 = function entries(O) {
  	var obj = es7.RequireObjectCoercible(O);
  	var entrys = [];
  	for (var key in obj) {
  		if (src(obj, key) && isEnumerable$1(obj, key)) {
  			entrys.push([key, obj[key]]);
  		}
  	}
  	return entrys;
  };

  var polyfill$4 = function getPolyfill() {
  	return typeof Object.entries === 'function' ? Object.entries : implementation$4;
  };

  var shim$5 = function shimEntries() {
  	var polyfill = polyfill$4();
  	defineProperties_1(Object, { entries: polyfill }, {
  		entries: function testEntries() {
  			return Object.entries !== polyfill;
  		}
  	});
  	return polyfill;
  };

  var polyfill$5 = polyfill$4();

  defineProperties_1(polyfill$5, {
  	getPolyfill: polyfill$4,
  	implementation: implementation$4,
  	shim: shim$5
  });

  var object_entries = polyfill$5;

  var isEnumerable$2 = functionBind.call(Function.call, Object.prototype.propertyIsEnumerable);

  var implementation$5 = function values(O) {
  	var obj = es7.RequireObjectCoercible(O);
  	var vals = [];
  	for (var key in obj) {
  		if (src(obj, key) && isEnumerable$2(obj, key)) {
  			vals.push(obj[key]);
  		}
  	}
  	return vals;
  };

  var polyfill$6 = function getPolyfill() {
  	return typeof Object.values === 'function' ? Object.values : implementation$5;
  };

  var shim$6 = function shimValues() {
  	var polyfill = polyfill$6();
  	defineProperties_1(Object, { values: polyfill }, {
  		values: function testValues() {
  			return Object.values !== polyfill;
  		}
  	});
  	return polyfill;
  };

  var polyfill$7 = polyfill$6();

  defineProperties_1(polyfill$7, {
  	getPolyfill: polyfill$6,
  	implementation: implementation$5,
  	shim: shim$6
  });

  var object_values = polyfill$7;

  var _Object = {
  	entries: object_entries,
  	getOwnPropertyDescriptors: object_getownpropertydescriptors,
  	shim: function shimObject() {
  		object_getownpropertydescriptors.shim();
  		object_entries.shim();
  		object_values.shim();
  	},
  	values: object_values
  };

  var atShim = function at(pos) {
  	es7.RequireObjectCoercible(this);
  	var O = es7.ToObject(this);
  	var S = es7.ToString(O);
  	var position = es7.ToInteger(pos);
  	var size = S.length;
  	if (position < 0 || position >= size) {
  		return '';
  	}
  	// Get the first code unit and code unit value
  	var cuFirst = S.charCodeAt(position);
  	var cuSecond;
  	var nextIndex = position + 1;
  	var len = 1;
  	// Check if it’s the start of a surrogate pair.
  	var isHighSurrogate = cuFirst >= 0xD800 && cuFirst <= 0xDBFF;
  	if (isHighSurrogate && size > nextIndex /* there is a next code unit */) {
  		cuSecond = S.charCodeAt(nextIndex);
  		if (cuSecond >= 0xDC00 && cuSecond <= 0xDFFF) { // low surrogate
  			len = 2;
  		}
  	}
  	return S.slice(position, position + len);
  };

  var at = functionBind.call(Function.call, atShim);
  defineProperties_1(at, {
  	method: atShim,
  	shim: function shimStringPrototypeAt() {
  		defineProperties_1(String.prototype, {
  			at: atShim
  		});
  		return String.prototype.at;
  	}
  });

  var stringAt = at;

  var String_prototype_at = stringAt;

  var slice$3 = functionBind.call(Function.call, String.prototype.slice);

  var implementation$6 = function padStart(maxLength) {
  	var O = es7.RequireObjectCoercible(this);
  	var S = es7.ToString(O);
  	var stringLength = es7.ToLength(S.length);
  	var fillString;
  	if (arguments.length > 1) {
  		fillString = arguments[1];
  	}
  	var filler = typeof fillString === 'undefined' ? '' : es7.ToString(fillString);
  	if (filler === '') {
  		filler = ' ';
  	}
  	var intMaxLength = es7.ToLength(maxLength);
  	if (intMaxLength <= stringLength) {
  		return S;
  	}
  	var fillLen = intMaxLength - stringLength;
  	while (filler.length < fillLen) {
  		var fLen = filler.length;
  		var remainingCodeUnits = fillLen - fLen;
  		filler += fLen > remainingCodeUnits ? slice$3(filler, 0, remainingCodeUnits) : filler;
  	}

  	var truncatedStringFiller = filler.length > fillLen ? slice$3(filler, 0, fillLen) : filler;
  	return truncatedStringFiller + S;
  };

  var polyfill$8 = function getPolyfill() {
  	return typeof String.prototype.padStart === 'function' ? String.prototype.padStart : implementation$6;
  };

  var shim$7 = function shimPadStart() {
  	var polyfill = polyfill$8();
  	defineProperties_1(String.prototype, { padStart: polyfill }, { padStart: function () { return String.prototype.padStart !== polyfill; } });
  	return polyfill;
  };

  var bound = functionBind.call(Function.apply, implementation$6);

  var boundPadStart = function padStart(str, maxLength) {
  	es7.RequireObjectCoercible(str);
  	var args = [maxLength];
  	if (arguments.length > 2) {
  		args.push(arguments[2]);
  	}
  	return bound(str, args);
  };

  defineProperties_1(boundPadStart, {
  	getPolyfill: polyfill$8,
  	implementation: implementation$6,
  	shim: shim$7
  });

  var string_prototype_padstart = boundPadStart;

  var String_prototype_padStart = string_prototype_padstart;

  var slice$4 = functionBind.call(Function.call, String.prototype.slice);

  var implementation$7 = function padEnd(maxLength) {
  	var O = es7.RequireObjectCoercible(this);
  	var S = es7.ToString(O);
  	var stringLength = es7.ToLength(S.length);
  	var fillString;
  	if (arguments.length > 1) {
  		fillString = arguments[1];
  	}
  	var filler = typeof fillString === 'undefined' ? '' : es7.ToString(fillString);
  	if (filler === '') {
  		filler = ' ';
  	}
  	var intMaxLength = es7.ToLength(maxLength);
  	if (intMaxLength <= stringLength) {
  		return S;
  	}
  	var fillLen = intMaxLength - stringLength;
  	while (filler.length < fillLen) {
  		var fLen = filler.length;
  		var remainingCodeUnits = fillLen - fLen;
  		filler += fLen > remainingCodeUnits ? slice$4(filler, 0, remainingCodeUnits) : filler;
  	}

  	var truncatedStringFiller = filler.length > fillLen ? slice$4(filler, 0, fillLen) : filler;
  	return S + truncatedStringFiller;
  };

  var polyfill$9 = function getPolyfill() {
  	return typeof String.prototype.padEnd === 'function' ? String.prototype.padEnd : implementation$7;
  };

  var shim$8 = function shimPadEnd() {
  	var polyfill = polyfill$9();
  	defineProperties_1(String.prototype, { padEnd: polyfill }, { padEnd: function () { return String.prototype.padEnd !== polyfill; } });
  	return polyfill;
  };

  var bound$1 = functionBind.call(Function.apply, implementation$7);

  var boundPadEnd = function padEnd(str, maxLength) {
  	es7.RequireObjectCoercible(str);
  	var args = [maxLength];
  	if (arguments.length > 2) {
  		args.push(arguments[2]);
  	}
  	return bound$1(str, args);
  };

  defineProperties_1(boundPadEnd, {
  	getPolyfill: polyfill$9,
  	implementation: implementation$7,
  	shim: shim$8
  });

  var string_prototype_padend = boundPadEnd;

  var String_prototype_padEnd = string_prototype_padend;

  var replace$1 = functionBind.call(Function.call, String.prototype.replace);

  var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;

  var implementation$8 = function trimLeft() {
  	return replace$1(this, leftWhitespace, '');
  };

  var polyfill$a = function getPolyfill() {
  	if (!String.prototype.trimLeft) {
  		return implementation$8;
  	}
  	var zeroWidthSpace = '\u200b';
  	if (zeroWidthSpace.trimLeft() !== zeroWidthSpace) {
  		return implementation$8;
  	}
  	return String.prototype.trimLeft;
  };

  var shim$9 = function shimTrimLeft() {
  	var polyfill = polyfill$a();
  	defineProperties_1(
  		String.prototype,
  		{ trimLeft: polyfill },
  		{ trimLeft: function () { return String.prototype.trimLeft !== polyfill; } }
  	);
  	return polyfill;
  };

  var bound$2 = functionBind.call(Function.call, polyfill$a());

  defineProperties_1(bound$2, {
  	getPolyfill: polyfill$a,
  	implementation: implementation$8,
  	shim: shim$9
  });

  var string_prototype_trimleft = bound$2;

  var String_prototype_trimLeft = string_prototype_trimleft;

  var replace$2 = functionBind.call(Function.call, String.prototype.replace);

  var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;

  var implementation$9 = function trimRight() {
  	return replace$2(this, rightWhitespace, '');
  };

  var polyfill$b = function getPolyfill() {
  	if (!String.prototype.trimRight) {
  		return implementation$9;
  	}
  	var zeroWidthSpace = '\u200b';
  	if (zeroWidthSpace.trimRight() !== zeroWidthSpace) {
  		return implementation$9;
  	}
  	return String.prototype.trimRight;
  };

  var shim$a = function shimTrimRight() {
  	var polyfill = polyfill$b();
  	defineProperties_1(
  		String.prototype,
  		{ trimRight: polyfill },
  		{ trimRight: function () { return String.prototype.trimRight !== polyfill; } }
  	);
  	return polyfill;
  };

  var bound$3 = functionBind.call(Function.call, polyfill$b());

  defineProperties_1(bound$3, {
  	getPolyfill: polyfill$b,
  	implementation: implementation$9,
  	shim: shim$a
  });

  var string_prototype_trimright = bound$3;

  var String_prototype_trimRight = string_prototype_trimright;

  var String_prototype = {
  	at: String_prototype_at,
  	padStart: String_prototype_padStart,
  	padEnd: String_prototype_padEnd,
  	trimLeft: String_prototype_trimLeft,
  	trimRight: String_prototype_trimRight,
  	shim: function shimStringPrototype() {
  		String_prototype_at.shim();
  		String_prototype_padStart.shim();
  		String_prototype_padEnd.shim();
  		String_prototype_trimLeft.shim();
  		String_prototype_trimRight.shim();
  	}
  };

  var _String = {
  	prototype: String_prototype,
  	shim: function shimString() {
  		String_prototype.shim();
  	}
  };

  var es7Shim = {
  	Array: _Array,
  	Object: _Object,
  	String: _String,
  	shim: function shimES7() {
  		_Array.shim();
  		_Object.shim();
  		_String.shim();
  	}
  };

  var es7Shim$1 = es7Shim;

  function shim$b() {
    if (typeof window === 'undefined') {
      return;
    }

    es7Shim$1.shim();
  }

  var Dummy = function Dummy() {
    this._attributes = {};
  };

  Dummy.prototype.attr = function attr (key, value) {
    if (typeof value === 'undefined') {
      return this._attributes[key];
    }

    this._attributes[key] = value;
    return this;
  };

  Dummy.prototype.classed = function classed () {
    return this;
  };

  Dummy.prototype.html = function html () {
    return this;
  };

  Dummy.prototype.property = function property () {
    return this;
  };

  Dummy.prototype.style = function style () {
    return this;
  };

  Dummy.prototype.text = function text () {
    return this;
  };

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$2(value) {
    return value;
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant$2(value) {
    return function() {
      return value;
    };
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$1 = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$2 = freeGlobal$1 || freeSelf$1 || Function('return this')();

  /** Built-in value references. */
  var Symbol$2 = root$2.Symbol;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$2 = objectProto$5.toString;

  /** Built-in value references. */
  var symToStringTag$2 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$5.call(value, symToStringTag$2),
        tag = value[symToStringTag$2];

    try {
      value[symToStringTag$2] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$2.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$2] = tag;
      } else {
        delete value[symToStringTag$2];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$3 = objectProto$6.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString$3.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag$1 = '[object Null]',
      undefinedTag$1 = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$3 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$1(value) {
    if (value == null) {
      return value === undefined ? undefinedTag$1 : nullTag$1;
    }
    return (symToStringTag$3 && symToStringTag$3 in Object(value))
      ? getRawTag$1(value)
      : objectToString$1(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$2(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag$1 = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      proxyTag$1 = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$2(value) {
    if (!isObject$2(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$1(value);
    return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData$1 = root$2['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey$1 = (function() {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$1(func) {
    return !!maskSrcKey$1 && (maskSrcKey$1 in func);
  }

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$1(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$3 = Function.prototype,
      objectProto$7 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$3 = funcProto$3.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative$1 = RegExp('^' +
    funcToString$3.call(hasOwnProperty$6).replace(reRegExpChar$1, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$1(value) {
    if (!isObject$2(value) || isMasked$1(value)) {
      return false;
    }
    var pattern = isFunction$2(value) ? reIsNative$1 : reIsHostCtor$1;
    return pattern.test(toSource$1(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$1(object, key) {
    var value = getValue$1(object, key);
    return baseIsNative$1(value) ? value : undefined;
  }

  var defineProperty$3 = (function() {
    try {
      var func = getNative$1(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty$3 ? identity$2 : function(func, string) {
    return defineProperty$3(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant$2(string),
      'writable': true
    });
  };

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString);

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity$2), func + '');
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq$1(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$1(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto$1 = Array.prototype;

  /** Built-in value references. */
  var splice$1 = arrayProto$1.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$1(key) {
    var data = this.__data__,
        index = assocIndexOf$1(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice$1.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$1(key) {
    var data = this.__data__,
        index = assocIndexOf$1(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$1(key, value) {
    var data = this.__data__,
        index = assocIndexOf$1(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$1(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$1.prototype.clear = listCacheClear$1;
  ListCache$1.prototype['delete'] = listCacheDelete$1;
  ListCache$1.prototype.get = listCacheGet$1;
  ListCache$1.prototype.has = listCacheHas$1;
  ListCache$1.prototype.set = listCacheSet$1;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache$1;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /* Built-in method references that are verified to be native. */
  var Map$3 = getNative$1(root$2, 'Map');

  /* Built-in method references that are verified to be native. */
  var nativeCreate$1 = getNative$1(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$1() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$7.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$3 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED$3 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$1(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$1.prototype.clear = hashClear$1;
  Hash$1.prototype['delete'] = hashDelete$1;
  Hash$1.prototype.get = hashGet$1;
  Hash$1.prototype.has = hashHas$1;
  Hash$1.prototype.set = hashSet$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash$1,
      'map': new (Map$3 || ListCache$1),
      'string': new Hash$1
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable$1(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$1(map, key) {
    var data = map.__data__;
    return isKeyable$1(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$1(key) {
    var result = getMapData$1(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$1(key) {
    return getMapData$1(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$1(key, value) {
    var data = getMapData$1(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$1(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$1.prototype.clear = mapCacheClear$1;
  MapCache$1.prototype['delete'] = mapCacheDelete$1;
  MapCache$1.prototype.get = mapCacheGet$1;
  MapCache$1.prototype.has = mapCacheHas$1;
  MapCache$1.prototype.set = mapCacheSet$1;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache$1) {
      var pairs = data.__data__;
      if (!Map$3 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache$1(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache$1(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty$3) {
      defineProperty$3(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq$1(object[key], value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer$1 = moduleExports ? root$2.Buffer : undefined,
      allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /** Built-in value references. */
  var Uint8Array$1 = root$2.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray$1(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject$2(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$a;

    return value === proto;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$1(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike$1(value) && baseGetTag$1(value) == argsTag;
  }

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$b.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$1 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike$1(value) && hasOwnProperty$9.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$2 = Array.isArray;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction$2(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike$1(value) && isArrayLike(value);
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Built-in value references. */
  var Buffer$2 = moduleExports$1 ? root$2.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /** `Object#toString` result references. */
  var objectTag = '[object Object]';

  /** Used for built-in method references. */
  var funcProto$4 = Function.prototype,
      objectProto$c = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$4 = funcProto$4.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString$4.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$a.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString$4.call(Ctor) == objectCtorString;
  }

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$2 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag$1 = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag$2] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike$1(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag$1(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports$2 && freeGlobal$1.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$2 && freeModule$2.require && freeModule$2.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /**
   * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
      return;
    }

    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  /** Used for built-in method references. */
  var objectProto$d = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$d.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$b.call(object, key) && eq$1(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$2 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$2 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /** Used for built-in method references. */
  var objectProto$e = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$c = objectProto$e.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$2(value),
        isArg = !isArr && isArguments$1(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$c.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$f = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$d = objectProto$f.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject$2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$d.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray$2(srcValue),
          isBuff = !isArr && isBuffer(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray$2(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject(objValue)) {
          newValue = copyArray$1(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
        newValue = objValue;
        if (isArguments$1(objValue)) {
          newValue = toPlainObject(objValue);
        }
        else if (!isObject$2(objValue) || isFunction$2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack);
      if (isObject$2(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }

  /**
   * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
   * objects into destination objects that are passed thru.
   *
   * @private
   * @param {*} objValue The destination value.
   * @param {*} srcValue The source value.
   * @param {string} key The key of the property to merge.
   * @param {Object} object The parent object of `objValue`.
   * @param {Object} source The parent object of `srcValue`.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   * @returns {*} Returns the value to assign.
   */
  function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
    if (isObject$2(objValue) && isObject$2(srcValue)) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, objValue);
      baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
      stack['delete'](srcValue);
    }
    return objValue;
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject$2(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq$1(object[index], value);
    }
    return false;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * This method is like `_.merge` except that it accepts `customizer` which
   * is invoked to produce the merged values of the destination and source
   * properties. If `customizer` returns `undefined`, merging is handled by the
   * method instead. The `customizer` is invoked with six arguments:
   * (objValue, srcValue, key, object, source, stack).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} customizer The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   if (_.isArray(objValue)) {
   *     return objValue.concat(srcValue);
   *   }
   * }
   *
   * var object = { 'a': [1], 'b': [2] };
   * var other = { 'a': [3], 'b': [4] };
   *
   * _.mergeWith(object, other, customizer);
   * // => { 'a': [1, 3], 'b': [2, 4] }
   */
  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
    baseMerge(object, source, srcIndex, customizer);
  });

  /**
   * This method is like `_.defaults` except that it recursively assigns
   * default properties.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.defaults
   * @example
   *
   * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
   * // => { 'a': { 'b': 2, 'c': 3 } }
   */
  var defaultsDeep = baseRest(function(args) {
    args.push(undefined, customDefaultsMerge);
    return apply(mergeWith, undefined, args);
  });

  var Route = function Route(options) {
    if ( options === void 0 ) options = {};

    defaultsDeep(this, options, {
      base: null,
      default: null,
      name: null,
      options: {
        bwd: false,
        clr: false,
        his: false,
        ins: true,
        ltr: false,
        mem: false,
        rtl: false
      },
      params: {},
      path: null
    });
  };

  Route.parse = function parse (route, router) {
    if (route instanceof Route) {
      return route;
    }

    if (typeof route === 'object') {
      return new Route(route);
    }

    if (typeof route === 'undefined') {
      return route;
    }

    var ref = route.split('@');
      var splitPath = ref[0];
      var splitName = ref[1]; if ( splitName === void 0 ) splitName = '';
    var ref$1 = splitPath.split(':');
      var path = ref$1[0];
      var rawParams = ref$1[1]; if ( rawParams === void 0 ) rawParams = '';
    var ref$2 = splitName.split(':');
      var name = ref$2[0];
      var rawOptions = ref$2[1]; if ( rawOptions === void 0 ) rawOptions = '';

    var options = {
      name: name,
      options: {},
      params: {},
      path: path
    };

    if (options.name === 'self') {
      options.name = router;
    }

    var optionNames = rawOptions ? rawOptions.split(';') : [];

    for (var i = 0; i < optionNames.length; i += 1) {
      options.options[optionNames[i]] = true;
    }

    var params = rawParams ? rawParams.split(';') : [];

    for (var i$1 = 0; i$1 < params.length; i$1 += 1) {
      var ref$3 = params[i$1].split('=');
        var paramName = ref$3[0];
        var paramValue = ref$3[1];
      options.params[paramName] = paramValue;
    }

    return new Route(options);
  };

  Route.prototype.format = function format (filter) {
    var string = '';

    string += this.path;
    string += this.formatParams();
    string += '@';
    string += this.name;
    string += this.formatOptions(filter);

    return string;
  };

  Route.prototype.formatOptions = function formatOptions (filter) {
      if ( filter === void 0 ) filter = [];

    var names = Object.keys(this.options);

    var string = '';
    var name = null;

    for (var i = 0; i < names.length; i += 1) {
      name = names[i];

      if (
        this.options[name] === true &&
        filter.indexOf(name) > -1
      ) {
        string += string.length === 0 ? ':' : ';';
        string += name;
      }
    }

    return string;
  };

  Route.prototype.formatParams = function formatParams () {
    var names = Object.keys(this.params);

    var string = '';
    var name = null;

    for (var i = 0; i < names.length; i += 1) {
      name = names[i];

      string += string.length === 0 ? ':' : ';';
      string += name + '=' + this.params[name];
    }

    return string;
  };

  Route.prototype.toJSON = function toJSON () {
    return this.format(['mem']);
  };

  var routers = {};

  var ViewRouter = /*@__PURE__*/(function (Router) {
    function ViewRouter(options) {
      if ( options === void 0 ) options = {};

      Router.call(this, options);

      this._base = null;
      this._default = null;
      this._global = null;
      this._history = null;
      this._name = null;
      this._stash = null;
      this._storage = null;

      this.setBase(options.base);
      this.setDefault(options.default);
      this.setGlobal(options.global);
      this.setHistory(options.history);
      this.setName(options.name);
      this.setStash(options.stash);
      this.setStorage(options.storage);

      this.loadHistory();

      routers[this._name] = this;
    }

    if ( Router ) ViewRouter.__proto__ = Router;
    ViewRouter.prototype = Object.create( Router && Router.prototype );
    ViewRouter.prototype.constructor = ViewRouter;

    ViewRouter.handle = function handle (box, data, route) {
      route = Route.parse(route, box.name);
      routers[route.name].handle(route, data);
    };

    ViewRouter.prototype.getBase = function getBase () {
      return this._base;
    };

    ViewRouter.prototype.setBase = function setBase (value) {
      if ( value === void 0 ) value = null;

      this._base = value;
      return this;
    };

    ViewRouter.prototype.getDefault = function getDefault () {
      return this._default;
    };

    ViewRouter.prototype.setDefault = function setDefault (value) {
      if ( value === void 0 ) value = null;

      this._default = value;
      return this;
    };

    ViewRouter.prototype.getGlobal = function getGlobal () {
      return this._global;
    };

    ViewRouter.prototype.setGlobal = function setGlobal (value) {
      if ( value === void 0 ) value = window;

      this._global = value;
      return this;
    };

    ViewRouter.prototype.getHistory = function getHistory () {
      return this._history;
    };

    ViewRouter.prototype.setHistory = function setHistory (value) {
      if ( value === void 0 ) value = [];

      this._history = value;
      return this;
    };

    ViewRouter.prototype.getName = function getName () {
      return this._name;
    };

    ViewRouter.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = null;

      this._name = value;
      return this;
    };

    ViewRouter.prototype.getStash = function getStash () {
      return this._stash;
    };

    ViewRouter.prototype.setStash = function setStash (value) {
      if ( value === void 0 ) value = null;

      this._stash = value;
      return this;
    };

    ViewRouter.prototype.getStorage = function getStorage () {
      return this._storage;
    };

    ViewRouter.prototype.setStorage = function setStorage (value) {
      if ( value === void 0 ) value = sessionStorage;

      this._storage = value;
      return this;
    };

    ViewRouter.prototype.act = function act (box, data, callback) {
      if (this._base.busy === true) {
        return;
      }

      this._base.busy = true;

      box = this.processHistory(box);
      box = this.processBackward(box);

      var routes = this.parseHash();

      if (box.path === false) {
        box = this.processDelete(box, routes);
      } else if (typeof this._workers[box.path] === 'undefined') {
        box = this.processDefault(box, routes);
      } else {
        box = this.processRoute(box, routes, box);
      }

      this.formatHash(routes);
      this.processForward(box);

      this.pass(box.path, box, data, callback);
    };

    ViewRouter.prototype.formatHash = function formatHash (routes) {
      var names = Object.keys(routes);
      var hash = '#';

      for (var i = 0; i < names.length; i += 1) {
        hash += '/' + routes[names[i]].format();
      }

      this._global.history.replaceState({}, '', hash);
    };

    ViewRouter.prototype.loadHistory = function loadHistory () {
      this._history = JSON.parse(
        this._storage.getItem('route-' + this._name) || '[]'
      ).map(function (route) { return Route.parse(route); });
    };

    ViewRouter.prototype.parseHash = function parseHash () {
      var hash = this._global.location.hash.slice(2);
      var parts = hash ? hash.split('/') : [];

      var routes = {};
      var route = null;

      for (var i = 0; i < parts.length; i += 1) {
        route = Route.parse(parts[i]);
        routes[route.name] = route;
      }

      return routes;
    };

    ViewRouter.prototype.processBackward = function processBackward (box) {
      if (box.options.bwd === false) {
        return box;
      }

      if (this._history.length < 2) {
        return box;
      }

      var current = this._history.pop();
      var previous = this._history.pop();

      if (current.options.mem || previous.options.mem) {
        previous.options = box.options;
        return previous;
      }

      return box;
    };

    ViewRouter.prototype.processDefault = function processDefault (box, routes) {
      var path = box.default || this._default;

      if (path === null) {
        return box;
      }

      return this.processRoute(box, routes, { path: path });
    };

    ViewRouter.prototype.processDelete = function processDelete (box, routes) {
      delete routes[this._name];

      if (this._base.snippet) {
        this._base.snippet.remove();
        this._base.snippet = null;
      }

      return box;
    };

    ViewRouter.prototype.processForward = function processForward (box) {
      if (box.options.clr === true) {
        this._history = [];
      }

      if (box.path) {
        this._history.push(box);
      }

      this.saveHistory();
    };

    ViewRouter.prototype.processHistory = function processHistory (box) {
      if (box.options.his === false) {
        return box;
      }

      if (this._history.length === 0) {
        return box;
      }

      return this._history.pop();
    };

    ViewRouter.prototype.processRoute = function processRoute (box, routes, from) {
      routes[this._name] = new Route({
        base: this._base,
        name: this._name,
        options: from.options,
        params: from.params,
        path: from.path
      });

      return routes[this._name];
    };

    ViewRouter.prototype.saveHistory = function saveHistory () {
      this._storage.setItem(
        'route-' + this._name,
        JSON.stringify(this._history)
      );
    };

    ViewRouter.prototype.stash = function stash () {
      var routes = this.parseHash();

      if (routes[this._name]) {
        this._stash = routes[this._name];
      }

      return this;
    };

    ViewRouter.prototype.unstash = function unstash () {
      var box = this._stash;
      this._stash = null;
      return box;
    };

    return ViewRouter;
  }(Router));

  var PopRouter = /*@__PURE__*/(function (ViewRouter) {
    function PopRouter () {
      ViewRouter.apply(this, arguments);
    }

    if ( ViewRouter ) PopRouter.__proto__ = ViewRouter;
    PopRouter.prototype = Object.create( ViewRouter && ViewRouter.prototype );
    PopRouter.prototype.constructor = PopRouter;

    PopRouter.prototype.act = function act (box, data, callback) {
      if (box.path !== false) {
        this.open(box);
      }

      ViewRouter.prototype.act.call(this, box, data, callback);
    };

    PopRouter.prototype.close = function close (box) {
      var this$1 = this;

      var base = select(this._base);
      var parent = select(this._base.parentNode);

      select(document).on('keydown.scola-pop', null);

      parent.style('width');

      parent
        .classed('in', false)
        .on('click.scola-pop', null)
        .on('transitionend.scola-pop', function () {
          parent
            .classed('open', false)
            .on('.scola-pop', null);

          box.path = false;
          this$1.act(box);
        });

      base.style('width');

      base
        .classed('in', false)
        .on('click.scola-pop', null);

      var duration = parseFloat(
        parent.style('transition-duration')
      );

      if (duration === 0) {
        parent.dispatch('transitionend');
      }
    };

    PopRouter.prototype.open = function open (box) {
      var this$1 = this;

      var base = select(this._base);
      var parent = select(this._base.parentNode);

      select(document).on('keydown.scola-pop', function () {
        if (event$1.keyCode === 27) {
          parent.dispatch('click');
        }
      });

      parent.classed('open', true);
      parent.style('width');

      parent
        .classed('in', true)
        .on('click.scola-pop', function () {
          if (box.lock !== true) {
            this$1.close(box);
          }
        });

      base.classed('move', box.move !== false);
      base.style('width');

      base
        .classed('in', true)
        .on('click.scola-pop', function () {
          event$1.stopPropagation();
        });
    };

    return PopRouter;
  }(ViewRouter));

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap$1(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /** `Object#toString` result references. */
  var symbolTag$1 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$3(value) {
    return typeof value == 'symbol' ||
      (isObjectLike$1(value) && baseGetTag$1(value) == symbolTag$1);
  }

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
      symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString$1(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$2(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap$1(value, baseToString$1) + '';
    }
    if (isSymbol$3(value)) {
      return symbolToString$1 ? symbolToString$1.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$1(value) {
    return value == null ? '' : baseToString$1(value);
  }

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice$1(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice$1(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : baseSlice$1(array, start, end);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$3 = '\\ud800-\\udfff',
      rsComboMarksRange$4 = '\\u0300-\\u036f',
      reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
      rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
      rsVarRange$3 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsZWJ$3 = '\\u200d';

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode$1 = RegExp('[' + rsZWJ$3 + rsAstralRange$3  + rsComboRange$4 + rsVarRange$3 + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode$1(string) {
    return reHasUnicode$1.test(string);
  }

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray$1(string) {
    return string.split('');
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$4 = '\\ud800-\\udfff',
      rsComboMarksRange$5 = '\\u0300-\\u036f',
      reComboHalfMarksRange$5 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$5 = '\\u20d0-\\u20ff',
      rsComboRange$5 = rsComboMarksRange$5 + reComboHalfMarksRange$5 + rsComboSymbolsRange$5,
      rsVarRange$4 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral$1 = '[' + rsAstralRange$4 + ']',
      rsCombo$3 = '[' + rsComboRange$5 + ']',
      rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
      rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
      rsNonAstral$2 = '[^' + rsAstralRange$4 + ']',
      rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$4 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod$2 = rsModifier$2 + '?',
      rsOptVar$2 = '[' + rsVarRange$4 + ']?',
      rsOptJoin$2 = '(?:' + rsZWJ$4 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
      rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
      rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray$1(string) {
    return string.match(reUnicode$1) || [];
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray$1(string) {
    return hasUnicode$1(string)
      ? unicodeToArray$1(string)
      : asciiToArray$1(string);
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst$1(methodName) {
    return function(string) {
      string = toString$1(string);

      var strSymbols = hasUnicode$1(string)
        ? stringToArray$1(string)
        : undefined;

      var chr = strSymbols
        ? strSymbols[0]
        : string.charAt(0);

      var trailing = strSymbols
        ? castSlice$1(strSymbols, 1).join('')
        : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst$1 = createCaseFirst$1('toUpperCase');

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize$1(string) {
    return upperFirst$1(toString$1(string).toLowerCase());
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce$1(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf$1(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters$1 = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter$1 = basePropertyOf$1(deburredLetters$1);

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin$1 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsComboMarksRange$6 = '\\u0300-\\u036f',
      reComboHalfMarksRange$6 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$6 = '\\u20d0-\\u20ff',
      rsComboRange$6 = rsComboMarksRange$6 + reComboHalfMarksRange$6 + rsComboSymbolsRange$6;

  /** Used to compose unicode capture groups. */
  var rsCombo$4 = '[' + rsComboRange$6 + ']';

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark$1 = RegExp(rsCombo$4, 'g');

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('déjà vu');
   * // => 'deja vu'
   */
  function deburr$1(string) {
    string = toString$1(string);
    return string && string.replace(reLatin$1, deburrLetter$1).replace(reComboMark$1, '');
  }

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord$1 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords$1(string) {
    return string.match(reAsciiWord$1) || [];
  }

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord$1 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord$1(string) {
    return reHasUnicodeWord$1.test(string);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$5 = '\\ud800-\\udfff',
      rsComboMarksRange$7 = '\\u0300-\\u036f',
      reComboHalfMarksRange$7 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$7 = '\\u20d0-\\u20ff',
      rsComboRange$7 = rsComboMarksRange$7 + reComboHalfMarksRange$7 + rsComboSymbolsRange$7,
      rsDingbatRange$1 = '\\u2700-\\u27bf',
      rsLowerRange$1 = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange$1 = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange$1 = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange$1 = '\\u2000-\\u206f',
      rsSpaceRange$1 = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange$1 = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange$5 = '\\ufe0e\\ufe0f',
      rsBreakRange$1 = rsMathOpRange$1 + rsNonCharRange$1 + rsPunctuationRange$1 + rsSpaceRange$1;

  /** Used to compose unicode capture groups. */
  var rsApos$2 = "['\u2019]",
      rsBreak$1 = '[' + rsBreakRange$1 + ']',
      rsCombo$5 = '[' + rsComboRange$7 + ']',
      rsDigits$1 = '\\d+',
      rsDingbat$1 = '[' + rsDingbatRange$1 + ']',
      rsLower$1 = '[' + rsLowerRange$1 + ']',
      rsMisc$1 = '[^' + rsAstralRange$5 + rsBreakRange$1 + rsDigits$1 + rsDingbatRange$1 + rsLowerRange$1 + rsUpperRange$1 + ']',
      rsFitz$3 = '\\ud83c[\\udffb-\\udfff]',
      rsModifier$3 = '(?:' + rsCombo$5 + '|' + rsFitz$3 + ')',
      rsNonAstral$3 = '[^' + rsAstralRange$5 + ']',
      rsRegional$3 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair$3 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper$1 = '[' + rsUpperRange$1 + ']',
      rsZWJ$5 = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower$1 = '(?:' + rsLower$1 + '|' + rsMisc$1 + ')',
      rsMiscUpper$1 = '(?:' + rsUpper$1 + '|' + rsMisc$1 + ')',
      rsOptContrLower$1 = '(?:' + rsApos$2 + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper$1 = '(?:' + rsApos$2 + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod$3 = rsModifier$3 + '?',
      rsOptVar$3 = '[' + rsVarRange$5 + ']?',
      rsOptJoin$3 = '(?:' + rsZWJ$5 + '(?:' + [rsNonAstral$3, rsRegional$3, rsSurrPair$3].join('|') + ')' + rsOptVar$3 + reOptMod$3 + ')*',
      rsOrdLower$1 = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper$1 = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq$3 = rsOptVar$3 + reOptMod$3 + rsOptJoin$3,
      rsEmoji$1 = '(?:' + [rsDingbat$1, rsRegional$3, rsSurrPair$3].join('|') + ')' + rsSeq$3;

  /** Used to match complex or compound words. */
  var reUnicodeWord$1 = RegExp([
    rsUpper$1 + '?' + rsLower$1 + '+' + rsOptContrLower$1 + '(?=' + [rsBreak$1, rsUpper$1, '$'].join('|') + ')',
    rsMiscUpper$1 + '+' + rsOptContrUpper$1 + '(?=' + [rsBreak$1, rsUpper$1 + rsMiscLower$1, '$'].join('|') + ')',
    rsUpper$1 + '?' + rsMiscLower$1 + '+' + rsOptContrLower$1,
    rsUpper$1 + '+' + rsOptContrUpper$1,
    rsOrdUpper$1,
    rsOrdLower$1,
    rsDigits$1,
    rsEmoji$1
  ].join('|'), 'g');

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords$1(string) {
    return string.match(reUnicodeWord$1) || [];
  }

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words$1(string, pattern, guard) {
    string = toString$1(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return hasUnicodeWord$1(string) ? unicodeWords$1(string) : asciiWords$1(string);
    }
    return string.match(pattern) || [];
  }

  /** Used to compose unicode capture groups. */
  var rsApos$3 = "['\u2019]";

  /** Used to match apostrophes. */
  var reApos$1 = RegExp(rsApos$3, 'g');

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder$1(callback) {
    return function(string) {
      return arrayReduce$1(words$1(deburr$1(string).replace(reApos$1, '')), callback, '');
    };
  }

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase$1 = createCompounder$1(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize$1(word) : word);
  });

  var id$3 = 0;

  var Snippet$1 = function Snippet(options) {
    if ( options === void 0 ) options = {};

    this._allow = null;
    this._args = null;
    this._builder = null;
    this._id = null;
    this._node = null;
    this._parent = null;

    this.setAllow(options.allow);
    this.setArgs(options.args);
    this.setBuilder(options.builder);
    this.setId(options.id);
    this.setNode(options.node);
    this.setParent(options.parent);
  };

  Snippet$1.attachFactories = function attachFactories () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

    Builder.attachFactories.apply(Builder, args);
  };

  Snippet$1.prototype.clone = function clone () {
    var options = this.getOptions();

    options.args = options.args.map(function (snippet) {
      return snippet instanceof Snippet$1 ?
        snippet.clone() : snippet;
    });

    return new this.constructor(options);
  };

  Snippet$1.prototype.getOptions = function getOptions () {
    return {
      allow: this._allow,
      args: this._args,
      builder: this._builder,
      id: this._id,
      parent: this._parent
    };
  };

  Snippet$1.prototype.getAllow = function getAllow () {
    return this._allow;
  };

  Snippet$1.prototype.setAllow = function setAllow (value) {
      if ( value === void 0 ) value = null;

    this._allow = value;
    return this;
  };

  Snippet$1.prototype.getArgs = function getArgs () {
    return this._args;
  };

  Snippet$1.prototype.setArgs = function setArgs (value) {
      if ( value === void 0 ) value = [];

    this._args = value;

    for (var i = 0; i < this._args.length; i += 1) {
      if (this._args[i] instanceof Snippet$1) {
        this._args[i].setParent(this);
      }
    }

    return this;
  };

  Snippet$1.prototype.getBuilder = function getBuilder () {
    return this._builder;
  };

  Snippet$1.prototype.setBuilder = function setBuilder (value) {
      if ( value === void 0 ) value = null;

    this._builder = value;
    return this;
  };

  Snippet$1.prototype.getId = function getId () {
    return this._id;
  };

  Snippet$1.prototype.setId = function setId (value) {
      if ( value === void 0 ) value = ++id$3;

    this._id = value;
    return this;
  };

  Snippet$1.prototype.getNode = function getNode () {
    return this._parent.getNode();
  };

  Snippet$1.prototype.setNode = function setNode (value) {
      if ( value === void 0 ) value = null;

    this._node = value;
    return this;
  };

  Snippet$1.prototype.getParent = function getParent () {
    return this._parent;
  };

  Snippet$1.prototype.setParent = function setParent (value) {
      if ( value === void 0 ) value = null;

    this._parent = value;
    return this;
  };

  Snippet$1.prototype.allow = function allow (value) {
    return this.setAllow(value);
  };

  Snippet$1.prototype.append = function append () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

    return this.setArgs(this._args.concat(args));
  };

  Snippet$1.prototype.id = function id (value) {
    return this.setId(value);
  };

  Snippet$1.prototype.node = function node () {
    return this.getNode();
  };

  Snippet$1.prototype.find = function find (compare) {
    var result = [];

    if (compare(this) === true) {
      result[result.length] = this;
    }

    return this.findRecursive(result, this._args, compare);
  };

  Snippet$1.prototype.findRecursive = function findRecursive (result, args, compare) {
    var snippet = null;

    for (var i = 0; i < args.length; i += 1) {
      snippet = args[i];

      if (snippet instanceof Snippet$1) {
        result = result.concat(snippet.find(compare));
      }
    }

    return result;
  };

  Snippet$1.prototype.isAllowed = function isAllowed (box, data) {
    return this.resolveValue(box, data, this._allow);
  };

  Snippet$1.prototype.remove = function remove () {
    this.removeBefore();
  };

  Snippet$1.prototype.removeAfter = function removeAfter () {};

  Snippet$1.prototype.removeBefore = function removeBefore () {
    this.removeOuter();
  };

  Snippet$1.prototype.removeInner = function removeInner () {
    for (var i = 0; i < this._args.length; i += 1) {
      this._args[i].remove();
    }

    this.removeAfter();
  };

  Snippet$1.prototype.removeOuter = function removeOuter () {
    this.removeInner();
  };

  Snippet$1.prototype.resolve = function resolve (box, data) {
    var isAllowed = this.isAllowed(box, data);

    if (isAllowed === false) {
      return null;
    }

    return this.resolveBefore(box, data);
  };

  Snippet$1.prototype.resolveAfter = function resolveAfter () {};

  Snippet$1.prototype.resolveBefore = function resolveBefore (box, data) {
    return this.resolveOuter(box, data);
  };

  Snippet$1.prototype.resolveInner = function resolveInner (box, data) {
    return this.resolveAfter(box, data);
  };

  Snippet$1.prototype.resolveOuter = function resolveOuter (box, data) {
    return this.resolveInner(box, data);
  };

  Snippet$1.prototype.resolveValue = function resolveValue (box, data, value) {
    if (value === null || typeof value === 'undefined') {
      return value;
    }

    if (typeof value === 'function') {
      return this.resolveValue(box, data, value(box, data));
    }

    if (value instanceof Snippet$1) {
      return this.resolveValue(box, data, value.resolve(box, data));
    }

    return value;
  };

  Snippet$1.prototype.resolveObject = function resolveObject (box, data, object, name) {
    object = this.resolveValue(box, data, object);
    return this.resolveValue(box, data, object[name]);
  };

  var Node$1 = /*@__PURE__*/(function (Snippet) {
    function Node(options) {
      if ( options === void 0 ) options = {};

      Snippet.call(this, options);

      this._name = null;
      this._transform = [];

      this.setName(options.name);
      this.setTransform(options.transform);

      if (options.class) {
        this.class(options.class);
      }
    }

    if ( Snippet ) Node.__proto__ = Snippet;
    Node.prototype = Object.create( Snippet && Snippet.prototype );
    Node.prototype.constructor = Node;

    Node.prototype.getOptions = function getOptions () {
      return Object.assign(Snippet.prototype.getOptions.call(this), {
        name: this._name,
        transform: this._transform
      });
    };

    Node.prototype.getName = function getName () {
      return this._name;
    };

    Node.prototype.getNode = function getNode () {
      return this._node;
    };

    Node.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = 'div';

      this._name = value;
      return this;
    };

    Node.prototype.getTransform = function getTransform () {
      return this._transform;
    };

    Node.prototype.setTransform = function setTransform (value) {
      if ( value === void 0 ) value = [];

      this._transform = value;
      return this;
    };

    Node.prototype.attributes = function attributes (values) {
      var this$1 = this;

      return this.transform(function (box, data, node) {
        this$1.resolveEach(box, data, values, function (key, value) {
          node.attr(key, value);
        });
      });
    };

    Node.prototype.classed = function classed (values) {
      var this$1 = this;

      return this.transform(function (box, data, node) {
        this$1.resolveEach(box, data, values, function (key, value) {
          node.classed(key, value);
        });
      });
    };

    Node.prototype.html = function html (value) {
      var this$1 = this;

      return this.transform(function (box, data, node) {
        node.html(this$1.resolveValue(box, data, value));
      });
    };

    Node.prototype.properties = function properties (values) {
      var this$1 = this;

      return this.transform(function (box, data, node) {
        this$1.resolveEach(box, data, values, function (key, value) {
          node.property(key, value);
        });
      });
    };

    Node.prototype.styles = function styles (values) {
      var this$1 = this;

      return this.transform(function (box, data, node) {
        this$1.resolveEach(box, data, values, function (key, value) {
          node.style(key, value);
        });
      });
    };

    Node.prototype.text = function text (value) {
      var this$1 = this;

      return this.transform(function (box, data, node) {
        node.text(this$1.resolveValue(box, data, value));
      });
    };

    Node.prototype.class = function class$1 (value) {
      var obj;

      return this.classed(( obj = {}, obj[value] = true, obj ));
    };

    Node.prototype.name = function name (value) {
      return this.setName(value);
    };

    Node.prototype.transform = function transform () {
      var transform = [], len = arguments.length;
      while ( len-- ) transform[ len ] = arguments[ len ];

      this._transform = this._transform.concat(transform);
      return this;
    };

    Node.prototype.createNode = function createNode () {
      this._node = this._parent === null ?
        select('body').append(this._name).remove() :
        this._parent.node().append(this._name);

      this._node.node().snippet = this;
    };

    Node.prototype.removeNode = function removeNode () {
      if (this._node === null) {
        return;
      }

      this._node.node().snippet = null;
      this._node.remove();
      this._node = null;
    };

    Node.prototype.wrapNode = function wrapNode (name) {
      var node = this._node.node();
      var wrapper = document.createElement(name);

      node.parentNode.insertBefore(wrapper, node);
      wrapper.appendChild(node);

      return select(wrapper);
    };

    Node.prototype.removeAfter = function removeAfter () {
      this.removeNode();
    };

    Node.prototype.resolve = function resolve (box, data) {
      var isAllowed = this.isAllowed(box, data);

      if (isAllowed === false) {
        return null;
      }

      if (this._node === null) {
        this.createNode();
      }

      return this.resolveBefore(box, data);
    };

    Node.prototype.resolveAfter = function resolveAfter () {
      return this._node;
    };

    Node.prototype.resolveAttribute = function resolveAttribute (box, data, name) {
      var node = this._node;

      if (node === null) {
        node = new Dummy();
        this.resolveTransform(box, data, node);
      }

      return node.attr(name);
    };

    Node.prototype.resolveBefore = function resolveBefore (box, data) {
      return this.resolveOuter(box, data);
    };

    Node.prototype.resolveEach = function resolveEach (box, data, object, callback) {
      object = this.resolveValue(box, data, object);

      var keys = Object.keys(object);
      var key = null;

      for (var i = 0; i < keys.length; i += 1) {
        key = keys[i];
        callback(key, this.resolveValue(box, data, object[key]));
      }
    };

    Node.prototype.resolveInner = function resolveInner (box, data) {
      for (var i = 0; i < this._args.length; i += 1) {
        this.resolveValue(box, data, this._args[i]);
      }

      return this.resolveAfter(box, data);
    };

    Node.prototype.resolveOuter = function resolveOuter (box, data) {
      this.resolveTransform(box, data, this._node);
      return this.resolveInner(box, data);
    };

    Node.prototype.resolveTransform = function resolveTransform (box, data, node) {
      for (var i = 0; i < this._transform.length; i += 1) {
        this._transform[i](box, data, node);
      }
    };

    return Node;
  }(Snippet$1));

  var clsBase = [
    'body',
    'bottom',
    'center',
    'comment',
    'footer',
    'graph',
    'group',
    'header',
    'icon',
    'item',
    'label',
    'left',
    'right',
    'title',
    'top'
  ];

  /*
  https://htmlreference.io/
  "{\n'" + Array.from(document.querySelectorAll('.item-name')).map((node) => node.innerText).join("',\n'") + "'\n}"

  https://developer.mozilla.org/en-US/docs/Web/SVG/Element
  "[\n'" + Array.from(document.querySelectorAll('.index li code')).map((node) => node.innerText.slice(1, -1)).join("',\n'") + "'\n]"
  */

  var domBase = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'meta',
    'meter',
    'nav',
    'noframes',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'rtc',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'slot',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr',

    'animate',
    'animateMotion',
    'animateTransform',
    'circle',
    'clipPath',
    'color-profile',
    'defs',
    'desc',
    'discard',
    'ellipse',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDistantLight',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence',
    'filter',
    'foreignObject',
    'g',
    'hatch',
    'hatchpath',
    'image',
    'line',
    'linearGradient',
    'marker',
    'mask',
    'mesh',
    'meshgradient',
    'meshpatch',
    'meshrow',
    'metadata',
    'mpath',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'set',
    'solidcolor',
    'stop',
    'svg',
    'switch',
    'symbol',
    'text',
    'textPath',
    'tspan',
    'unknown',
    'use',
    'view'
  ];

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$2 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal$2;

  /** Detect free variable `self`. */
  var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$3 = _freeGlobal || freeSelf$2 || Function('return this')();

  var _root = root$3;

  /** Built-in value references. */
  var Symbol$3 = _root.Symbol;

  var _Symbol = Symbol$3;

  /** Used for built-in method references. */
  var objectProto$g = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$e = objectProto$g.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$4 = objectProto$g.toString;

  /** Built-in value references. */
  var symToStringTag$4 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$2(value) {
    var isOwn = hasOwnProperty$e.call(value, symToStringTag$4),
        tag = value[symToStringTag$4];

    try {
      value[symToStringTag$4] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$4.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$4] = tag;
      } else {
        delete value[symToStringTag$4];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag$2;

  /** Used for built-in method references. */
  var objectProto$h = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$5 = objectProto$h.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$2(value) {
    return nativeObjectToString$5.call(value);
  }

  var _objectToString = objectToString$2;

  /** `Object#toString` result references. */
  var nullTag$2 = '[object Null]',
      undefinedTag$2 = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$5 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$2(value) {
    if (value == null) {
      return value === undefined ? undefinedTag$2 : nullTag$2;
    }
    return (symToStringTag$5 && symToStringTag$5 in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag$2;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$3(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1$1 = isObject$3;

  /** `Object#toString` result references. */
  var asyncTag$2 = '[object AsyncFunction]',
      funcTag$3 = '[object Function]',
      genTag$2 = '[object GeneratorFunction]',
      proxyTag$2 = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$3(value) {
    if (!isObject_1$1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag$3 || tag == genTag$2 || tag == asyncTag$2 || tag == proxyTag$2;
  }

  var isFunction_1 = isFunction$3;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$3 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$1(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$3;
  }

  var isLength_1 = isLength$1;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike$1(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike$1;

  var breakLoop = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // A temporary value used to identify if the loop should be broken.
  // See #1064, #1293
  exports.default = {};
  module.exports = exports["default"];
  });

  unwrapExports(breakLoop);

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop$3() {
    // No operation performed.
  }

  var noop_1$1 = noop$3;

  var once_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = once;
  function once(fn) {
      return function () {
          if (fn === null) { return; }
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
      };
  }
  module.exports = exports["default"];
  });

  unwrapExports(once_1);

  var getIterator = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  exports.default = function (coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
  };

  var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

  module.exports = exports['default'];
  });

  unwrapExports(getIterator);

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes$1(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes$1;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$2(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike$2;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments$1(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
  }

  var _baseIsArguments = baseIsArguments$1;

  /** Used for built-in method references. */
  var objectProto$i = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$f = objectProto$i.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$i.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$2 = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$f.call(value, 'callee') &&
      !propertyIsEnumerable$1.call(value, 'callee');
  };

  var isArguments_1 = isArguments$2;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$3 = Array.isArray;

  var isArray_1$1 = isArray$3;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse$1() {
    return false;
  }

  var stubFalse_1 = stubFalse$1;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports =  exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? _root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse_1;

  module.exports = isBuffer;
  });

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$4 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint$1 = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex$1(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$4 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint$1.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  var _isIndex = isIndex$1;

  /** `Object#toString` result references. */
  var argsTag$3 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$4 = '[object Function]',
      mapTag$1 = '[object Map]',
      numberTag$1 = '[object Number]',
      objectTag$2 = '[object Object]',
      regexpTag$1 = '[object RegExp]',
      setTag$1 = '[object Set]',
      stringTag$1 = '[object String]',
      weakMapTag$1 = '[object WeakMap]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags$1 = {};
  typedArrayTags$1[float32Tag$1] = typedArrayTags$1[float64Tag$1] =
  typedArrayTags$1[int8Tag$1] = typedArrayTags$1[int16Tag$1] =
  typedArrayTags$1[int32Tag$1] = typedArrayTags$1[uint8Tag$1] =
  typedArrayTags$1[uint8ClampedTag$1] = typedArrayTags$1[uint16Tag$1] =
  typedArrayTags$1[uint32Tag$1] = true;
  typedArrayTags$1[argsTag$3] = typedArrayTags$1[arrayTag$1] =
  typedArrayTags$1[arrayBufferTag$1] = typedArrayTags$1[boolTag$1] =
  typedArrayTags$1[dataViewTag$1] = typedArrayTags$1[dateTag$1] =
  typedArrayTags$1[errorTag$1] = typedArrayTags$1[funcTag$4] =
  typedArrayTags$1[mapTag$1] = typedArrayTags$1[numberTag$1] =
  typedArrayTags$1[objectTag$2] = typedArrayTags$1[regexpTag$1] =
  typedArrayTags$1[setTag$1] = typedArrayTags$1[stringTag$1] =
  typedArrayTags$1[weakMapTag$1] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray$1(value) {
    return isObjectLike_1(value) &&
      isLength_1(value.length) && !!typedArrayTags$1[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray$1;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary$1(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary$1;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  /** Detect free variable `exports`. */
  var freeExports =  exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && _freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  module.exports = nodeUtil;
  });

  /* Node.js helper references. */
  var nodeIsTypedArray$1 = _nodeUtil && _nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray$1 = nodeIsTypedArray$1 ? _baseUnary(nodeIsTypedArray$1) : _baseIsTypedArray;

  var isTypedArray_1 = isTypedArray$1;

  /** Used for built-in method references. */
  var objectProto$j = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$g = objectProto$j.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys$1(value, inherited) {
    var isArr = isArray_1$1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$g.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             _isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys$1;

  /** Used for built-in method references. */
  var objectProto$k = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype$1(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$k;

    return value === proto;
  }

  var _isPrototype = isPrototype$1;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg$1(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg$1;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = _overArg(Object.keys, Object);

  var _nativeKeys = nativeKeys;

  /** Used for built-in method references. */
  var objectProto$l = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$h = objectProto$l.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$h.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys$2(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys$2;

  var iterator_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = iterator;



  var _isArrayLike2 = _interopRequireDefault(isArrayLike_1);



  var _getIterator2 = _interopRequireDefault(getIterator);



  var _keys2 = _interopRequireDefault(keys_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
      };
  }

  function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
          var item = iterator.next();
          if (item.done) { return null; }
          i++;
          return { value: item.value, key: i };
      };
  }

  function createObjectIterator(obj) {
      var okeys = (0, _keys2.default)(obj);
      var i = -1;
      var len = okeys.length;
      return function next() {
          var key = okeys[++i];
          return i < len ? { value: obj[key], key: key } : null;
      };
  }

  function iterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
          return createArrayIterator(coll);
      }

      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
  }
  module.exports = exports['default'];
  });

  unwrapExports(iterator_1);

  var onlyOnce_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = onlyOnce;
  function onlyOnce(fn) {
      return function () {
          if (fn === null) { throw new Error("Callback was already called."); }
          var callFn = fn;
          fn = null;
          callFn.apply(this, arguments);
      };
  }
  module.exports = exports["default"];
  });

  unwrapExports(onlyOnce_1$1);

  var eachOfLimit = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = _eachOfLimit;



  var _noop2 = _interopRequireDefault(noop_1$1);



  var _once2 = _interopRequireDefault(once_1);



  var _iterator2 = _interopRequireDefault(iterator_1);



  var _onlyOnce2 = _interopRequireDefault(onlyOnce_1$1);



  var _breakLoop2 = _interopRequireDefault(breakLoop);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _eachOfLimit(limit) {
      return function (obj, iteratee, callback) {
          callback = (0, _once2.default)(callback || _noop2.default);
          if (limit <= 0 || !obj) {
              return callback(null);
          }
          var nextElem = (0, _iterator2.default)(obj);
          var done = false;
          var running = 0;
          var looping = false;

          function iterateeCallback(err, value) {
              running -= 1;
              if (err) {
                  done = true;
                  callback(err);
              } else if (value === _breakLoop2.default || done && running <= 0) {
                  done = true;
                  return callback(null);
              } else if (!looping) {
                  replenish();
              }
          }

          function replenish() {
              looping = true;
              while (running < limit && !done) {
                  var elem = nextElem();
                  if (elem === null) {
                      done = true;
                      if (running <= 0) {
                          callback(null);
                      }
                      return;
                  }
                  running += 1;
                  iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
              }
              looping = false;
          }

          replenish();
      };
  }
  module.exports = exports['default'];
  });

  unwrapExports(eachOfLimit);

  var slice_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = slice;
  function slice(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
          newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
  }
  module.exports = exports["default"];
  });

  unwrapExports(slice_1$1);

  var initialParams$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  exports.default = function (fn) {
      return function () /*...args, callback*/{
          var args = (0, _slice2.default)(arguments);
          var callback = args.pop();
          fn.call(this, args, callback);
      };
  };



  var _slice2 = _interopRequireDefault(slice_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  module.exports = exports['default'];
  });

  unwrapExports(initialParams$1);

  var setImmediate_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.hasNextTick = exports.hasSetImmediate = undefined;
  exports.fallback = fallback;
  exports.wrap = wrap;



  var _slice2 = _interopRequireDefault(slice_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
  var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

  function fallback(fn) {
      setTimeout(fn, 0);
  }

  function wrap(defer) {
      return function (fn /*, ...args*/) {
          var args = (0, _slice2.default)(arguments, 1);
          defer(function () {
              fn.apply(null, args);
          });
      };
  }

  var _defer;

  if (hasSetImmediate) {
      _defer = setImmediate;
  } else if (hasNextTick) {
      _defer = process.nextTick;
  } else {
      _defer = fallback;
  }

  exports.default = wrap(_defer);
  });

  unwrapExports(setImmediate_1$1);
  var setImmediate_2$1 = setImmediate_1$1.hasNextTick;
  var setImmediate_3$1 = setImmediate_1$1.hasSetImmediate;
  var setImmediate_4$1 = setImmediate_1$1.fallback;
  var setImmediate_5$1 = setImmediate_1$1.wrap;

  var asyncify_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = asyncify;



  var _isObject2 = _interopRequireDefault(isObject_1$1);



  var _initialParams2 = _interopRequireDefault(initialParams$1);



  var _setImmediate2 = _interopRequireDefault(setImmediate_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Take a sync function and make it async, passing its return value to a
   * callback. This is useful for plugging sync functions into a waterfall,
   * series, or other async functions. Any arguments passed to the generated
   * function will be passed to the wrapped function (except for the final
   * callback argument). Errors thrown will be passed to the callback.
   *
   * If the function passed to `asyncify` returns a Promise, that promises's
   * resolved/rejected state will be used to call the callback, rather than simply
   * the synchronous return value.
   *
   * This also means you can asyncify ES2017 `async` functions.
   *
   * @name asyncify
   * @static
   * @memberOf module:Utils
   * @method
   * @alias wrapSync
   * @category Util
   * @param {Function} func - The synchronous function, or Promise-returning
   * function to convert to an {@link AsyncFunction}.
   * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
   * invoked with `(args..., callback)`.
   * @example
   *
   * // passing a regular synchronous function
   * async.waterfall([
   *     async.apply(fs.readFile, filename, "utf8"),
   *     async.asyncify(JSON.parse),
   *     function (data, next) {
   *         // data is the result of parsing the text.
   *         // If there was a parsing error, it would have been caught.
   *     }
   * ], callback);
   *
   * // passing a function returning a promise
   * async.waterfall([
   *     async.apply(fs.readFile, filename, "utf8"),
   *     async.asyncify(function (contents) {
   *         return db.model.create(contents);
   *     }),
   *     function (model, next) {
   *         // `model` is the instantiated model object.
   *         // If there was an error, this function would be skipped.
   *     }
   * ], callback);
   *
   * // es2017 example, though `asyncify` is not needed if your JS environment
   * // supports async functions out of the box
   * var q = async.queue(async.asyncify(async function(file) {
   *     var intermediateStep = await processFile(file);
   *     return await somePromise(intermediateStep)
   * }));
   *
   * q.push(files);
   */
  function asyncify(func) {
      return (0, _initialParams2.default)(function (args, callback) {
          var result;
          try {
              result = func.apply(this, args);
          } catch (e) {
              return callback(e);
          }
          // if result is Promise object
          if ((0, _isObject2.default)(result) && typeof result.then === 'function') {
              result.then(function (value) {
                  invokeCallback(callback, null, value);
              }, function (err) {
                  invokeCallback(callback, err.message ? err : new Error(err));
              });
          } else {
              callback(null, result);
          }
      });
  }

  function invokeCallback(callback, error, value) {
      try {
          callback(error, value);
      } catch (e) {
          (0, _setImmediate2.default)(rethrow, e);
      }
  }

  function rethrow(error) {
      throw error;
  }
  module.exports = exports['default'];
  });

  unwrapExports(asyncify_1$1);

  var wrapAsync_1$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.isAsync = undefined;



  var _asyncify2 = _interopRequireDefault(asyncify_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var supportsSymbol = typeof Symbol === 'function';

  function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
  }

  function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  }

  exports.default = wrapAsync;
  exports.isAsync = isAsync;
  });

  unwrapExports(wrapAsync_1$1);
  var wrapAsync_2$1 = wrapAsync_1$1.isAsync;

  var eachOfLimit_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachOfLimit$1;



  var _eachOfLimit3 = _interopRequireDefault(eachOfLimit);



  var _wrapAsync2 = _interopRequireDefault(wrapAsync_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
   * time.
   *
   * @name eachOfLimit
   * @static
   * @memberOf module:Collections
   * @method
   * @see [async.eachOf]{@link module:Collections.eachOf}
   * @alias forEachOfLimit
   * @category Collection
   * @param {Array|Iterable|Object} coll - A collection to iterate over.
   * @param {number} limit - The maximum number of async operations at a time.
   * @param {AsyncFunction} iteratee - An async function to apply to each
   * item in `coll`. The `key` is the item's key, or index in the case of an
   * array.
   * Invoked with (item, key, callback).
   * @param {Function} [callback] - A callback which is called when all
   * `iteratee` functions have finished, or an error occurs. Invoked with (err).
   */
  function eachOfLimit$1(coll, limit, iteratee, callback) {
    (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  }
  module.exports = exports['default'];
  });

  unwrapExports(eachOfLimit_1);

  var doLimit_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = doLimit;
  function doLimit(fn, limit) {
      return function (iterable, iteratee, callback) {
          return fn(iterable, limit, iteratee, callback);
      };
  }
  module.exports = exports["default"];
  });

  unwrapExports(doLimit_1);

  var eachOf = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });

  exports.default = function (coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };



  var _isArrayLike2 = _interopRequireDefault(isArrayLike_1);



  var _breakLoop2 = _interopRequireDefault(breakLoop);



  var _eachOfLimit2 = _interopRequireDefault(eachOfLimit_1);



  var _doLimit2 = _interopRequireDefault(doLimit_1);



  var _noop2 = _interopRequireDefault(noop_1$1);



  var _once2 = _interopRequireDefault(once_1);



  var _onlyOnce2 = _interopRequireDefault(onlyOnce_1$1);



  var _wrapAsync2 = _interopRequireDefault(wrapAsync_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  // eachOf implementation optimized for array-likes
  function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      var index = 0,
          completed = 0,
          length = coll.length;
      if (length === 0) {
          callback(null);
      }

      function iteratorCallback(err, value) {
          if (err) {
              callback(err);
          } else if (++completed === length || value === _breakLoop2.default) {
              callback(null);
          }
      }

      for (; index < length; index++) {
          iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
  }

  // a generic version of eachOf which can handle array, object, and iterator cases.
  var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);

  /**
   * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
   * to the iteratee.
   *
   * @name eachOf
   * @static
   * @memberOf module:Collections
   * @method
   * @alias forEachOf
   * @category Collection
   * @see [async.each]{@link module:Collections.each}
   * @param {Array|Iterable|Object} coll - A collection to iterate over.
   * @param {AsyncFunction} iteratee - A function to apply to each
   * item in `coll`.
   * The `key` is the item's key, or index in the case of an array.
   * Invoked with (item, key, callback).
   * @param {Function} [callback] - A callback which is called when all
   * `iteratee` functions have finished, or an error occurs. Invoked with (err).
   * @example
   *
   * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
   * var configs = {};
   *
   * async.forEachOf(obj, function (value, key, callback) {
   *     fs.readFile(__dirname + value, "utf8", function (err, data) {
   *         if (err) return callback(err);
   *         try {
   *             configs[key] = JSON.parse(data);
   *         } catch (e) {
   *             return callback(e);
   *         }
   *         callback();
   *     });
   * }, function (err) {
   *     if (err) console.error(err.message);
   *     // configs is now a map of JSON data
   *     doSomethingWith(configs);
   * });
   */
  module.exports = exports['default'];
  });

  unwrapExports(eachOf);

  var parallel = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
      value: true
  });
  exports.default = _parallel;



  var _noop2 = _interopRequireDefault(noop_1$1);



  var _isArrayLike2 = _interopRequireDefault(isArrayLike_1);



  var _slice2 = _interopRequireDefault(slice_1$1);



  var _wrapAsync2 = _interopRequireDefault(wrapAsync_1$1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _parallel(eachfn, tasks, callback) {
      callback = callback || _noop2.default;
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

      eachfn(tasks, function (task, key, callback) {
          (0, _wrapAsync2.default)(task)(function (err, result) {
              if (arguments.length > 2) {
                  result = (0, _slice2.default)(arguments, 1);
              }
              results[key] = result;
              callback(err);
          });
      }, function (err) {
          callback(err, results);
      });
  }
  module.exports = exports['default'];
  });

  unwrapExports(parallel);

  var parallel$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parallelLimit;



  var _eachOf2 = _interopRequireDefault(eachOf);



  var _parallel2 = _interopRequireDefault(parallel);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Run the `tasks` collection of functions in parallel, without waiting until
   * the previous function has completed. If any of the functions pass an error to
   * its callback, the main `callback` is immediately called with the value of the
   * error. Once the `tasks` have completed, the results are passed to the final
   * `callback` as an array.
   *
   * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
   * parallel execution of code.  If your tasks do not use any timers or perform
   * any I/O, they will actually be executed in series.  Any synchronous setup
   * sections for each task will happen one after the other.  JavaScript remains
   * single-threaded.
   *
   * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
   * execution of other tasks when a task fails.
   *
   * It is also possible to use an object instead of an array. Each property will
   * be run as a function and the results will be passed to the final `callback`
   * as an object instead of an array. This can be a more readable way of handling
   * results from {@link async.parallel}.
   *
   * @name parallel
   * @static
   * @memberOf module:ControlFlow
   * @method
   * @category Control Flow
   * @param {Array|Iterable|Object} tasks - A collection of
   * [async functions]{@link AsyncFunction} to run.
   * Each async function can complete with any number of optional `result` values.
   * @param {Function} [callback] - An optional callback to run once all the
   * functions have completed successfully. This function gets a results array
   * (or object) containing all the result arguments passed to the task callbacks.
   * Invoked with (err, results).
   *
   * @example
   * async.parallel([
   *     function(callback) {
   *         setTimeout(function() {
   *             callback(null, 'one');
   *         }, 200);
   *     },
   *     function(callback) {
   *         setTimeout(function() {
   *             callback(null, 'two');
   *         }, 100);
   *     }
   * ],
   * // optional callback
   * function(err, results) {
   *     // the results array will equal ['one','two'] even though
   *     // the second function had a shorter timeout.
   * });
   *
   * // an example using an object instead of an array
   * async.parallel({
   *     one: function(callback) {
   *         setTimeout(function() {
   *             callback(null, 1);
   *         }, 200);
   *     },
   *     two: function(callback) {
   *         setTimeout(function() {
   *             callback(null, 2);
   *         }, 100);
   *     }
   * }, function(err, results) {
   *     // results is now equals to: {one: 1, two: 2}
   * });
   */
  function parallelLimit(tasks, callback) {
    (0, _parallel2.default)(_eachOf2.default, tasks, callback);
  }
  module.exports = exports['default'];
  });

  var parallel$2 = unwrapExports(parallel$1);

  var eachOfSeries = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });



  var _eachOfLimit2 = _interopRequireDefault(eachOfLimit_1);



  var _doLimit2 = _interopRequireDefault(doLimit_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
   *
   * @name eachOfSeries
   * @static
   * @memberOf module:Collections
   * @method
   * @see [async.eachOf]{@link module:Collections.eachOf}
   * @alias forEachOfSeries
   * @category Collection
   * @param {Array|Iterable|Object} coll - A collection to iterate over.
   * @param {AsyncFunction} iteratee - An async function to apply to each item in
   * `coll`.
   * Invoked with (item, key, callback).
   * @param {Function} [callback] - A callback which is called when all `iteratee`
   * functions have finished, or an error occurs. Invoked with (err).
   */
  exports.default = (0, _doLimit2.default)(_eachOfLimit2.default, 1);
  module.exports = exports['default'];
  });

  unwrapExports(eachOfSeries);

  var series_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = series;



  var _parallel2 = _interopRequireDefault(parallel);



  var _eachOfSeries2 = _interopRequireDefault(eachOfSeries);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  /**
   * Run the functions in the `tasks` collection in series, each one running once
   * the previous function has completed. If any functions in the series pass an
   * error to its callback, no more functions are run, and `callback` is
   * immediately called with the value of the error. Otherwise, `callback`
   * receives an array of results when `tasks` have completed.
   *
   * It is also possible to use an object instead of an array. Each property will
   * be run as a function, and the results will be passed to the final `callback`
   * as an object instead of an array. This can be a more readable way of handling
   *  results from {@link async.series}.
   *
   * **Note** that while many implementations preserve the order of object
   * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
   * explicitly states that
   *
   * > The mechanics and order of enumerating the properties is not specified.
   *
   * So if you rely on the order in which your series of functions are executed,
   * and want this to work on all platforms, consider using an array.
   *
   * @name series
   * @static
   * @memberOf module:ControlFlow
   * @method
   * @category Control Flow
   * @param {Array|Iterable|Object} tasks - A collection containing
   * [async functions]{@link AsyncFunction} to run in series.
   * Each function can complete with any number of optional `result` values.
   * @param {Function} [callback] - An optional callback to run once all the
   * functions have completed. This function gets a results array (or object)
   * containing all the result arguments passed to the `task` callbacks. Invoked
   * with (err, result).
   * @example
   * async.series([
   *     function(callback) {
   *         // do some stuff ...
   *         callback(null, 'one');
   *     },
   *     function(callback) {
   *         // do some more stuff ...
   *         callback(null, 'two');
   *     }
   * ],
   * // optional callback
   * function(err, results) {
   *     // results is now equal to ['one', 'two']
   * });
   *
   * async.series({
   *     one: function(callback) {
   *         setTimeout(function() {
   *             callback(null, 1);
   *         }, 200);
   *     },
   *     two: function(callback){
   *         setTimeout(function() {
   *             callback(null, 2);
   *         }, 100);
   *     }
   * }, function(err, results) {
   *     // results is now equal to: {one: 1, two: 2}
   * });
   */
  function series(tasks, callback) {
    (0, _parallel2.default)(_eachOfSeries2.default, tasks, callback);
  }
  module.exports = exports['default'];
  });

  var series = unwrapExports(series_1);

  var Action = /*@__PURE__*/(function (Snippet) {
    function Action(options) {
      if ( options === void 0 ) options = {};

      Snippet.call(this, options);

      this._act = null;
      this._err = null;
      this._ref = null;

      this.setAct(options.act);
      this.setErr(options.err);
      this.setRef(options.ref);
    }

    if ( Snippet ) Action.__proto__ = Snippet;
    Action.prototype = Object.create( Snippet && Snippet.prototype );
    Action.prototype.constructor = Action;

    Action.prototype.getOptions = function getOptions () {
      return Object.assign(Snippet.prototype.getOptions.call(this), {
        act: this._act,
        err: this._err,
        ref: this._ref
      });
    };

    Action.prototype.getAct = function getAct () {
      return this._act;
    };

    Action.prototype.setAct = function setAct (value) {
      if ( value === void 0 ) value = [];

      this._act = value;
      return this;
    };

    Action.prototype.getErr = function getErr () {
      return this._err;
    };

    Action.prototype.setErr = function setErr (value) {
      if ( value === void 0 ) value = [];

      this._err = value;
      return this;
    };

    Action.prototype.getRef = function getRef () {
      return this._ref;
    };

    Action.prototype.setRef = function setRef (value) {
      if ( value === void 0 ) value = [];

      this._ref = value;
      return this;
    };

    Action.prototype.act = function act () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return this.setAct(args);
    };

    Action.prototype.err = function err () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return this.setErr(args);
    };

    Action.prototype.ref = function ref () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return this.setRef(args);
    };

    Action.prototype.fail = function fail (box, error) {
      for (var i = 0; i < this._err.length; i += 1) {
        this.resolveValue(box, error, this._err[i]);
      }
    };

    Action.prototype.pass = function pass (box, data) {
      this.passAct(box, data);
      this.passRef(box, data);
    };

    Action.prototype.passAct = function passAct (box, data) {
      for (var i = 0; i < this._act.length; i += 1) {
        this.resolveValue(box, data, this._act[i]);
      }
    };

    Action.prototype.passRef = function passRef (box, data) {
      var ref = null;

      for (var i = 0; i < this._ref.length; i += 1) {
        ref = this.resolveValue(null, null, this._ref[i]);

        for (var j = 0; j < ref.length; j += 1) {
          ref[j].pass(box, data);
        }
      }
    };

    return Action;
  }(Snippet$1));

  var Async = /*@__PURE__*/(function (Action) {
    function Async(options) {
      if ( options === void 0 ) options = {};

      Action.call(this, options);

      this._handler = null;
      this.setHandler(options.handler);
    }

    if ( Action ) Async.__proto__ = Action;
    Async.prototype = Object.create( Action && Action.prototype );
    Async.prototype.constructor = Async;

    Async.prototype.getOptions = function getOptions () {
      return Object.assign(Action.prototype.getOptions.call(this), {
        handler: this._handler
      });
    };

    Async.prototype.getHandler = function getHandler () {
      return this._handler;
    };

    Async.prototype.setHandler = function setHandler (value) {
      if ( value === void 0 ) value = parallel$2;

      this._handler = value;
      return this;
    };

    Async.prototype.parallel = function parallel$1 () {
      return this.setHandler(parallel$2);
    };

    Async.prototype.series = function series$1 () {
      return this.setHandler(series);
    };

    Async.prototype.resolveAfter = function resolveAfter (box, data) {
      var this$1 = this;

      var fn = [];

      for (var i = 0; i < this._args.length; i += 1) {
        fn[fn.length] = this.asyncify(box, data, this._args[i]);
      }

      this._handler(fn, function (error, results) {
        if (error) {
          this$1.fail(box, error);
        } else {
          results = fn.length === 1 ? results[0] : results;
          this$1.pass(box, results);
        }
      });
    };

    Async.prototype.asyncify = function asyncify (box, data, snippet) {
      var this$1 = this;

      return function (callback) {
        snippet.act(function (b, result) {
          callback(null, result);
        });

        snippet.err(function (b, error) {
          callback(error);
        });

        this$1.resolveValue(box, data, snippet);
      };
    };

    return Async;
  }(Action));

  var PasswordChecker = /*@__PURE__*/(function (Worker) {
    function PasswordChecker () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) PasswordChecker.__proto__ = Worker;
    PasswordChecker.prototype = Object.create( Worker && Worker.prototype );
    PasswordChecker.prototype.constructor = PasswordChecker;

    PasswordChecker.prototype.act = function act (request, data, callback) {
      var this$1 = this;

      var password = data.password;
      var hash = request.user.getDetail('password') || '';

      request.user.unsetDetail('password');

      bcrypt.compare(password, hash, function (error, result) {
        if (error) {
          this$1.fail(request, error, callback);
          return;
        }

        if (result === false) {
          this$1.fail(
            request,
            new Error('401 Password is invalid'),
            callback
          );

          return;
        }

        this$1.pass(request, data, callback);
      });
    };

    PasswordChecker.prototype.decide = function decide (request) {
      if (request.user === null) {
        throw new Error('401 User not found');
      }

      return true;
    };

    return PasswordChecker;
  }(Worker));

  var RoleChecker = /*@__PURE__*/(function (Worker) {
    function RoleChecker () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) RoleChecker.__proto__ = Worker;
    RoleChecker.prototype = Object.create( Worker && Worker.prototype );
    RoleChecker.prototype.constructor = RoleChecker;

    RoleChecker.prototype.act = function act (request, data, callback) {
      if (this.filter(request, data) === false) {
        throw new Error('403 Role not allowed');
      }

      this.pass(request, data, callback);
    };

    return RoleChecker;
  }(Worker));

  var UserChecker = /*@__PURE__*/(function (Worker) {
    function UserChecker () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) UserChecker.__proto__ = Worker;
    UserChecker.prototype = Object.create( Worker && Worker.prototype );
    UserChecker.prototype.constructor = UserChecker;

    UserChecker.prototype.act = function act (request, data, callback) {
      if (request.user === null) {
        throw new Error('401 User not found');
      }

      this.pass(request, data, callback);
    };

    return UserChecker;
  }(Worker));

  var Header = function Header(options) {
    if ( options === void 0 ) options = {};

    this.name = options.name;
    this.value = options.value;
    this.values = options.values;
  };

  Header.parse = function parse (name, header) {
    if (typeof header === 'undefined') {
      return new Header({ name: name });
    }

    var parts = [];

    var char = null;
    var i = 0;
    var key = 0;
    var part = {};
    var value = '';

    for (; i <= header.length; i += 1) {
      char = header[i];

      if (char === ',' || i === header.length) {
        part[key] = value;
        parts.push(part);
        part = {};
        key = 0;
        value = '';
      } else if (char === ';') {
        part[key] = value;
        key = '';
        value = '';
      } else if (char === '=') {
        key = value;
        value = '';
      } else if (char === '"') {
        continue;
      } else if (char === ' ' && value === '') {
        continue;
      } else {
        value += char;
      }
    }

    var options = {
      name: name,
      value: parts[0],
      values: parts
    };

    return new Header(options);
  };

  Header.prototype.parseAcceptable = function parseAcceptable (base) {
      if ( base === void 0 ) base = '';

    var acceptable = this.values || [{ 0: base }];
    var entry = null;

    for (var i = 0; i < acceptable.length; i += 1) {
      entry = acceptable[i];

      entry.hq = typeof entry.q === 'undefined' ? 0 : 1;
      entry.q = entry.hq === 1 ? Number(entry.q) : 1;

      entry.s = 0;
      entry.s += (entry[0].match(/\*/g) || '').length;
      entry.s += Object.keys(entry).length - 4;
    }

    acceptable.sort(function (a, b) {
      return b.q - a.q || b.hq - a.hq || b.s - a.s || 0;
    });

    return acceptable;
  };

  var Message = function Message(options) {
    if ( options === void 0 ) options = {};

    this.body = {};
    this.extra = options.extra || {};
    this.headers = options.headers || {};
    this.parser = { begin: 0, end: 0 };
    this.protocol = {};
    this.socket = options.socket;
    this.state = options.state || {};
    this.timeout = options.timeout;
    this.timestamp = null;
    this.user = null;
  };

  Message.prototype.end = function end () {
    this.socket.removeAllListeners();
    this.socket.destroy();
  };

  Message.prototype.parseHeader = function parseHeader (name) {
    return Header.parse(name, this.headers[name]);
  };

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply$1(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$3(value) {
    return value;
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest$1(func, start, transform) {
    start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax$1(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply$1(func, this, otherArgs);
    };
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant$3(value) {
    return function() {
      return value;
    };
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$3 = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf$3 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$4 = freeGlobal$3 || freeSelf$3 || Function('return this')();

  /** Built-in value references. */
  var Symbol$4 = root$4.Symbol;

  /** Used for built-in method references. */
  var objectProto$m = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$i = objectProto$m.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$6 = objectProto$m.toString;

  /** Built-in value references. */
  var symToStringTag$6 = Symbol$4 ? Symbol$4.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$3(value) {
    var isOwn = hasOwnProperty$i.call(value, symToStringTag$6),
        tag = value[symToStringTag$6];

    try {
      value[symToStringTag$6] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$6.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$6] = tag;
      } else {
        delete value[symToStringTag$6];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$n = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$7 = objectProto$n.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$3(value) {
    return nativeObjectToString$7.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag$3 = '[object Null]',
      undefinedTag$3 = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$7 = Symbol$4 ? Symbol$4.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$3(value) {
    if (value == null) {
      return value === undefined ? undefinedTag$3 : nullTag$3;
    }
    return (symToStringTag$7 && symToStringTag$7 in Object(value))
      ? getRawTag$3(value)
      : objectToString$3(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$4(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag$3 = '[object AsyncFunction]',
      funcTag$5 = '[object Function]',
      genTag$3 = '[object GeneratorFunction]',
      proxyTag$3 = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$4(value) {
    if (!isObject$4(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$3(value);
    return tag == funcTag$5 || tag == genTag$3 || tag == asyncTag$3 || tag == proxyTag$3;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData$2 = root$4['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey$2 = (function() {
    var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$2(func) {
    return !!maskSrcKey$2 && (maskSrcKey$2 in func);
  }

  /** Used for built-in method references. */
  var funcProto$5 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$5 = funcProto$5.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$2(func) {
    if (func != null) {
      try {
        return funcToString$5.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar$2 = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$6 = Function.prototype,
      objectProto$o = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$6 = funcProto$6.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$j = objectProto$o.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative$2 = RegExp('^' +
    funcToString$6.call(hasOwnProperty$j).replace(reRegExpChar$2, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$2(value) {
    if (!isObject$4(value) || isMasked$2(value)) {
      return false;
    }
    var pattern = isFunction$4(value) ? reIsNative$2 : reIsHostCtor$2;
    return pattern.test(toSource$2(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$2(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$2(object, key) {
    var value = getValue$2(object, key);
    return baseIsNative$2(value) ? value : undefined;
  }

  var defineProperty$4 = (function() {
    try {
      var func = getNative$2(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString$1 = !defineProperty$4 ? identity$3 : function(func, string) {
    return defineProperty$4(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant$3(string),
      'writable': true
    });
  };

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT$1 = 800,
      HOT_SPAN$1 = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow$1 = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut$1(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow$1(),
          remaining = HOT_SPAN$1 - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT$1) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString$1 = shortOut$1(baseSetToString$1);

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest$1(func, start) {
    return setToString$1(overRest$1(func, start, identity$3), func + '');
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear$2() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq$2(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$2(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto$2 = Array.prototype;

  /** Built-in value references. */
  var splice$2 = arrayProto$2.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$2(key) {
    var data = this.__data__,
        index = assocIndexOf$2(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice$2.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$2(key) {
    var data = this.__data__,
        index = assocIndexOf$2(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$2(key) {
    return assocIndexOf$2(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$2(key, value) {
    var data = this.__data__,
        index = assocIndexOf$2(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$2(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$2.prototype.clear = listCacheClear$2;
  ListCache$2.prototype['delete'] = listCacheDelete$2;
  ListCache$2.prototype.get = listCacheGet$2;
  ListCache$2.prototype.has = listCacheHas$2;
  ListCache$2.prototype.set = listCacheSet$2;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear$1() {
    this.__data__ = new ListCache$2;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete$1(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet$1(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas$1(key) {
    return this.__data__.has(key);
  }

  /* Built-in method references that are verified to be native. */
  var Map$4 = getNative$2(root$4, 'Map');

  /* Built-in method references that are verified to be native. */
  var nativeCreate$2 = getNative$2(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$2() {
    this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete$2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$4 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$p = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$k = objectProto$p.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$2(key) {
    var data = this.__data__;
    if (nativeCreate$2) {
      var result = data[key];
      return result === HASH_UNDEFINED$4 ? undefined : result;
    }
    return hasOwnProperty$k.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$q = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$l = objectProto$q.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$2(key) {
    var data = this.__data__;
    return nativeCreate$2 ? (data[key] !== undefined) : hasOwnProperty$l.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$5 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate$2 && value === undefined) ? HASH_UNDEFINED$5 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$2(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$2.prototype.clear = hashClear$2;
  Hash$2.prototype['delete'] = hashDelete$2;
  Hash$2.prototype.get = hashGet$2;
  Hash$2.prototype.has = hashHas$2;
  Hash$2.prototype.set = hashSet$2;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$2() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash$2,
      'map': new (Map$4 || ListCache$2),
      'string': new Hash$2
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable$2(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$2(map, key) {
    var data = map.__data__;
    return isKeyable$2(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$2(key) {
    var result = getMapData$2(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$2(key) {
    return getMapData$2(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$2(key) {
    return getMapData$2(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$2(key, value) {
    var data = getMapData$2(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$2(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$2.prototype.clear = mapCacheClear$2;
  MapCache$2.prototype['delete'] = mapCacheDelete$2;
  MapCache$2.prototype.get = mapCacheGet$2;
  MapCache$2.prototype.has = mapCacheHas$2;
  MapCache$2.prototype.set = mapCacheSet$2;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE$1 = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet$1(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache$2) {
      var pairs = data.__data__;
      if (!Map$4 || (pairs.length < LARGE_ARRAY_SIZE$1 - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache$2(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack$1(entries) {
    var data = this.__data__ = new ListCache$2(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack$1.prototype.clear = stackClear$1;
  Stack$1.prototype['delete'] = stackDelete$1;
  Stack$1.prototype.get = stackGet$1;
  Stack$1.prototype.has = stackHas$1;
  Stack$1.prototype.set = stackSet$1;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue$1(object, key, value) {
    if (key == '__proto__' && defineProperty$4) {
      defineProperty$4(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue$1(object, key, value) {
    if ((value !== undefined && !eq$2(object[key], value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue$1(object, key, value);
    }
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor$1(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor$1 = createBaseFor$1();

  /** Detect free variable `exports`. */
  var freeExports$3 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$3 = freeExports$3 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$3 = freeModule$3 && freeModule$3.exports === freeExports$3;

  /** Built-in value references. */
  var Buffer$3 = moduleExports$3 ? root$4.Buffer : undefined,
      allocUnsafe$1 = Buffer$3 ? Buffer$3.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer$1(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe$1 ? allocUnsafe$1(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /** Built-in value references. */
  var Uint8Array$2 = root$4.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer$1(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray$1(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray$2(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /** Built-in value references. */
  var objectCreate$1 = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate$1 = (function() {
    function object() {}
    return function(proto) {
      if (!isObject$4(proto)) {
        return {};
      }
      if (objectCreate$1) {
        return objectCreate$1(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg$2(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /** Built-in value references. */
  var getPrototype$1 = overArg$2(Object.getPrototypeOf, Object);

  /** Used for built-in method references. */
  var objectProto$r = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype$2(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$r;

    return value === proto;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject$1(object) {
    return (typeof object.constructor == 'function' && !isPrototype$2(object))
      ? baseCreate$1(getPrototype$1(object))
      : {};
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$3(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var argsTag$4 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments$2(value) {
    return isObjectLike$3(value) && baseGetTag$3(value) == argsTag$4;
  }

  /** Used for built-in method references. */
  var objectProto$s = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$m = objectProto$s.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable$2 = objectProto$s.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$3 = baseIsArguments$2(function() { return arguments; }()) ? baseIsArguments$2 : function(value) {
    return isObjectLike$3(value) && hasOwnProperty$m.call(value, 'callee') &&
      !propertyIsEnumerable$2.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$4 = Array.isArray;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$5 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$2(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$5;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike$2(value) {
    return value != null && isLength$2(value.length) && !isFunction$4(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject$1(value) {
    return isObjectLike$3(value) && isArrayLike$2(value);
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse$2() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$4 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$4 = freeExports$4 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$4 = freeModule$4 && freeModule$4.exports === freeExports$4;

  /** Built-in value references. */
  var Buffer$4 = moduleExports$4 ? root$4.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer$1 = Buffer$4 ? Buffer$4.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer$1 = nativeIsBuffer$1 || stubFalse$2;

  /** `Object#toString` result references. */
  var objectTag$3 = '[object Object]';

  /** Used for built-in method references. */
  var funcProto$7 = Function.prototype,
      objectProto$t = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$7 = funcProto$7.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$n = objectProto$t.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString$1 = funcToString$7.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject$1(value) {
    if (!isObjectLike$3(value) || baseGetTag$3(value) != objectTag$3) {
      return false;
    }
    var proto = getPrototype$1(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$n.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString$7.call(Ctor) == objectCtorString$1;
  }

  /** `Object#toString` result references. */
  var argsTag$5 = '[object Arguments]',
      arrayTag$2 = '[object Array]',
      boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      errorTag$2 = '[object Error]',
      funcTag$6 = '[object Function]',
      mapTag$2 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$4 = '[object Object]',
      regexpTag$2 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$2 = '[object String]',
      weakMapTag$2 = '[object WeakMap]';

  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags$2 = {};
  typedArrayTags$2[float32Tag$2] = typedArrayTags$2[float64Tag$2] =
  typedArrayTags$2[int8Tag$2] = typedArrayTags$2[int16Tag$2] =
  typedArrayTags$2[int32Tag$2] = typedArrayTags$2[uint8Tag$2] =
  typedArrayTags$2[uint8ClampedTag$2] = typedArrayTags$2[uint16Tag$2] =
  typedArrayTags$2[uint32Tag$2] = true;
  typedArrayTags$2[argsTag$5] = typedArrayTags$2[arrayTag$2] =
  typedArrayTags$2[arrayBufferTag$2] = typedArrayTags$2[boolTag$2] =
  typedArrayTags$2[dataViewTag$2] = typedArrayTags$2[dateTag$2] =
  typedArrayTags$2[errorTag$2] = typedArrayTags$2[funcTag$6] =
  typedArrayTags$2[mapTag$2] = typedArrayTags$2[numberTag$2] =
  typedArrayTags$2[objectTag$4] = typedArrayTags$2[regexpTag$2] =
  typedArrayTags$2[setTag$2] = typedArrayTags$2[stringTag$2] =
  typedArrayTags$2[weakMapTag$2] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray$2(value) {
    return isObjectLike$3(value) &&
      isLength$2(value.length) && !!typedArrayTags$2[baseGetTag$3(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary$2(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports$5 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$5 = freeExports$5 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$5 = freeModule$5 && freeModule$5.exports === freeExports$5;

  /** Detect free variable `process` from Node.js. */
  var freeProcess$1 = moduleExports$5 && freeGlobal$3.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil$1 = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$5 && freeModule$5.require && freeModule$5.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess$1 && freeProcess$1.binding && freeProcess$1.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsTypedArray$2 = nodeUtil$1 && nodeUtil$1.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray$2 = nodeIsTypedArray$2 ? baseUnary$2(nodeIsTypedArray$2) : baseIsTypedArray$2;

  /**
   * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet$1(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
      return;
    }

    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  /** Used for built-in method references. */
  var objectProto$u = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$o = objectProto$u.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue$1(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$o.call(object, key) && eq$2(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue$1(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject$1(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue$1(object, key, newValue);
      } else {
        assignValue$1(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes$2(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$6 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint$2 = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex$2(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$6 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint$2.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /** Used for built-in method references. */
  var objectProto$v = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$p = objectProto$v.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys$2(value, inherited) {
    var isArr = isArray$4(value),
        isArg = !isArr && isArguments$3(value),
        isBuff = !isArr && !isArg && isBuffer$1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray$2(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes$2(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$p.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex$2(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn$1(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$w = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$q = objectProto$w.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn$1(object) {
    if (!isObject$4(object)) {
      return nativeKeysIn$1(object);
    }
    var isProto = isPrototype$2(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$q.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn$1(object) {
    return isArrayLike$2(object) ? arrayLikeKeys$2(object, true) : baseKeysIn$1(object);
  }

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject$1(value) {
    return copyObject$1(value, keysIn$1(value));
  }

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet$1(object, key),
        srcValue = safeGet$1(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue$1(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray$4(srcValue),
          isBuff = !isArr && isBuffer$1(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray$2(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray$4(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject$1(objValue)) {
          newValue = copyArray$2(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer$1(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray$1(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject$1(srcValue) || isArguments$3(srcValue)) {
        newValue = objValue;
        if (isArguments$3(objValue)) {
          newValue = toPlainObject$1(objValue);
        }
        else if (!isObject$4(objValue) || isFunction$4(objValue)) {
          newValue = initCloneObject$1(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    assignMergeValue$1(object, key, newValue);
  }

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge$1(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor$1(source, function(srcValue, key) {
      stack || (stack = new Stack$1);
      if (isObject$4(srcValue)) {
        baseMergeDeep$1(object, source, key, srcIndex, baseMerge$1, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(safeGet$1(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        assignMergeValue$1(object, key, newValue);
      }
    }, keysIn$1);
  }

  /**
   * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
   * objects into destination objects that are passed thru.
   *
   * @private
   * @param {*} objValue The destination value.
   * @param {*} srcValue The source value.
   * @param {string} key The key of the property to merge.
   * @param {Object} object The parent object of `objValue`.
   * @param {Object} source The parent object of `srcValue`.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   * @returns {*} Returns the value to assign.
   */
  function customDefaultsMerge$1(objValue, srcValue, key, object, source, stack) {
    if (isObject$4(objValue) && isObject$4(srcValue)) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, objValue);
      baseMerge$1(objValue, srcValue, undefined, customDefaultsMerge$1, stack);
      stack['delete'](srcValue);
    }
    return objValue;
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall$1(value, index, object) {
    if (!isObject$4(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike$2(object) && isIndex$2(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq$2(object[index], value);
    }
    return false;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner$1(assigner) {
    return baseRest$1(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall$1(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * This method is like `_.merge` except that it accepts `customizer` which
   * is invoked to produce the merged values of the destination and source
   * properties. If `customizer` returns `undefined`, merging is handled by the
   * method instead. The `customizer` is invoked with six arguments:
   * (objValue, srcValue, key, object, source, stack).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} customizer The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   if (_.isArray(objValue)) {
   *     return objValue.concat(srcValue);
   *   }
   * }
   *
   * var object = { 'a': [1], 'b': [2] };
   * var other = { 'a': [3], 'b': [4] };
   *
   * _.mergeWith(object, other, customizer);
   * // => { 'a': [1, 3], 'b': [2, 4] }
   */
  var mergeWith$1 = createAssigner$1(function(object, source, srcIndex, customizer) {
    baseMerge$1(object, source, srcIndex, customizer);
  });

  /**
   * This method is like `_.defaults` except that it recursively assigns
   * default properties.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.defaults
   * @example
   *
   * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
   * // => { 'a': { 'b': 2, 'c': 3 } }
   */
  var defaultsDeep$1 = baseRest$1(function(args) {
    args.push(undefined, customDefaultsMerge$1);
    return apply$1(mergeWith$1, undefined, args);
  });

  var Response = /*@__PURE__*/(function (Message) {
    function Response(options) {
      if ( options === void 0 ) options = {};

      Message.call(this, options);

      this.request = options.request;
      this.status = options.status;

      var connection = this.request.headers.connection;

      if (typeof connection !== 'undefined') {
        this.headers.connection = connection;
      }

      var setCookie = this.request.headers['set-cookie'];

      if (typeof setCookie !== 'undefined') {
        this.headers['set-cookie'] = setCookie;
      }
    }

    if ( Message ) Response.__proto__ = Message;
    Response.prototype = Object.create( Message && Message.prototype );
    Response.prototype.constructor = Response;

    Response.prototype.createResponse = function createResponse () {
      return this;
    };

    Response.prototype.mustEnd = function mustEnd () {
      return this.headers.connection === 'close';
    };

    return Response;
  }(Message));

  var has$2 = Object.prototype.hasOwnProperty;
  var isArray$5 = Array.isArray;

  var hexTable = (function () {
      var array = [];
      for (var i = 0; i < 256; ++i) {
          array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
      }

      return array;
  }());

  var compactQueue = function compactQueue(queue) {
      while (queue.length > 1) {
          var item = queue.pop();
          var obj = item.obj[item.prop];

          if (isArray$5(obj)) {
              var compacted = [];

              for (var j = 0; j < obj.length; ++j) {
                  if (typeof obj[j] !== 'undefined') {
                      compacted.push(obj[j]);
                  }
              }

              item.obj[item.prop] = compacted;
          }
      }
  };

  var arrayToObject = function arrayToObject(source, options) {
      var obj = options && options.plainObjects ? Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
          if (typeof source[i] !== 'undefined') {
              obj[i] = source[i];
          }
      }

      return obj;
  };

  var merge = function merge(target, source, options) {
      if (!source) {
          return target;
      }

      if (typeof source !== 'object') {
          if (isArray$5(target)) {
              target.push(source);
          } else if (target && typeof target === 'object') {
              if ((options && (options.plainObjects || options.allowPrototypes)) || !has$2.call(Object.prototype, source)) {
                  target[source] = true;
              }
          } else {
              return [target, source];
          }

          return target;
      }

      if (!target || typeof target !== 'object') {
          return [target].concat(source);
      }

      var mergeTarget = target;
      if (isArray$5(target) && !isArray$5(source)) {
          mergeTarget = arrayToObject(target, options);
      }

      if (isArray$5(target) && isArray$5(source)) {
          source.forEach(function (item, i) {
              if (has$2.call(target, i)) {
                  var targetItem = target[i];
                  if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                      target[i] = merge(targetItem, item, options);
                  } else {
                      target.push(item);
                  }
              } else {
                  target[i] = item;
              }
          });
          return target;
      }

      return Object.keys(source).reduce(function (acc, key) {
          var value = source[key];

          if (has$2.call(acc, key)) {
              acc[key] = merge(acc[key], value, options);
          } else {
              acc[key] = value;
          }
          return acc;
      }, mergeTarget);
  };

  var assign$2 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function (acc, key) {
          acc[key] = source[key];
          return acc;
      }, target);
  };

  var decode = function (str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, ' ');
      if (charset === 'iso-8859-1') {
          // unescape never throws, no try...catch needed:
          return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      // utf-8
      try {
          return decodeURIComponent(strWithoutPlus);
      } catch (e) {
          return strWithoutPlus;
      }
  };

  var encode = function encode(str, defaultEncoder, charset) {
      // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
      // It has been adapted here for stricter adherence to RFC 3986
      if (str.length === 0) {
          return str;
      }

      var string = typeof str === 'string' ? str : String(str);

      if (charset === 'iso-8859-1') {
          return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
              return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
          });
      }

      var out = '';
      for (var i = 0; i < string.length; ++i) {
          var c = string.charCodeAt(i);

          if (
              c === 0x2D // -
              || c === 0x2E // .
              || c === 0x5F // _
              || c === 0x7E // ~
              || (c >= 0x30 && c <= 0x39) // 0-9
              || (c >= 0x41 && c <= 0x5A) // a-z
              || (c >= 0x61 && c <= 0x7A) // A-Z
          ) {
              out += string.charAt(i);
              continue;
          }

          if (c < 0x80) {
              out = out + hexTable[c];
              continue;
          }

          if (c < 0x800) {
              out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
              continue;
          }

          if (c < 0xD800 || c >= 0xE000) {
              out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
              continue;
          }

          i += 1;
          c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
          out += hexTable[0xF0 | (c >> 18)]
              + hexTable[0x80 | ((c >> 12) & 0x3F)]
              + hexTable[0x80 | ((c >> 6) & 0x3F)]
              + hexTable[0x80 | (c & 0x3F)];
      }

      return out;
  };

  var compact = function compact(value) {
      var queue = [{ obj: { o: value }, prop: 'o' }];
      var refs = [];

      for (var i = 0; i < queue.length; ++i) {
          var item = queue[i];
          var obj = item.obj[item.prop];

          var keys = Object.keys(obj);
          for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              var val = obj[key];
              if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                  queue.push({ obj: obj, prop: key });
                  refs.push(val);
              }
          }
      }

      compactQueue(queue);

      return value;
  };

  var isRegExp = function isRegExp(obj) {
      return Object.prototype.toString.call(obj) === '[object RegExp]';
  };

  var isBuffer$2 = function isBuffer(obj) {
      if (!obj || typeof obj !== 'object') {
          return false;
      }

      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };

  var combine = function combine(a, b) {
      return [].concat(a, b);
  };

  var utils = {
      arrayToObject: arrayToObject,
      assign: assign$2,
      combine: combine,
      compact: compact,
      decode: decode,
      encode: encode,
      isBuffer: isBuffer$2,
      isRegExp: isRegExp,
      merge: merge
  };

  var replace$3 = String.prototype.replace;
  var percentTwenties = /%20/g;

  var formats = {
      'default': 'RFC3986',
      formatters: {
          RFC1738: function (value) {
              return replace$3.call(value, percentTwenties, '+');
          },
          RFC3986: function (value) {
              return value;
          }
      },
      RFC1738: 'RFC1738',
      RFC3986: 'RFC3986'
  };

  var has$3 = Object.prototype.hasOwnProperty;

  var arrayPrefixGenerators = {
      brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
          return prefix + '[]';
      },
      comma: 'comma',
      indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
          return prefix + '[' + key + ']';
      },
      repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
          return prefix;
      }
  };

  var isArray$6 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function (arr, valueOrArray) {
      push.apply(arr, isArray$6(valueOrArray) ? valueOrArray : [valueOrArray]);
  };

  var toISO = Date.prototype.toISOString;

  var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: 'utf-8',
      charsetSentinel: false,
      delimiter: '&',
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      formatter: formats.formatters[formats['default']],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
          return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
  };

  var stringify = function stringify( // eslint-disable-line func-name-matching
      object,
      prefix,
      generateArrayPrefix,
      strictNullHandling,
      skipNulls,
      encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      formatter,
      encodeValuesOnly,
      charset
  ) {
      var obj = object;
      if (typeof filter === 'function') {
          obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
          obj = serializeDate(obj);
      } else if (generateArrayPrefix === 'comma' && isArray$6(obj)) {
          obj = obj.join(',');
      }

      if (obj === null) {
          if (strictNullHandling) {
              return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
          }

          obj = '';
      }

      if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
          if (encoder) {
              var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
              return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
          }
          return [formatter(prefix) + '=' + formatter(String(obj))];
      }

      var values = [];

      if (typeof obj === 'undefined') {
          return values;
      }

      var objKeys;
      if (isArray$6(filter)) {
          objKeys = filter;
      } else {
          var keys = Object.keys(obj);
          objKeys = sort ? keys.sort(sort) : keys;
      }

      for (var i = 0; i < objKeys.length; ++i) {
          var key = objKeys[i];

          if (skipNulls && obj[key] === null) {
              continue;
          }

          if (isArray$6(obj)) {
              pushToArray(values, stringify(
                  obj[key],
                  typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                  generateArrayPrefix,
                  strictNullHandling,
                  skipNulls,
                  encoder,
                  filter,
                  sort,
                  allowDots,
                  serializeDate,
                  formatter,
                  encodeValuesOnly,
                  charset
              ));
          } else {
              pushToArray(values, stringify(
                  obj[key],
                  prefix + (allowDots ? '.' + key : '[' + key + ']'),
                  generateArrayPrefix,
                  strictNullHandling,
                  skipNulls,
                  encoder,
                  filter,
                  sort,
                  allowDots,
                  serializeDate,
                  formatter,
                  encodeValuesOnly,
                  charset
              ));
          }
      }

      return values;
  };

  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
      if (!opts) {
          return defaults;
      }

      if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
          throw new TypeError('Encoder has to be a function.');
      }

      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
          throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
      }

      var format = formats['default'];
      if (typeof opts.format !== 'undefined') {
          if (!has$3.call(formats.formatters, opts.format)) {
              throw new TypeError('Unknown format option provided.');
          }
          format = opts.format;
      }
      var formatter = formats.formatters[format];

      var filter = defaults.filter;
      if (typeof opts.filter === 'function' || isArray$6(opts.filter)) {
          filter = opts.filter;
      }

      return {
          addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
          allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
          charset: charset,
          charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
          delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
          encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
          encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
          encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
          filter: filter,
          formatter: formatter,
          serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
          skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
          sort: typeof opts.sort === 'function' ? opts.sort : null,
          strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
      };
  };

  var stringify_1 = function (object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);

      var objKeys;
      var filter;

      if (typeof options.filter === 'function') {
          filter = options.filter;
          obj = filter('', obj);
      } else if (isArray$6(options.filter)) {
          filter = options.filter;
          objKeys = filter;
      }

      var keys = [];

      if (typeof obj !== 'object' || obj === null) {
          return '';
      }

      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
          arrayFormat = opts.arrayFormat;
      } else if (opts && 'indices' in opts) {
          arrayFormat = opts.indices ? 'indices' : 'repeat';
      } else {
          arrayFormat = 'indices';
      }

      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

      if (!objKeys) {
          objKeys = Object.keys(obj);
      }

      if (options.sort) {
          objKeys.sort(options.sort);
      }

      for (var i = 0; i < objKeys.length; ++i) {
          var key = objKeys[i];

          if (options.skipNulls && obj[key] === null) {
              continue;
          }
          pushToArray(keys, stringify(
              obj[key],
              key,
              generateArrayPrefix,
              options.strictNullHandling,
              options.skipNulls,
              options.encode ? options.encoder : null,
              options.filter,
              options.sort,
              options.allowDots,
              options.serializeDate,
              options.formatter,
              options.encodeValuesOnly,
              options.charset
          ));
      }

      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? '?' : '';

      if (options.charsetSentinel) {
          if (options.charset === 'iso-8859-1') {
              // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
              prefix += 'utf8=%26%2310003%3B&';
          } else {
              // encodeURIComponent('✓')
              prefix += 'utf8=%E2%9C%93&';
          }
      }

      return joined.length > 0 ? prefix + joined : '';
  };

  var has$4 = Object.prototype.hasOwnProperty;

  var defaults$1 = {
      allowDots: false,
      allowPrototypes: false,
      arrayLimit: 20,
      charset: 'utf-8',
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: '&',
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1000,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
  };

  var interpretNumericEntities = function (str) {
      return str.replace(/&#(\d+);/g, function ($0, numberStr) {
          return String.fromCharCode(parseInt(numberStr, 10));
      });
  };

  // This is what browsers will submit when the ✓ character occurs in an
  // application/x-www-form-urlencoded body and the encoding of the page containing
  // the form is iso-8859-1, or when the submitted form has an accept-charset
  // attribute of iso-8859-1. Presumably also with other charsets that do not contain
  // the ✓ character, such as us-ascii.
  var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

  // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
  var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

  var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
      var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1; // Keep track of where the utf8 sentinel was found
      var i;

      var charset = options.charset;
      if (options.charsetSentinel) {
          for (i = 0; i < parts.length; ++i) {
              if (parts[i].indexOf('utf8=') === 0) {
                  if (parts[i] === charsetSentinel) {
                      charset = 'utf-8';
                  } else if (parts[i] === isoSentinel) {
                      charset = 'iso-8859-1';
                  }
                  skipIndex = i;
                  i = parts.length; // The eslint settings do not allow break;
              }
          }
      }

      for (i = 0; i < parts.length; ++i) {
          if (i === skipIndex) {
              continue;
          }
          var part = parts[i];

          var bracketEqualsPos = part.indexOf(']=');
          var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

          var key, val;
          if (pos === -1) {
              key = options.decoder(part, defaults$1.decoder, charset);
              val = options.strictNullHandling ? null : '';
          } else {
              key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset);
              val = options.decoder(part.slice(pos + 1), defaults$1.decoder, charset);
          }

          if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
              val = interpretNumericEntities(val);
          }

          if (val && options.comma && val.indexOf(',') > -1) {
              val = val.split(',');
          }

          if (has$4.call(obj, key)) {
              obj[key] = utils.combine(obj[key], val);
          } else {
              obj[key] = val;
          }
      }

      return obj;
  };

  var parseObject = function (chain, val, options) {
      var leaf = val;

      for (var i = chain.length - 1; i >= 0; --i) {
          var obj;
          var root = chain[i];

          if (root === '[]' && options.parseArrays) {
              obj = [].concat(leaf);
          } else {
              obj = options.plainObjects ? Object.create(null) : {};
              var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
              var index = parseInt(cleanRoot, 10);
              if (!options.parseArrays && cleanRoot === '') {
                  obj = { 0: leaf };
              } else if (
                  !isNaN(index)
                  && root !== cleanRoot
                  && String(index) === cleanRoot
                  && index >= 0
                  && (options.parseArrays && index <= options.arrayLimit)
              ) {
                  obj = [];
                  obj[index] = leaf;
              } else {
                  obj[cleanRoot] = leaf;
              }
          }

          leaf = obj;
      }

      return leaf;
  };

  var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
      if (!givenKey) {
          return;
      }

      // Transform dot notation to bracket notation
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

      // The regex chunks

      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;

      // Get the parent

      var segment = brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;

      // Stash the parent if it exists

      var keys = [];
      if (parent) {
          // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
          if (!options.plainObjects && has$4.call(Object.prototype, parent)) {
              if (!options.allowPrototypes) {
                  return;
              }
          }

          keys.push(parent);
      }

      // Loop through children appending to the array until we hit depth

      var i = 0;
      while ((segment = child.exec(key)) !== null && i < options.depth) {
          i += 1;
          if (!options.plainObjects && has$4.call(Object.prototype, segment[1].slice(1, -1))) {
              if (!options.allowPrototypes) {
                  return;
              }
          }
          keys.push(segment[1]);
      }

      // If there's a remainder, just add whatever is left

      if (segment) {
          keys.push('[' + key.slice(segment.index) + ']');
      }

      return parseObject(keys, val, options);
  };

  var normalizeParseOptions = function normalizeParseOptions(opts) {
      if (!opts) {
          return defaults$1;
      }

      if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
          throw new TypeError('Decoder has to be a function.');
      }

      if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
          throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
      }
      var charset = typeof opts.charset === 'undefined' ? defaults$1.charset : opts.charset;

      return {
          allowDots: typeof opts.allowDots === 'undefined' ? defaults$1.allowDots : !!opts.allowDots,
          allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults$1.allowPrototypes,
          arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults$1.arrayLimit,
          charset: charset,
          charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
          comma: typeof opts.comma === 'boolean' ? opts.comma : defaults$1.comma,
          decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults$1.decoder,
          delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
          depth: typeof opts.depth === 'number' ? opts.depth : defaults$1.depth,
          ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
          interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
          parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults$1.parameterLimit,
          parseArrays: opts.parseArrays !== false,
          plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults$1.plainObjects,
          strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling
      };
  };

  var parse = function (str, opts) {
      var options = normalizeParseOptions(opts);

      if (str === '' || str === null || typeof str === 'undefined') {
          return options.plainObjects ? Object.create(null) : {};
      }

      var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
      var obj = options.plainObjects ? Object.create(null) : {};

      // Iterate over the keys and setup the new object

      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var newObj = parseKeys(key, tempObj[key], options);
          obj = utils.merge(obj, newObj, options);
      }

      return utils.compact(obj);
  };

  var lib = {
      formats: formats,
      parse: parse,
      stringify: stringify_1
  };

  var Url = function Url(options) {
    defaultsDeep$1(this, options, {
      auth: null,
      hostname: null,
      path: null,
      port: options.scheme === 'http' ? 80 : 443,
      query: null,
      scheme: 'https'
    });
  };

  Url.parse = function parse (url) {
    if (url instanceof Url) {
      return url;
    }

    if (typeof url === 'object') {
      return new Url(url);
    }

    if (typeof url === 'undefined') {
      return url;
    }

    var options = {};

    var authPos = null;
    var pathPos = null;
    var portPos = null;
    var queryPos = null;
    var schemePos = null;

    var begin = 0;
    var end = 0;

    var char = '';

    for (; end < url.length; end += 1) {
      char = url[end];

      if (char === ':') {
        if (schemePos === null) {
          schemePos = end;
          end += 3;
        } else {
          portPos = end;
        }
      } else if (char === '/') {
        if (pathPos === null) {
          pathPos = end;
        }
      } else if (char === '@') {
        if (pathPos === null) {
          authPos = end;
        }
      } else if (char === '?') {
        queryPos = end;
        break;
      }
    }

    if (pathPos === null) {
      pathPos = url.length;
    }

    if (schemePos !== null) {
      options.scheme = url.slice(begin, schemePos);
      begin = schemePos + 3;
    }

    if (authPos !== null) {
      options.auth = url.slice(begin, authPos);
      begin = authPos + 1;
    }

    if (portPos !== null) {
      options.port = url.slice(portPos + 1, pathPos);
    }

    if (begin > 0) {
      options.hostname = url.slice(begin, portPos || pathPos);
      begin = pathPos;
    }

    if (queryPos !== null) {
      options.query = lib.parse(url.slice(queryPos + 1));
    } else {
      options.query = {};
    }

    options.path = url.slice(pathPos, queryPos || url.length);

    return new Url(options);
  };

  Url.prototype.format = function format () {
    var string = '';

    string += this.formatScheme();
    string += this.formatAuth();
    string += this.formatHost();
    string += this.formatPath();

    return string;
  };

  Url.prototype.formatAuth = function formatAuth () {
    return this.auth ? this.auth + '@' : '';
  };

  Url.prototype.formatHost = function formatHost () {
    return this.hostname + (this.port ? ':' + this.port : '');
  };

  Url.prototype.formatPath = function formatPath () {
    return this.path + lib.stringify(this.query, {
      addQueryPrefix: true,
      filter: function (name, value) {
        return value === '' ? void 0 : value;
      }
    });
  };

  Url.prototype.formatScheme = function formatScheme () {
    return this.scheme + '://';
  };

  var Request = /*@__PURE__*/(function (Message) {
    function Request(options) {
      if ( options === void 0 ) options = {};

      Message.call(this, options);

      defaultsDeep$1(this, options, {
        method: 'GET',
        retry: 0,
        timeout: 60000,
        url: null
      });

      this.url = Url.parse(options.url);
    }

    if ( Message ) Request.__proto__ = Message;
    Request.prototype = Object.create( Message && Message.prototype );
    Request.prototype.constructor = Request;

    Request.prototype.createResponse = function createResponse () {
      return new Response({
        request: this,
        socket: this.socket
      });
    };

    Request.prototype.mustEnd = function mustEnd () {
      return false;
    };

    return Request;
  }(Message));

  var byteLength_1 = byteLength;
  var toByteArray_1 = toByteArray;
  var fromByteArray_1 = fromByteArray;

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens (b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) { validLen = len; }

    var placeHoldersLen = validLen === len
      ? 0
      : 4 - (validLen % 4);

    return [validLen, placeHoldersLen]
  }

  // base64 is 4/3 + up to two characters of the original data
  function byteLength (b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function _byteLength (b64, validLen, placeHoldersLen) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
  }

  function toByteArray (b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];

    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

    var curByte = 0;

    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
      ? validLen - 4
      : validLen;

    for (var i = 0; i < len; i += 4) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 18) |
        (revLookup[b64.charCodeAt(i + 1)] << 12) |
        (revLookup[b64.charCodeAt(i + 2)] << 6) |
        revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = (tmp >> 16) & 0xFF;
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 2) |
        (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp =
        (revLookup[b64.charCodeAt(i)] << 10) |
        (revLookup[b64.charCodeAt(i + 1)] << 4) |
        (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[curByte++] = (tmp >> 8) & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] +
      lookup[num >> 12 & 0x3F] +
      lookup[num >> 6 & 0x3F] +
      lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp =
        ((uint8[i] << 16) & 0xFF0000) +
        ((uint8[i + 1] << 8) & 0xFF00) +
        (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(
        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
      ));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(
        lookup[tmp >> 2] +
        lookup[(tmp << 4) & 0x3F] +
        '=='
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(
        lookup[tmp >> 10] +
        lookup[(tmp >> 4) & 0x3F] +
        lookup[(tmp << 2) & 0x3F] +
        '='
      );
    }

    return parts.join('')
  }

  var base64Js = {
  	byteLength: byteLength_1,
  	toByteArray: toByteArray_1,
  	fromByteArray: fromByteArray_1
  };

  var read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  };

  var write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = ((value * c) - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  var ieee754 = {
  	read: read,
  	write: write
  };

  var buffer = createCommonjsModule(function (module, exports) {




  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;

  var K_MAX_LENGTH = 0x7fffffff;
  exports.kMaxLength = K_MAX_LENGTH;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
      typeof console.error === 'function') {
    console.error(
      'This browser lacks typed array (Uint8Array) support which is required by ' +
      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
    );
  }

  function typedArraySupport () {
    // Can typed array instances can be augmented?
    try {
      var arr = new Uint8Array(1);
      arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } };
      return arr.foo() === 42
    } catch (e) {
      return false
    }
  }

  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) { return undefined }
      return this.buffer
    }
  });

  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function () {
      if (!Buffer.isBuffer(this)) { return undefined }
      return this.byteOffset
    }
  });

  function createBuffer (length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"')
    }
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    buf.__proto__ = Buffer.prototype;
    return buf
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }

  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
  if (typeof Symbol !== 'undefined' && Symbol.species != null &&
      Buffer[Symbol.species] === Buffer) {
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    });
  }

  Buffer.poolSize = 8192; // not used by this implementation

  function from (value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset)
    }

    if (ArrayBuffer.isView(value)) {
      return fromArrayLike(value)
    }

    if (value == null) {
      throw TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value)
      )
    }

    if (isInstance(value, ArrayBuffer) ||
        (value && isInstance(value.buffer, ArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length)
    }

    if (typeof value === 'number') {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      )
    }

    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length)
    }

    var b = fromObject(value);
    if (b) { return b }

    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
        typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(
        value[Symbol.toPrimitive]('string'), encodingOrOffset, length
      )
    }

    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length)
  };

  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
  }

  function alloc (size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(size).fill(fill, encoding)
        : createBuffer(size).fill(fill)
    }
    return createBuffer(size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding)
  };

  function allocUnsafe (size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size)
  };

  function fromString (string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }

    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);

    var actual = buf.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual);
    }

    return buf
  }

  function fromArrayLike (array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf
  }

  function fromArrayBuffer (array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds')
    }

    var buf;
    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }

    // Return an augmented `Uint8Array` instance
    buf.__proto__ = Buffer.prototype;
    return buf
  }

  function fromObject (obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);

      if (buf.length === 0) {
        return buf
      }

      obj.copy(buf, 0, 0, len);
      return buf
    }

    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  function checked (length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    }
    return length | 0
  }

  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer.alloc(+length)
  }

  Buffer.isBuffer = function isBuffer (b) {
    return b != null && b._isBuffer === true &&
      b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
  };

  Buffer.compare = function compare (a, b) {
    if (isInstance(a, Uint8Array)) { a = Buffer.from(a, a.offset, a.byteLength); }
    if (isInstance(b, Uint8Array)) { b = Buffer.from(b, b.offset, b.byteLength); }
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      )
    }

    if (a === b) { return 0 }

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) { return -1 }
    if (y < x) { return 1 }
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        buf = Buffer.from(buf);
      }
      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
        'Received type ' + typeof string
      )
    }

    var len = string.length;
    var mustMatch = (arguments.length > 2 && arguments[2] === true);
    if (!mustMatch && len === 0) { return 0 }

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
          }
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) { encoding = 'utf8'; }

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) { throw new TypeError('Unknown encoding: ' + encoding) }
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length;
    if (length === 0) { return '' }
    if (arguments.length === 0) { return utf8Slice(this, 0, length) }
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.toLocaleString = Buffer.prototype.toString;

  Buffer.prototype.equals = function equals (b) {
    if (!Buffer.isBuffer(b)) { throw new TypeError('Argument must be a Buffer') }
    if (this === b) { return true }
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) { str += ' ... '; }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. ' +
        'Received type ' + (typeof target)
      )
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) { return 0 }

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) { return -1 }
    if (y < x) { return 1 }
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) { return -1 }

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) { byteOffset = buffer.length + byteOffset; }
    if (byteOffset >= buffer.length) {
      if (dir) { return -1 }
      else { byteOffset = buffer.length - 1; }
    } else if (byteOffset < 0) {
      if (dir) { byteOffset = 0; }
      else { return -1 }
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) { foundIndex = i; }
          if (i - foundIndex + 1 === valLength) { return foundIndex * indexSize }
        } else {
          if (foundIndex !== -1) { i -= i - foundIndex; }
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) { byteOffset = arrLength - valLength; }
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) { return i }
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    var strLen = string.length;

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) { return i }
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) { encoding = 'utf8'; }
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) { length = remaining; }

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) { encoding = 'utf8'; }

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) { throw new TypeError('Unknown encoding: ' + encoding) }
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64Js.fromByteArray(buf)
    } else {
      return base64Js.fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
            : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) { start = 0; }
    if (!end || end < 0 || end > len) { end = len; }

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) { start = 0; }
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) { end = 0; }
    } else if (end > len) {
      end = len;
    }

    if (end < start) { end = start; }

    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    newBuf.__proto__ = Buffer.prototype;
    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) { throw new RangeError('offset is not uint') }
    if (offset + ext > length) { throw new RangeError('Trying to access beyond buffer length') }
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) { checkOffset(offset, byteLength, this.length); }

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 1, this.length); }
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 2, this.length); }
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 2, this.length); }
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 4, this.length); }

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 4, this.length); }

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) { checkOffset(offset, byteLength, this.length); }

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) { val -= Math.pow(2, 8 * byteLength); }

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) { checkOffset(offset, byteLength, this.length); }

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) { val -= Math.pow(2, 8 * byteLength); }

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 1, this.length); }
    if (!(this[offset] & 0x80)) { return (this[offset]) }
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 2, this.length); }
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 2, this.length); }
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 4, this.length); }

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 4, this.length); }

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 4, this.length); }
    return ieee754.read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 4, this.length); }
    return ieee754.read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 8, this.length); }
    return ieee754.read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) { checkOffset(offset, 8, this.length); }
    return ieee754.read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) { throw new TypeError('"buffer" argument must be a Buffer instance') }
    if (value > max || value < min) { throw new RangeError('"value" argument is out of bounds') }
    if (offset + ext > buf.length) { throw new RangeError('Index out of range') }
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 1, 0xff, 0); }
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 2, 0xffff, 0); }
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 2, 0xffff, 0); }
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
    return offset + 2
  };

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 4, 0xffffffff, 0); }
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 4, 0xffffffff, 0); }
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, (8 * byteLength) - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, (8 * byteLength) - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 1, 0x7f, -0x80); }
    if (value < 0) { value = 0xff + value + 1; }
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 2, 0x7fff, -0x8000); }
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 2, 0x7fff, -0x8000); }
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000); }
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) { checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000); }
    if (value < 0) { value = 0xffffffff + value + 1; }
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) { throw new RangeError('Index out of range') }
    if (offset < 0) { throw new RangeError('Index out of range') }
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) { throw new TypeError('argument should be a Buffer') }
    if (!start) { start = 0; }
    if (!end && end !== 0) { end = this.length; }
    if (targetStart >= target.length) { targetStart = target.length; }
    if (!targetStart) { targetStart = 0; }
    if (end > 0 && end < start) { end = start; }

    // Copy 0 bytes; we're done
    if (end === start) { return 0 }
    if (target.length === 0 || this.length === 0) { return 0 }

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) { throw new RangeError('Index out of range') }
    if (end < 0) { throw new RangeError('sourceEnd out of bounds') }

    // Are we oob?
    if (end > this.length) { end = this.length; }
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;

    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end);
    } else if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (var i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if ((encoding === 'utf8' && code < 128) ||
            encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) { val = 0; }

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val)
        ? val
        : Buffer.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val +
          '" is invalid for argument "value"')
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) { return '' }
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function toHex (n) {
    if (n < 16) { return '0' + n.toString(16) }
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) { break }
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) { break }
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) { break }
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) { break }
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) { break }

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }

  function base64ToBytes (str) {
    return base64Js.toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) { break }
      dst[i + offset] = src[i];
    }
    return i
  }

  // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166
  function isInstance (obj, type) {
    return obj instanceof type ||
      (obj != null && obj.constructor != null && obj.constructor.name != null &&
        obj.constructor.name === type.name)
  }
  function numberIsNaN (obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
  }
  });
  var buffer_1 = buffer.Buffer;
  var buffer_2 = buffer.SlowBuffer;
  var buffer_3 = buffer.INSPECT_MAX_BYTES;
  var buffer_4 = buffer.kMaxLength;

  var delimiters = [',', ';', '\t'];

  var lineEndings = {
    CR: { char: '\r', code: 13 },
    CRLF: { char: '\r\n', code: 13 },
    LF: { char: '\n', code: 10 }
  };

  var CsvStruct = function CsvStruct(options, data) {
    this._options = options;
    this._data = data;
  };

  CsvStruct.prototype.checkQuote = function checkQuote (data, isValue, isEscaped, i) {
    if (isValue === true) {
      if (data[i + 1] === 34) {
        isEscaped = !isEscaped;
        i += 1;
      } else if (isEscaped === false) {
        isValue = false;
      }
    } else {
      isValue = true;
    }

    return [true, isValue, isEscaped, i];
  };

  CsvStruct.prototype.decode = function decode () {
      var assign;

    if (typeof this._data !== 'string') {
      return this._data;
    }

    var ref = this._options;
      var delimiter = ref.delimiter; if ( delimiter === void 0 ) delimiter = ',';
      var lineEnding = ref.lineEnding; if ( lineEnding === void 0 ) lineEnding = 'LF';

    var data = buffer_1.from(this._data.trim());

    if (lineEnding === 'detect') {
      lineEnding = this.detectLineEnding(data);
    }

    lineEnding = lineEndings[lineEnding];

    if (delimiter === 'detect') {
      delimiter = this.detectDelimiter(data, lineEnding.code);
    }

    delimiter = buffer_1.from(delimiter)[0];

    var begin = 0;
    var i = 0;
    var line = [];

    var isEscaped = false;
    var isQuoted = false;
    var isValue = false;

    var lines = [];

    for (; i < data.length; i += 1) {
      if (data[i] === 34) {
        ((assign =
          this.checkQuote(data, isValue, isEscaped, i), isQuoted = assign[0], isValue = assign[1], isEscaped = assign[2], i = assign[3]));
      } else if (data[i] === delimiter && isValue === false) {
        line[line.length] = this.parseValue(data, begin, i, isQuoted);
        isQuoted = false;
        begin = i + 1;
      } else if (data[i] === lineEnding.code && isValue === false) {
        line[line.length] = this.parseValue(data, begin, i, isQuoted);
        lines[lines.length] = line;
        line = [];
        isQuoted = false;
        begin = i + lineEnding.char.length;
      }
    }

    line[line.length] = this.parseValue(data, begin, i, isQuoted);
    lines[lines.length] = line;

    this._data = lines;
    return this._data;
  };

  CsvStruct.prototype.detectDelimiter = function detectDelimiter (data, lineEndingCode) {
    data = String(data.slice(0, data.indexOf(lineEndingCode)));

    var count = 0;
    var delimiter = ',';
    var match = null;

    for (var i = 0; i < delimiters.length; i += 1) {
      match = data.match(new RegExp(delimiters[i]), 'g');
      delimiter = match && match.length > count ? delimiters[i] : delimiter;
      count = match && match.length > count ? match.length : count;
    }

    return delimiter;
  };

  CsvStruct.prototype.detectLineEnding = function detectLineEnding (data) {
    for (var i = 0; i < data.length; i += 1) {
      if (data[i] === 13) {
        if (data[i + 1] === 10) {
          return 'CRLF';
        }

        return 'CR';
      } else if (data[i] === 10) {
        return 'LF';
      }
    }

    return 'LF';
  };

  CsvStruct.prototype.encode = function encode () {
    if (typeof this._data === 'string') {
      return this._data;
    }

    var ref = this._options;
      var delimiter = ref.delimiter; if ( delimiter === void 0 ) delimiter = ',';
      var fields = ref.fields; if ( fields === void 0 ) fields = [];
      var quote = ref.quote; if ( quote === void 0 ) quote = false;

    var ref$1 = this._options;
      var lineEnding = ref$1.lineEnding; if ( lineEnding === void 0 ) lineEnding = 'LF';

    lineEnding = lineEndings[lineEnding];

    var regexp = new RegExp(("\r|\n|\"|" + delimiter));

    var csv = '';
    var field = null;

    for (var i = 0; i < fields.length; i += 1) {
      field = fields[i];

      csv += i > 0 ? delimiter : '';

      csv += this.formatValue(
        field.label,
        delimiter,
        regexp,
        quote
      );
    }

    for (var i$1 = 0; i$1 < this._data.length; i$1 += 1) {
      csv += csv.length > 0 ? lineEnding.char : '';

      for (var j = 0; j < fields.length; j += 1) {
        field = fields[j];

        csv += j > 0 ?
          delimiter : '';

        csv += this.formatValue(
          field.value(this._data[i$1], j),
          delimiter,
          regexp,
          quote
        );
      }
    }

    this._data = csv;
    return this._data;
  };

  CsvStruct.prototype.formatValue = function formatValue (value, delimiter, regexp, quote) {
    value = String(value);
    return quote || value.match(regexp) ?
      ("\"" + (value.replace(/"/g, '""')) + "\"") : value;
  };

  CsvStruct.prototype.parseValue = function parseValue (data, begin, i, isQuoted) {
    var quote = (isQuoted ? 1 : 0);
    var value = data.slice(begin + quote, i - quote);
    return String(value).replace(/""/g, '"');
  };

  CsvStruct.prototype.toString = function toString () {
    return this.encode();
  };

  var HtmlStruct = function HtmlStruct(data) {
    this._data = data;
  };

  HtmlStruct.prototype.decode = function decode () {
    if (typeof this._data === 'string') {
      this._data = parser.parse(this._data);
    }

    return this._data;
  };

  HtmlStruct.prototype.encode = function encode () {
    if (typeof this._data !== 'string') {
      this._data = parser.serialize(this._data);
    }

    return this._data;
  };

  HtmlStruct.prototype.toString = function toString () {
    return this.encode();
  };

  /** `Object#toString` result references. */
  var symbolTag$2 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$4(value) {
    return typeof value == 'symbol' ||
      (isObjectLike$3(value) && baseGetTag$3(value) == symbolTag$2);
  }

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray$4(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol$4(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize$1(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize$1.Cache || MapCache$2);
    return memoized;
  }

  // Expose `MapCache`.
  memoize$1.Cache = MapCache$2;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE$1 = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped$1(func) {
    var result = memoize$1(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE$1) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */
  var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar$1 = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath$1 = memoizeCapped$1(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName$1, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar$1, '$1') : (number || match));
    });
    return result;
  });

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap$2(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /** Used as references for various `Number` constants. */
  var INFINITY$3 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : undefined,
      symbolToString$2 = symbolProto$2 ? symbolProto$2.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString$2(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$4(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap$2(value, baseToString$2) + '';
    }
    if (isSymbol$4(value)) {
      return symbolToString$2 ? symbolToString$2.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$3) ? '-0' : result;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$2(value) {
    return value == null ? '' : baseToString$2(value);
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray$4(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath$1(toString$2(value));
  }

  /** Used as references for various `Number` constants. */
  var INFINITY$4 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey$1(value) {
    if (typeof value == 'string' || isSymbol$4(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$4) ? '-0' : result;
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey$1(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get$2(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet(object, path, value, customizer) {
    if (!isObject$4(object)) {
      return object;
    }
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey$1(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject$4(objValue)
            ? objValue
            : (isIndex$2(path[index + 1]) ? [] : {});
        }
      }
      assignValue$1(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */
  function set$3(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }

  var long_1 = Long;

  /**
   * wasm optimizations, to do native i64 multiplication and divide
   */
  var wasm = null;

  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
    ])), {}).exports;
  } catch (e) {
    // no wasm support :(
  }

  /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
  function Long(low, high, unsigned) {

      /**
       * The low 32 bits as a signed value.
       * @type {number}
       */
      this.low = low | 0;

      /**
       * The high 32 bits as a signed value.
       * @type {number}
       */
      this.high = high | 0;

      /**
       * Whether unsigned or not.
       * @type {boolean}
       */
      this.unsigned = !!unsigned;
  }

  Object.defineProperty(Long.prototype, "__isLong__", { value: true });

  /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
  function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
  }

  /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
  Long.isLong = isLong;

  /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
  var INT_CACHE = {};

  /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
  var UINT_CACHE = {};

  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
          value >>>= 0;
          if (cache = (0 <= value && value < 256)) {
              cachedObj = UINT_CACHE[value];
              if (cachedObj)
                  { return cachedObj; }
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
              { UINT_CACHE[value] = obj; }
          return obj;
      } else {
          value |= 0;
          if (cache = (-128 <= value && value < 128)) {
              cachedObj = INT_CACHE[value];
              if (cachedObj)
                  { return cachedObj; }
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache)
              { INT_CACHE[value] = obj; }
          return obj;
      }
  }

  /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromInt = fromInt;

  /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromNumber(value, unsigned) {
      if (isNaN(value))
          { return unsigned ? UZERO : ZERO; }
      if (unsigned) {
          if (value < 0)
              { return UZERO; }
          if (value >= TWO_PWR_64_DBL)
              { return MAX_UNSIGNED_VALUE; }
      } else {
          if (value <= -TWO_PWR_63_DBL)
              { return MIN_VALUE; }
          if (value + 1 >= TWO_PWR_63_DBL)
              { return MAX_VALUE; }
      }
      if (value < 0)
          { return fromNumber(-value, unsigned).neg(); }
      return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
  }

  /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromNumber = fromNumber;

  /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
  }

  /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
  Long.fromBits = fromBits;

  /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

  /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
  function fromString(str, unsigned, radix) {
      if (str.length === 0)
          { throw Error('empty string'); }
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          { return ZERO; }
      if (typeof unsigned === 'number') {
          // For goog.math.long compatibility
          radix = unsigned,
          unsigned = false;
      } else {
          unsigned = !! unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
          { throw RangeError('radix'); }

      var p;
      if ((p = str.indexOf('-')) > 0)
          { throw Error('interior hyphen'); }
      else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
      }

      // Do several (8) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 8));

      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i),
              value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
              var power = fromNumber(pow_dbl(radix, size));
              result = result.mul(power).add(fromNumber(value));
          } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber(value));
          }
      }
      result.unsigned = unsigned;
      return result;
  }

  /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
  Long.fromString = fromString;

  /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
  function fromValue(val, unsigned) {
      if (typeof val === 'number')
          { return fromNumber(val, unsigned); }
      if (typeof val === 'string')
          { return fromString(val, unsigned); }
      // Throws for non-objects, converts non-instanceof Long:
      return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
  }

  /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
  Long.fromValue = fromValue;

  // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
  // no runtime penalty for these.

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_16_DBL = 1 << 16;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_24_DBL = 1 << 24;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

  /**
   * @type {number}
   * @const
   * @inner
   */
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

  /**
   * @type {!Long}
   * @const
   * @inner
   */
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

  /**
   * @type {!Long}
   * @inner
   */
  var ZERO = fromInt(0);

  /**
   * Signed zero.
   * @type {!Long}
   */
  Long.ZERO = ZERO;

  /**
   * @type {!Long}
   * @inner
   */
  var UZERO = fromInt(0, true);

  /**
   * Unsigned zero.
   * @type {!Long}
   */
  Long.UZERO = UZERO;

  /**
   * @type {!Long}
   * @inner
   */
  var ONE = fromInt(1);

  /**
   * Signed one.
   * @type {!Long}
   */
  Long.ONE = ONE;

  /**
   * @type {!Long}
   * @inner
   */
  var UONE = fromInt(1, true);

  /**
   * Unsigned one.
   * @type {!Long}
   */
  Long.UONE = UONE;

  /**
   * @type {!Long}
   * @inner
   */
  var NEG_ONE = fromInt(-1);

  /**
   * Signed negative one.
   * @type {!Long}
   */
  Long.NEG_ONE = NEG_ONE;

  /**
   * @type {!Long}
   * @inner
   */
  var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

  /**
   * Maximum signed value.
   * @type {!Long}
   */
  Long.MAX_VALUE = MAX_VALUE;

  /**
   * @type {!Long}
   * @inner
   */
  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

  /**
   * Maximum unsigned value.
   * @type {!Long}
   */
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

  /**
   * @type {!Long}
   * @inner
   */
  var MIN_VALUE = fromBits(0, 0x80000000|0, false);

  /**
   * Minimum signed value.
   * @type {!Long}
   */
  Long.MIN_VALUE = MIN_VALUE;

  /**
   * @alias Long.prototype
   * @inner
   */
  var LongPrototype = Long.prototype;

  /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @returns {number}
   */
  LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
  };

  /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @returns {number}
   */
  LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
          { return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0); }
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };

  /**
   * Converts the Long to a string written in the specified radix.
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
  LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
          { throw RangeError('radix'); }
      if (this.isZero())
          { return '0'; }
      if (this.isNegative()) { // Unsigned Longs are never negative
          if (this.eq(MIN_VALUE)) {
              // We need to change the Long value before it can be negated, so we remove
              // the bottom-most digit in this base and then recurse to do the rest.
              var radixLong = fromNumber(radix),
                  div = this.div(radixLong),
                  rem1 = div.mul(radixLong).sub(this);
              return div.toString(radix) + rem1.toInt().toString(radix);
          } else
              { return '-' + this.neg().toString(radix); }
      }

      // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
          rem = this;
      var result = '';
      while (true) {
          var remDiv = rem.div(radixToPower),
              intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
              digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
              { return digits + result; }
          else {
              while (digits.length < 6)
                  { digits = '0' + digits; }
              result = '' + digits + result;
          }
      }
  };

  /**
   * Gets the high 32 bits as a signed integer.
   * @returns {number} Signed high bits
   */
  LongPrototype.getHighBits = function getHighBits() {
      return this.high;
  };

  /**
   * Gets the high 32 bits as an unsigned integer.
   * @returns {number} Unsigned high bits
   */
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
  };

  /**
   * Gets the low 32 bits as a signed integer.
   * @returns {number} Signed low bits
   */
  LongPrototype.getLowBits = function getLowBits() {
      return this.low;
  };

  /**
   * Gets the low 32 bits as an unsigned integer.
   * @returns {number} Unsigned low bits
   */
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
  };

  /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @returns {number}
   */
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative()) // Unsigned Longs are never negative
          { return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs(); }
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
          { if ((val & (1 << bit)) != 0)
              { break; } }
      return this.high != 0 ? bit + 33 : bit + 1;
  };

  /**
   * Tests if this Long's value equals zero.
   * @returns {boolean}
   */
  LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
  };

  /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
  LongPrototype.eqz = LongPrototype.isZero;

  /**
   * Tests if this Long's value is negative.
   * @returns {boolean}
   */
  LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
  };

  /**
   * Tests if this Long's value is positive.
   * @returns {boolean}
   */
  LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
  };

  /**
   * Tests if this Long's value is odd.
   * @returns {boolean}
   */
  LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
  };

  /**
   * Tests if this Long's value is even.
   * @returns {boolean}
   */
  LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
  };

  /**
   * Tests if this Long's value equals the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.equals = function equals(other) {
      if (!isLong(other))
          { other = fromValue(other); }
      if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
          { return false; }
      return this.high === other.high && this.low === other.low;
  };

  /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.eq = LongPrototype.equals;

  /**
   * Tests if this Long's value differs from the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(/* validates */ other);
  };

  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.neq = LongPrototype.notEquals;

  /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ne = LongPrototype.notEquals;

  /**
   * Tests if this Long's value is less than the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThan = function lessThan(other) {
      return this.comp(/* validates */ other) < 0;
  };

  /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lt = LongPrototype.lessThan;

  /**
   * Tests if this Long's value is less than or equal the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(/* validates */ other) <= 0;
  };

  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.lte = LongPrototype.lessThanOrEqual;

  /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.le = LongPrototype.lessThanOrEqual;

  /**
   * Tests if this Long's value is greater than the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(/* validates */ other) > 0;
  };

  /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gt = LongPrototype.greaterThan;

  /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(/* validates */ other) >= 0;
  };

  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;

  /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;

  /**
   * Compares this Long's value with the specified's.
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  LongPrototype.compare = function compare(other) {
      if (!isLong(other))
          { other = fromValue(other); }
      if (this.eq(other))
          { return 0; }
      var thisNeg = this.isNegative(),
          otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
          { return -1; }
      if (!thisNeg && otherNeg)
          { return 1; }
      // At this point the sign bits are the same
      if (!this.unsigned)
          { return this.sub(other).isNegative() ? -1 : 1; }
      // Both are positive if at least one is unsigned
      return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
  };

  /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
  LongPrototype.comp = LongPrototype.compare;

  /**
   * Negates this Long's value.
   * @returns {!Long} Negated Long
   */
  LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
          { return MIN_VALUE; }
      return this.not().add(ONE);
  };

  /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
  LongPrototype.neg = LongPrototype.negate;

  /**
   * Returns the sum of this and the specified Long.
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */
  LongPrototype.add = function add(addend) {
      if (!isLong(addend))
          { addend = fromValue(addend); }

      // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xFFFF;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xFFFF;

      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xFFFF;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xFFFF;

      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  };

  /**
   * Returns the difference of this and the specified Long.
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
          { subtrahend = fromValue(subtrahend); }
      return this.add(subtrahend.neg());
  };

  /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
  LongPrototype.sub = LongPrototype.subtract;

  /**
   * Returns the product of this and the specified Long.
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
          { return ZERO; }
      if (!isLong(multiplier))
          { multiplier = fromValue(multiplier); }

      // use wasm support if present
      if (wasm) {
          var low = wasm.mul(this.low,
                             this.high,
                             multiplier.low,
                             multiplier.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
      }

      if (multiplier.isZero())
          { return ZERO; }
      if (this.eq(MIN_VALUE))
          { return multiplier.isOdd() ? MIN_VALUE : ZERO; }
      if (multiplier.eq(MIN_VALUE))
          { return this.isOdd() ? MIN_VALUE : ZERO; }

      if (this.isNegative()) {
          if (multiplier.isNegative())
              { return this.neg().mul(multiplier.neg()); }
          else
              { return this.neg().mul(multiplier).neg(); }
      } else if (multiplier.isNegative())
          { return this.mul(multiplier.neg()).neg(); }

      // If both longs are small, use float multiplication
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          { return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); }

      // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xFFFF;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xFFFF;

      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xFFFF;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xFFFF;

      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xFFFF;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
  };

  /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
  LongPrototype.mul = LongPrototype.multiply;

  /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
          { divisor = fromValue(divisor); }
      if (divisor.isZero())
          { throw Error('division by zero'); }

      // use wasm support if present
      if (wasm) {
          // guard against signed division overflow: the largest
          // negative number / -1 would be 1 larger than the largest
          // positive number, due to two's complement.
          if (!this.unsigned &&
              this.high === -0x80000000 &&
              divisor.low === -1 && divisor.high === -1) {
              // be consistent with non-wasm code path
              return this;
          }
          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
              this.low,
              this.high,
              divisor.low,
              divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
      }

      if (this.isZero())
          { return this.unsigned ? UZERO : ZERO; }
      var approx, rem, res;
      if (!this.unsigned) {
          // This section is only relevant for signed longs and is derived from the
          // closure library as a whole.
          if (this.eq(MIN_VALUE)) {
              if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                  { return MIN_VALUE; }  // recall that -MIN_VALUE == MIN_VALUE
              else if (divisor.eq(MIN_VALUE))
                  { return ONE; }
              else {
                  // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                  var halfThis = this.shr(1);
                  approx = halfThis.div(divisor).shl(1);
                  if (approx.eq(ZERO)) {
                      return divisor.isNegative() ? ONE : NEG_ONE;
                  } else {
                      rem = this.sub(divisor.mul(approx));
                      res = approx.add(rem.div(divisor));
                      return res;
                  }
              }
          } else if (divisor.eq(MIN_VALUE))
              { return this.unsigned ? UZERO : ZERO; }
          if (this.isNegative()) {
              if (divisor.isNegative())
                  { return this.neg().div(divisor.neg()); }
              return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
              { return this.div(divisor.neg()).neg(); }
          res = ZERO;
      } else {
          // The algorithm below has not been made for unsigned longs. It's therefore
          // required to take special care of the MSB prior to running it.
          if (!divisor.unsigned)
              { divisor = divisor.toUnsigned(); }
          if (divisor.gt(this))
              { return UZERO; }
          if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
              { return UONE; }
          res = UZERO;
      }

      // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.
      rem = this;
      while (rem.gte(divisor)) {
          // Approximate the result of division. This may be a little greater or
          // smaller than the actual value.
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

          // We will tweak the approximate result by changing it in the 48-th digit or
          // the smallest non-fractional digit, whichever is larger.
          var log2 = Math.ceil(Math.log(approx) / Math.LN2),
              delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

          // Decrease the approximation until it is smaller than the remainder.  Note
          // that if it is too large, the product overflows and is negative.
              approxRes = fromNumber(approx),
              approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
          }

          // We know the answer can't be zero... and actually, zero would cause
          // infinite recursion since we would make no progress.
          if (approxRes.isZero())
              { approxRes = ONE; }

          res = res.add(approxRes);
          rem = rem.sub(approxRem);
      }
      return res;
  };

  /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
  LongPrototype.div = LongPrototype.divide;

  /**
   * Returns this Long modulo the specified.
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
          { divisor = fromValue(divisor); }

      // use wasm support if present
      if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
              this.low,
              this.high,
              divisor.low,
              divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
      }

      return this.sub(this.div(divisor).mul(divisor));
  };

  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.mod = LongPrototype.modulo;

  /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
  LongPrototype.rem = LongPrototype.modulo;

  /**
   * Returns the bitwise NOT of this Long.
   * @returns {!Long}
   */
  LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
  };

  /**
   * Returns the bitwise AND of this Long and the specified.
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.and = function and(other) {
      if (!isLong(other))
          { other = fromValue(other); }
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };

  /**
   * Returns the bitwise OR of this Long and the specified.
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.or = function or(other) {
      if (!isLong(other))
          { other = fromValue(other); }
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };

  /**
   * Returns the bitwise XOR of this Long and the given one.
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
  LongPrototype.xor = function xor(other) {
      if (!isLong(other))
          { other = fromValue(other); }
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };

  /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
          { numBits = numBits.toInt(); }
      if ((numBits &= 63) === 0)
          { return this; }
      else if (numBits < 32)
          { return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned); }
      else
          { return fromBits(0, this.low << (numBits - 32), this.unsigned); }
  };

  /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shl = LongPrototype.shiftLeft;

  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
          { numBits = numBits.toInt(); }
      if ((numBits &= 63) === 0)
          { return this; }
      else if (numBits < 32)
          { return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned); }
      else
          { return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned); }
  };

  /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shr = LongPrototype.shiftRight;

  /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
          { numBits = numBits.toInt(); }
      numBits &= 63;
      if (numBits === 0)
          { return this; }
      else {
          var high = this.high;
          if (numBits < 32) {
              var low = this.low;
              return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
          } else if (numBits === 32)
              { return fromBits(high, 0, this.unsigned); }
          else
              { return fromBits(high >>> (numBits - 32), 0, this.unsigned); }
      }
  };

  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;

  /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

  /**
   * Converts this Long to signed.
   * @returns {!Long} Signed long
   */
  LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
          { return this; }
      return fromBits(this.low, this.high, false);
  };

  /**
   * Converts this Long to unsigned.
   * @returns {!Long} Unsigned long
   */
  LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
          { return this; }
      return fromBits(this.low, this.high, true);
  };

  /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {!Array.<number>} Byte representation
   */
  LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
  };

  /**
   * Converts this Long to its little endian byte representation.
   * @returns {!Array.<number>} Little endian byte representation
   */
  LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high,
          lo = this.low;
      return [
          lo        & 0xff,
          lo >>>  8 & 0xff,
          lo >>> 16 & 0xff,
          lo >>> 24       ,
          hi        & 0xff,
          hi >>>  8 & 0xff,
          hi >>> 16 & 0xff,
          hi >>> 24
      ];
  };

  /**
   * Converts this Long to its big endian byte representation.
   * @returns {!Array.<number>} Big endian byte representation
   */
  LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high,
          lo = this.low;
      return [
          hi >>> 24       ,
          hi >>> 16 & 0xff,
          hi >>>  8 & 0xff,
          hi        & 0xff,
          lo >>> 24       ,
          lo >>> 16 & 0xff,
          lo >>>  8 & 0xff,
          lo        & 0xff
      ];
  };

  /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };

  /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
          bytes[0]       |
          bytes[1] <<  8 |
          bytes[2] << 16 |
          bytes[3] << 24,
          bytes[4]       |
          bytes[5] <<  8 |
          bytes[6] << 16 |
          bytes[7] << 24,
          unsigned
      );
  };

  /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
          bytes[4] << 24 |
          bytes[5] << 16 |
          bytes[6] <<  8 |
          bytes[7],
          bytes[0] << 24 |
          bytes[1] << 16 |
          bytes[2] <<  8 |
          bytes[3],
          unsigned
      );
  };

  var scopes = { read: 0, write: 1 };
  var masks = {};

  var User = function User(options) {
    if ( options === void 0 ) options = {};

    this._details = null;
    this._id = null;
    this._parents = null;
    this._role = null;
    this._token = null;

    this.setDetails(options.details);
    this.setId(options.id);
    this.setParents(options.parents);
    this.setRole(options.role);
    this.setToken(options.token);
  };

  User.getMasks = function getMasks () {
    return masks;
  };

  User.setMasks = function setMasks (value) {
    masks = value;
  };

  User.formatName = function formatName (details, parts) {
      if ( parts === void 0 ) parts = null;

    var name = '';

    if (parts === null || parts.indexOf('given_name') > -1) {
      name += details.given_name;
    }

    if (parts === null || parts.indexOf('additional_name') > -1) {
      name += details.additional_name ?
        ' ' + details.additional_name : '';
    }

    if (parts === null || parts.indexOf('family_name') > -1) {
      name += details.family_name ?
        ' ' + details.family_name : '';
    }

    return name.trim();
  };

  User.prototype.getDetail = function getDetail (name) {
    return get$2(this._details, name);
  };

  User.prototype.getDetails = function getDetails () {
    return this._details;
  };

  User.prototype.hasDetail = function hasDetail (name) {
    var value = this.getDetail(name);
    return typeof value !== 'undefined' && value !== null && value !== '';
  };

  User.prototype.setDetail = function setDetail (name, value) {
    set$3(this._details, name, value);
    return this;
  };

  User.prototype.setDetails = function setDetails (value) {
      if ( value === void 0 ) value = {};

    this._details = value;
    return this;
  };

  User.prototype.unsetDetail = function unsetDetail (name) {
    set$3(this._details, name, null);
    return this;
  };

  User.prototype.getId = function getId () {
    return this._id;
  };

  User.prototype.setId = function setId (value) {
      if ( value === void 0 ) value = null;

    this._id = value;
    return this;
  };

  User.prototype.getName = function getName (parts) {
    return this._details === null ?
      '' : User.formatName(this._details, parts);
  };

  User.prototype.getParentId = function getParentId (name, scope) {
      if ( scope === void 0 ) scope = 'write';

    return this._parents[scope][name] || [];
  };

  User.prototype.getParentScope = function getParentScope (name, scope) {
      if ( scope === void 0 ) scope = 'write';

    return typeof this._parents[scope][name] !== 'undefined' ?
      scope : null;
  };

  User.prototype.getParents = function getParents () {
    return this._parents;
  };

  User.prototype.setParents = function setParents (value) {
      if ( value === void 0 ) value = null;

    this._parents = value;
    return this;
  };

  User.prototype.getRole = function getRole () {
    return this._role;
  };

  User.prototype.getRoleDetail = function getRoleDetail (name) {
    return this._role[name];
  };

  User.prototype.setRoleDetail = function setRoleDetail (name, value) {
    this._role[name] = value;
    return this;
  };

  User.prototype.setRole = function setRole (value) {
      if ( value === void 0 ) value = null;

    this._role = value;
    return this;
  };

  User.prototype.getToken = function getToken () {
    return this._token;
  };

  User.prototype.setToken = function setToken (value) {
      if ( value === void 0 ) value = null;

    this._token = value;
    return this;
  };

  User.prototype.may = function may (permission, box, data) {
    if (typeof permission === 'string' || Array.isArray(permission)) {
      return this.mayRole(permission);
    }

    if (typeof permission === 'function') {
      return permission(box, data);
    }

    if (typeof permission.scope === 'undefined') {
      return this.mayRole(permission.name);
    }

    var scope = data && data.meta && data.meta.scope ||
      data && data.data && data.data.scope;

    var found = this.mayScope(box, data,
      permission.scope, scope);

    if (typeof permission.name === 'undefined') {
      return found;
    }

    return this.mayRole(permission.name) && found;
  };

  User.prototype.mayRole = function mayRole (names) {
    names = Array.isArray(names) ? names : [names];
    var name = null;

    for (var i = 0; i < names.length; i += 1) {
      name = names[i].split('.');

      var permission = long_1.fromNumber(this._role[name[0]]);
      var mask = long_1.fromNumber(get$2(masks, name));

      if ((permission.and(mask)).toNumber() !== 0) {
        return true;
      }
    }

    return false;
  };

  User.prototype.mayScope = function mayScope (box, data, desired, actual) {
    if (typeof desired === 'function') {
      return desired(box, data, actual);
    }

    return scopes[actual] >= scopes[desired];
  };

  var BrowserConnector = /*@__PURE__*/(function (Worker) {
    function BrowserConnector () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) BrowserConnector.__proto__ = Worker;
    BrowserConnector.prototype = Object.create( Worker && Worker.prototype );
    BrowserConnector.prototype.constructor = BrowserConnector;

    BrowserConnector.prototype.act = function act (options, data, callback) {
      var request = new Request(options);

      if (typeof request.socket !== 'undefined') {
        this.pass(request, data, callback);
        return;
      }

      try {
        this.open(request, data, callback);
      } catch (error) {
        this.fail(request, error, callback);
      }
    };

    BrowserConnector.prototype.err = function err (box, error, callback) {
      this.fail(new Request(), error, callback);
    };

    BrowserConnector.prototype.open = function open (request, data, callback) {
      request.socket = new XMLHttpRequest();
      request.socket.removeAllListeners = function () {};
      request.socket.destroy = function () {};

      request.socket.open(
        request.method,
        request.url.format()
      );

      this.pass(request, data, callback);
    };

    return BrowserConnector;
  }(Worker));

  var ClientConnector = /*@__PURE__*/(function (Worker) {
    function ClientConnector () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) ClientConnector.__proto__ = Worker;
    ClientConnector.prototype = Object.create( Worker && Worker.prototype );
    ClientConnector.prototype.constructor = ClientConnector;

    ClientConnector.prototype.act = function act (options, data, callback) {
      var request = new Request(options);

      if (typeof request.socket !== 'undefined') {
        this.pass(request, data, callback);
        return;
      }

      try {
        this.open(request, data, callback, options);
      } catch (error) {
        error.data = data;
        this.fail(request, error, callback);
      }
    };

    ClientConnector.prototype.err = function err (box, error, callback) {
      this.fail(new Request(), error, callback);
    };

    ClientConnector.prototype.open = function open (request, data, callback, options) {
      var this$1 = this;

      var library = request.url.scheme === 'http' ?
        net : tls;

      var event = library === net ?
        'connect' : 'secureConnect';

      request.headers.host = request.url.formatHost();

      var socket = library.connect(Object.assign({
        host: request.url.hostname,
        port: request.url.port,
        servername: request.url.hostname,
        timeout: request.timeout
      }, request.options));

      socket.once('error', function (error) {
        this$1.fail(request, error, callback);
      });

      socket.once('timeout', function () {
        request.socket = socket;
        this$1.timeout(request, data, callback, options);
      });

      socket.once(event, function () {
        request.socket = socket;
        this$1.pass(request, data, callback);
      });
    };

    ClientConnector.prototype.retry = function retry (request, data, callback, options) {
      if (request.socket) {
        request.socket.removeAllListeners();
        request.socket.destroy();
        delete request.socket;
      }

      if (request.retry === 0) {
        var error = new Error('Connection timed out');
        this.fail(request, error, callback);
        return;
      }

      options.retry -= 1;
      this.act(options, data, callback);
    };

    ClientConnector.prototype.timeout = function timeout (request, data, callback, options) {
      try {
        this.retry(request, data, callback, options);
      } catch (error) {
        this.fail(request, error, callback);
      }
    };

    return ClientConnector;
  }(Worker));

  var ServerConnector = /*@__PURE__*/(function (Streamer) {
    function ServerConnector () {
      Streamer.apply(this, arguments);
    }

    if ( Streamer ) ServerConnector.__proto__ = Streamer;
    ServerConnector.prototype = Object.create( Streamer && Streamer.prototype );
    ServerConnector.prototype.constructor = ServerConnector;

    ServerConnector.prototype.act = function act (socket) {
      this.read({
        socket: socket
      });
    };

    ServerConnector.prototype.data = function data (box, data$1) {
      var this$1 = this;

      this.log('info', box, data$1);

      var create = typeof box.request === 'undefined' ||
        box.request.state.body === true &&
        box.request.state.headers === true &&
        box.request.state.line === true;

      if (create === true) {
        box.request = new Request({
          socket: box.socket
        });
      }

      data$1 = this.prepareParser(box.request, data$1);

      this.pass(box.request, data$1, function (bx, resume) {
        this$1.throttle(box, resume);
      });
    };

    ServerConnector.prototype.end = function end () {};

    ServerConnector.prototype.fail = function fail () {};

    ServerConnector.prototype.stream = function stream (request) {
      return request.socket;
    };

    ServerConnector.prototype.prepareParser = function prepareParser (request, data) {
      if (request.parser.data) {
        data = buffer_1.concat([request.parser.data, data]);
        request.parser.data = null;
      }

      if (typeof request.parser.length === 'undefined') {
        request.parser.length = null;
      }

      request.parser.begin = 0;
      request.parser.end = 0;

      return data;
    };

    return ServerConnector;
  }(Streamer));

  var ChunkedDecoder = /*@__PURE__*/(function (Worker) {
    function ChunkedDecoder(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._maxLength = null;
      this.setMaxLength(options.maxLength);
    }

    if ( Worker ) ChunkedDecoder.__proto__ = Worker;
    ChunkedDecoder.prototype = Object.create( Worker && Worker.prototype );
    ChunkedDecoder.prototype.constructor = ChunkedDecoder;

    ChunkedDecoder.prototype.getMaxLength = function getMaxLength () {
      return this._maxLength;
    };

    ChunkedDecoder.prototype.setMaxLength = function setMaxLength (maxLength) {
      if ( maxLength === void 0 ) maxLength = 1024 * 1024;

      this._maxLength = maxLength;
      return this;
    };

    ChunkedDecoder.prototype.getEncoding = function getEncoding () {
      return 'chunked';
    };

    ChunkedDecoder.prototype.act = function act (message, data, callback) {
      var assign, assign$1;

      var begin = message.parser.begin;
      var i = begin;

      for (; i < data.length; i += 1) {
        if (data[i] === 13) {
          if (message.state.body !== true && message.parser.length === null) {
            (assign = this.parseLength(message, data, callback, begin, i), begin = assign[0], i = assign[1]);
          } else {
            (assign$1 = this.parsePartial(message, data, callback, begin, i), begin = assign$1[0], i = assign$1[1]);
          }
        }
      }

      if (begin < i || message.parser.length === null) {
        this.parseComplete(message, data, callback, begin, i);
      }

      message.parser.begin = 0;
    };

    ChunkedDecoder.prototype.decide = function decide (message, data) {
      return data !== null &&
        message.state.body !== true &&
        message.state.headers === true;
    };

    ChunkedDecoder.prototype.parseComplete = function parseComplete (message, data, callback, begin, i) {
      if (i - begin === 1 && Number(data.slice(begin, i)) === 0) {
        this.parseLength(message, data, callback, begin, i);
        return;
      }

      this.pass(message, data.slice(begin, i), callback);

      message.parser.sliced = (message.parser.sliced || 0) +
        data.slice(begin, i).length;
    };

    ChunkedDecoder.prototype.parseLength = function parseLength (message, data, callback, begin, i) {
      message.parser.length = parseInt(data.slice(begin, i), 16);
      message.parser.sliced = 0;

      if (Number.isNaN(message.parser.length)) {
        throw new Error('Chunked data is corrupt');
      }

      begin = i + 2;
      i = begin - 2 + message.parser.length;

      return [begin, i];
    };

    ChunkedDecoder.prototype.parsePartial = function parsePartial (message, data, callback, begin, i) {
      if (message.parser.length !== 0) {
        this.pass(message, data.slice(begin, i), callback);
      }

      message.state.body = message.parser.length === 0;

      message.parser.length = null;
      message.parser.sliced = (message.parser.sliced || 0) +
        data.slice(begin, i).length;

      begin = i + 2;

      return [begin, i];
    };

    return ChunkedDecoder;
  }(Worker));

  var ContentEncodingDecoder = /*@__PURE__*/(function (Manager) {
    function ContentEncodingDecoder () {
      Manager.apply(this, arguments);
    }

    if ( Manager ) ContentEncodingDecoder.__proto__ = Manager;
    ContentEncodingDecoder.prototype = Object.create( Manager && Manager.prototype );
    ContentEncodingDecoder.prototype.constructor = ContentEncodingDecoder;

    ContentEncodingDecoder.prototype.decide = function decide (message) {
      if (typeof message.body.content !== 'undefined') {
        return true;
      }

      var content = message.parseHeader('Content-Encoding');

      if (typeof content.values === 'undefined') {
        return false;
      }

      for (var i = 0; i < content.values.length; i += 1) {
        if (typeof this._pool[content.values[i][0]] === 'undefined') {
          throw new Error('501 Decoder not implemented' +
            " (" + (content[i][0]) + ")");
        }
      }

      message.body.content = content.values
        .reverse()
        .map(function (encoding) { return encoding[0]; });

      return true;
    };

    ContentEncodingDecoder.prototype.names = function names (message) {
      return message.body.content.slice(0);
    };

    return ContentEncodingDecoder;
  }(Manager));

  var ContentTypeDecoder = /*@__PURE__*/(function (Manager) {
    function ContentTypeDecoder(options) {
      if ( options === void 0 ) options = {};

      Manager.call(this, options);

      this._strict = null;
      this.setStrict(options.strict);
    }

    if ( Manager ) ContentTypeDecoder.__proto__ = Manager;
    ContentTypeDecoder.prototype = Object.create( Manager && Manager.prototype );
    ContentTypeDecoder.prototype.constructor = ContentTypeDecoder;

    ContentTypeDecoder.prototype.getStrict = function getStrict () {
      return this._strict;
    };

    ContentTypeDecoder.prototype.setStrict = function setStrict (value) {
      if ( value === void 0 ) value = true;

      this._strict = value;
      return this;
    };

    ContentTypeDecoder.prototype.decide = function decide (message) {
      if (typeof message.body.type !== 'undefined') {
        return true;
      }

      var type = message.parseHeader('content-type');

      if (typeof type.value === 'undefined') {
        return false;
      }

      if (typeof this._pool[type.value[0]] === 'undefined') {
        if (this._strict === true) {
          throw new Error('415 Decoder not implemented ' +
            " (" + (type[0]) + ")");
        }

        return false;
      }

      message.body.type = type.value[0];
      return true;
    };

    ContentTypeDecoder.prototype.names = function names (message) {
      return [message.body.type];
    };

    return ContentTypeDecoder;
  }(Manager));

  var CsvDecoder = /*@__PURE__*/(function (Worker) {
    function CsvDecoder(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._delimiter = null;
      this._lineEnding = null;

      this.setDelimiter(options.delimiter);
      this.setLineEnding(options.lineEnding);
    }

    if ( Worker ) CsvDecoder.__proto__ = Worker;
    CsvDecoder.prototype = Object.create( Worker && Worker.prototype );
    CsvDecoder.prototype.constructor = CsvDecoder;

    CsvDecoder.prototype.getDelimiter = function getDelimiter () {
      return this._delimiter;
    };

    CsvDecoder.prototype.setDelimiter = function setDelimiter (value) {
      if ( value === void 0 ) value = ',';

      this._delimiter = value;
      return this;
    };

    CsvDecoder.prototype.getLineEnding = function getLineEnding () {
      return this._lineEnding;
    };

    CsvDecoder.prototype.setLineEnding = function setLineEnding (value) {
      if ( value === void 0 ) value = 'LF';

      this._lineEnding = value;
      return this;
    };

    CsvDecoder.prototype.getType = function getType () {
      return 'text/csv';
    };

    CsvDecoder.prototype.act = function act (message, data, callback) {
      if (message.state.body !== true) {
        message.parser.csv = (message.parser.csv || '') + data;
        return;
      }

      try {
        this.decode(message, data, callback);
      } catch (error) {
        throw new Error('400 ' + error.message);
      }
    };

    CsvDecoder.prototype.decide = function decide (message, data) {
      return data === null ? null : true;
    };

    CsvDecoder.prototype.decode = function decode (message, data, callback) {
      var struct = new CsvStruct({
        delimiter: this._delimiter,
        lineEnding: this._lineEnding
      }, (message.parser.csv || '') + data);

      data = struct.decode();

      message.parser.csv = null;

      this.pass(message, data, callback);
    };

    return CsvDecoder;
  }(Worker));

  var FormdataDecoder = /*@__PURE__*/(function (Worker) {
    function FormdataDecoder(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._config = null;
      this.setConfig(options);
    }

    if ( Worker ) FormdataDecoder.__proto__ = Worker;
    FormdataDecoder.prototype = Object.create( Worker && Worker.prototype );
    FormdataDecoder.prototype.constructor = FormdataDecoder;

    FormdataDecoder.prototype.getConfig = function getConfig () {
      return this._config;
    };

    FormdataDecoder.prototype.setConfig = function setConfig (value) {
      if ( value === void 0 ) value = {};

      this._config = defaultsDeep$1({}, value, {
        base: '/tmp',
        path: '/'
      });

      fs.ensureDirSync(this._config.base + this._config.path);
      return this;
    };

    FormdataDecoder.prototype.getType = function getType () {
      return 'multipart/form-data';
    };

    FormdataDecoder.prototype.act = function act (message, data, callback) {
      try {
        this.decode(message, data, callback);
      } catch (error) {
        throw new Error('400 ' + error.message);
      }
    };

    FormdataDecoder.prototype.decode = function decode (message, data, callback) {
      if (typeof message.parser.formdata === 'undefined') {
        this.setupParser(message, data, callback);
      }

      if (message.state.body === true) {
        message.parser.formdata.end(data, null, callback);
      } else {
        message.parser.formdata.write(data, null, callback);
      }
    };

    FormdataDecoder.prototype.handleError = function handleError (message, error, callback) {
      message.parser.formdata.removeAllListeners();
      message.parser.formdata = null;

      error = new Error('400 ' + error.message);

      this.fail(message, error, callback);
    };

    FormdataDecoder.prototype.handleFinish = function handleFinish (message, data, callback) {
      message.parser.formdata.removeAllListeners();
      message.parser.formdata = null;

      this.pass(message, data, callback);
    };

    FormdataDecoder.prototype.setValue = function setValue (data, name, value) {
      if (typeof data[name] !== 'undefined') {
        if (Array.isArray(data[name]) === true) {
          value = data[name].concat(value);
        } else {
          value = [data[name], value];
        }
      }

      data[name] = value;
    };

    FormdataDecoder.prototype.setupParser = function setupParser (message, data, callback) {
      var this$1 = this;

      var options = Object.assign({}, this._config, {
        headers: (message._original || message).headers
      });

      var formdata = new Busboy(options);
      var parsed = {};

      formdata.on('field', function (name, value) {
        this$1.setValue(parsed, name, value);
      });

      formdata.on('file', function (fieldName, stream, name, encoding, type) {
        var file = {};

        file.name = name;
        file.type = type;
        file.size = 0;

        file.tmppath =
          this$1._config.base +
          this$1._config.path +
          shortid.generate();

        var target = fs.createWriteStream(file.tmppath);

        stream.on('data', function (chunk) {
          file.size += chunk.length;
        });

        stream.once('limit', function () {
          var error = new Error('File size exceeds maximum');
          this$1.handleError(message, error, callback);
        });

        stream.once('end', function () {
          this$1.setValue(parsed, fieldName, file);
        });

        stream.once('error', function (error) {
          this$1.setValue(parsed, fieldName, error);
        });

        target.on('drain', function () {
          callback(message, true);
        });

        stream.pipe(target);
      });

      formdata.once('error', function (error) {
        this$1.handleError(message, error, callback);
      });

      formdata.once('finish', function () {
        this$1.handleFinish(message, parsed, callback);
      });

      message.parser.formdata = formdata;
    };

    return FormdataDecoder;
  }(Worker));

  var HtmlDecoder = /*@__PURE__*/(function (Worker) {
    function HtmlDecoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) HtmlDecoder.__proto__ = Worker;
    HtmlDecoder.prototype = Object.create( Worker && Worker.prototype );
    HtmlDecoder.prototype.constructor = HtmlDecoder;

    HtmlDecoder.prototype.getType = function getType () {
      return 'text/html';
    };

    HtmlDecoder.prototype.act = function act (message, data, callback) {
      if (message.state.body !== true) {
        message.parser.html = (message.parser.html || '') + data;
        return;
      }

      try {
        this.decode(message, data, callback);
      } catch (error) {
        throw new Error('400 ' + error.message);
      }
    };

    HtmlDecoder.prototype.decide = function decide (message, data) {
      return data === null ? null : true;
    };

    HtmlDecoder.prototype.decode = function decode (message, data, callback) {
      data = (message.parser.html || '') + data;
      message.parser.html = null;

      var struct = new HtmlStruct(data);

      this.pass(message, struct, callback);
    };

    return HtmlDecoder;
  }(Worker));

  var JsonDecoder = /*@__PURE__*/(function (Worker) {
    function JsonDecoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) JsonDecoder.__proto__ = Worker;
    JsonDecoder.prototype = Object.create( Worker && Worker.prototype );
    JsonDecoder.prototype.constructor = JsonDecoder;

    JsonDecoder.prototype.getType = function getType () {
      return 'application/json';
    };

    JsonDecoder.prototype.act = function act (message, data, callback) {
      if (message.state.body !== true) {
        message.parser.json = (message.parser.json || '') + data;
        return;
      }

      try {
        this.decode(message, data, callback);
      } catch (error) {
        throw new Error('400 ' + error.message);
      }
    };

    JsonDecoder.prototype.decide = function decide (message, data) {
      return data === null ? null : true;
    };

    JsonDecoder.prototype.decode = function decode (message, data, callback) {
      data = (message.parser.json || '') + data;
      message.parser.json = null;

      if (data) {
        data = JSON.parse(data);
      } else {
        data = {};
      }

      this.pass(message, data, callback);
    };

    return JsonDecoder;
  }(Worker));

  var MsgpackDecoder = /*@__PURE__*/(function (Worker) {
    function MsgpackDecoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) MsgpackDecoder.__proto__ = Worker;
    MsgpackDecoder.prototype = Object.create( Worker && Worker.prototype );
    MsgpackDecoder.prototype.constructor = MsgpackDecoder;

    MsgpackDecoder.prototype.getType = function getType () {
      return 'application/msgpack';
    };

    MsgpackDecoder.prototype.act = function act (message, data, callback) {
      if (message.state.body !== true) {
        message.parser.msgpack = (message.parser.msgpack || '') + data;
        return;
      }

      try {
        this.decode(message, data, callback);
      } catch (error) {
        throw new Error('400 ' + error.message);
      }
    };

    MsgpackDecoder.prototype.decide = function decide (message, data) {
      return data === null ? null : true;
    };

    MsgpackDecoder.prototype.decode = function decode$1 (message, data, callback) {
      data = (message.parser.msgpack || '') + data;
      message.parser.msgpack = null;

      if (data) {
        data = msgpackLite.decode(data);
      } else {
        data = {};
      }

      this.pass(message, data, callback);
    };

    return MsgpackDecoder;
  }(Worker));

  var PlainDecoder = /*@__PURE__*/(function (Worker) {
    function PlainDecoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) PlainDecoder.__proto__ = Worker;
    PlainDecoder.prototype = Object.create( Worker && Worker.prototype );
    PlainDecoder.prototype.constructor = PlainDecoder;

    PlainDecoder.prototype.getType = function getType () {
      return 'text/plain';
    };

    PlainDecoder.prototype.act = function act (message, data, callback) {
      if (message.state.body !== true) {
        message.parser.plain = (message.parser.plain || '') + data;
        return;
      }

      try {
        this.decode(message, data, callback);
      } catch (error) {
        throw new Error('400 ' + error.message);
      }
    };

    PlainDecoder.prototype.decide = function decide (message, data) {
      return data === null ? null : true;
    };

    PlainDecoder.prototype.decode = function decode (message, data, callback) {
      data = (message.parser.plain || '') + data;
      message.parser.plain = null;

      this.pass(message, data, callback);
    };

    return PlainDecoder;
  }(Worker));

  var TransferEncodingDecoder = /*@__PURE__*/(function (Manager) {
    function TransferEncodingDecoder () {
      Manager.apply(this, arguments);
    }

    if ( Manager ) TransferEncodingDecoder.__proto__ = Manager;
    TransferEncodingDecoder.prototype = Object.create( Manager && Manager.prototype );
    TransferEncodingDecoder.prototype.constructor = TransferEncodingDecoder;

    TransferEncodingDecoder.prototype.decide = function decide (message) {
      if (typeof message.body.transfer !== 'undefined') {
        return true;
      }

      var transfer = message.parseHeader('transfer-encoding');

      if (typeof transfer.values === 'undefined') {
        return false;
      }

      for (var i = 0; i < transfer.values.length; i += 1) {
        if (typeof this._pool[transfer.values[i][0]] === 'undefined') {
          throw new Error('501 Decoder not implemented' +
            " (" + (transfer[i][0]) + ")");
        }
      }

      message.body.transfer = transfer.values
        .reverse()
        .map(function (encoding) { return encoding[0]; });

      return true;
    };

    TransferEncodingDecoder.prototype.names = function names (message) {
      return message.body.transfer.slice(0);
    };

    return TransferEncodingDecoder;
  }(Manager));

  var UrlencodedDecoder = /*@__PURE__*/(function (Worker) {
    function UrlencodedDecoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) UrlencodedDecoder.__proto__ = Worker;
    UrlencodedDecoder.prototype = Object.create( Worker && Worker.prototype );
    UrlencodedDecoder.prototype.constructor = UrlencodedDecoder;

    UrlencodedDecoder.prototype.getType = function getType () {
      return 'application/x-www-form-urlencoded';
    };

    UrlencodedDecoder.prototype.act = function act (message, data, callback) {
      if (message.state.body !== true) {
        message.parser.urlencoded = (message.parser.urlencoded || '') + data;
        return;
      }

      try {
        this.decode(message, data, callback);
      } catch (error) {
        throw new Error('400 ' + error.message);
      }
    };

    UrlencodedDecoder.prototype.decide = function decide (message, data) {
      return data === null ? null : true;
    };

    UrlencodedDecoder.prototype.decode = function decode (message, data, callback) {
      data = (message.parser.urlencoded || '') + data;
      message.parser.urlencoded = null;

      if (data) {
        data = lib.parse(data);
      } else {
        data = {};
      }

      this.pass(message, data, callback);
    };

    return UrlencodedDecoder;
  }(Worker));

  var CRLF = buffer_1.from('\r\n');

  var ChunkedEncoder = /*@__PURE__*/(function (Worker) {
    function ChunkedEncoder(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._chunkLength = null;
      this.setChunkLength(options.chunkLength);
    }

    if ( Worker ) ChunkedEncoder.__proto__ = Worker;
    ChunkedEncoder.prototype = Object.create( Worker && Worker.prototype );
    ChunkedEncoder.prototype.constructor = ChunkedEncoder;

    ChunkedEncoder.prototype.getChunkLength = function getChunkLength () {
      return this._chunkLength;
    };

    ChunkedEncoder.prototype.setChunkLength = function setChunkLength (chunkLength) {
      if ( chunkLength === void 0 ) chunkLength = 64 * 1024;

      this._chunkLength = chunkLength;
      return this;
    };

    ChunkedEncoder.prototype.getEncoding = function getEncoding () {
      return 'chunked';
    };

    ChunkedEncoder.prototype.act = function act (message, data, callback) {
      if (data === null) {
        this.flush(message, data, callback);
      } else {
        this.encode(message, data, callback);
      }
    };

    ChunkedEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true;
    };

    ChunkedEncoder.prototype.encode = function encode (message, data, callback) {
      var buffer = null;
      var i = 0;
      var newLength = 0;
      var oldLength = 0;

      for (i = 0; i < data.length; i += this._chunkLength) {
        buffer = buffer_1.from(data.slice(i, i + this._chunkLength));
        oldLength = buffer.length.toString(16);
        newLength = oldLength.length + buffer.length + 4;

        this.pass(message, buffer_1.concat([
          buffer_1.from(oldLength),
          CRLF,
          buffer,
          CRLF
        ], newLength), callback);
      }
    };

    ChunkedEncoder.prototype.flush = function flush (message, data, callback) {
      message.state.body = true;

      this.pass(message, buffer_1.concat([
        buffer_1.from('0'),
        CRLF
      ], 3), callback);
    };

    return ChunkedEncoder;
  }(Worker));

  var ContentEncodingEncoder = /*@__PURE__*/(function (Manager) {
    function ContentEncodingEncoder () {
      Manager.apply(this, arguments);
    }

    if ( Manager ) ContentEncodingEncoder.__proto__ = Manager;
    ContentEncodingEncoder.prototype = Object.create( Manager && Manager.prototype );
    ContentEncodingEncoder.prototype.constructor = ContentEncodingEncoder;

    ContentEncodingEncoder.prototype.decide = function decide (message, data) {
      if (typeof message.body.content !== 'undefined') {
        return true;
      }

      if (typeof data === 'undefined') {
        return false;
      }

      var content = message.headers['content-encoding'];

      if (typeof content === 'undefined') {
        return false;
      }

      for (var i = 0; i < content.length; i += 1) {
        if (typeof this._pool[content[i]] === 'undefined') {
          throw new Error(("501 Encoder not implemented (" + (content[i]) + ")"));
        }
      }

      message.body.content = content
        .slice(0)
        .reverse();

      return true;
    };

    ContentEncodingEncoder.prototype.names = function names (message) {
      return message.body.content.slice(0);
    };

    return ContentEncodingEncoder;
  }(Manager));

  var ContentTypeEncoder = /*@__PURE__*/(function (Manager) {
    function ContentTypeEncoder(options) {
      if ( options === void 0 ) options = {};

      Manager.call(this, options);

      this._strict = null;
      this.setStrict(options.strict);
    }

    if ( Manager ) ContentTypeEncoder.__proto__ = Manager;
    ContentTypeEncoder.prototype = Object.create( Manager && Manager.prototype );
    ContentTypeEncoder.prototype.constructor = ContentTypeEncoder;

    ContentTypeEncoder.prototype.getStrict = function getStrict () {
      return this._strict;
    };

    ContentTypeEncoder.prototype.setStrict = function setStrict (value) {
      if ( value === void 0 ) value = true;

      this._strict = value;
      return this;
    };

    ContentTypeEncoder.prototype.decide = function decide (message, data) {
      if (typeof message.body.type !== 'undefined') {
        return true;
      }

      if (typeof data === 'undefined') {
        return false;
      }

      var type = message.parseHeader('content-type');

      if (typeof type.value === 'undefined') {
        return false;
      }

      if (typeof this._pool[type.value[0]] === 'undefined') {
        if (this._strict === true) {
          throw new Error('406 Encoder not implemented' +
            " (" + (type.value[0]) + ")");
        }

        return false;
      }

      message.body.type = type.value[0];
      return true;
    };

    ContentTypeEncoder.prototype.names = function names (message) {
      return [message.body.type];
    };

    return ContentTypeEncoder;
  }(Manager));

  var CsvEncoder = /*@__PURE__*/(function (Worker) {
    function CsvEncoder(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._delimiter = null;
      this._fields = null;
      this._lineEnding = null;

      this.setDelimiter(options.delimiter);
      this.setFields(options.fields);
      this.setLineEnding(options.lineEnding);
    }

    if ( Worker ) CsvEncoder.__proto__ = Worker;
    CsvEncoder.prototype = Object.create( Worker && Worker.prototype );
    CsvEncoder.prototype.constructor = CsvEncoder;

    CsvEncoder.prototype.getDelimiter = function getDelimiter () {
      return this._delimiter;
    };

    CsvEncoder.prototype.setDelimiter = function setDelimiter (value) {
      if ( value === void 0 ) value = ',';

      this._delimiter = value;
      return this;
    };

    CsvEncoder.prototype.getFields = function getFields () {
      return this._fields;
    };

    CsvEncoder.prototype.setFields = function setFields (value) {
      if ( value === void 0 ) value = [];

      this._fields = value;
      return this;
    };

    CsvEncoder.prototype.getLineEnding = function getLineEnding () {
      return this._lineEnding;
    };

    CsvEncoder.prototype.setLineEnding = function setLineEnding (value) {
      if ( value === void 0 ) value = 'LF';

      this._lineEnding = value;
      return this;
    };

    CsvEncoder.prototype.getType = function getType () {
      return 'text/csv';
    };

    CsvEncoder.prototype.act = function act (message, data, callback) {
      try {
        this.encode(message, data, callback);
      } catch (error) {
        throw new Error('500 ' + error.message);
      }
    };

    CsvEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true &&
        message.body.dataType !== this.getType();
    };

    CsvEncoder.prototype.encode = function encode (message, data, callback) {
      var struct = new CsvStruct({
        delimiter: this._delimiter,
        fields: this._fields,
        lineEnding: this._lineEnding
      }, data);

      data = struct.encode();

      message.body.length = buffer_1.byteLength(data);
      message.state.body = true;

      this.pass(message, data, callback);
    };

    return CsvEncoder;
  }(Worker));

  var FormdataEncoder = /*@__PURE__*/(function (Worker) {
    function FormdataEncoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) FormdataEncoder.__proto__ = Worker;
    FormdataEncoder.prototype = Object.create( Worker && Worker.prototype );
    FormdataEncoder.prototype.constructor = FormdataEncoder;

    FormdataEncoder.prototype.getType = function getType () {
      return 'multipart/form-data';
    };

    FormdataEncoder.prototype.act = function act (message, data, callback) {
      try {
        this.encode(message, data, callback);
      } catch (error) {
        throw new Error('500 ' + error.message);
      }
    };

    FormdataEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true &&
        message.body.dataType !== this.getType();
    };

    FormdataEncoder.prototype.encode = function encode (message, data, callback) {
      var keys = Object.keys(data);
      var form = new FormData();

      var name = null;
      var value = null;

      for (var i = 0; i < keys.length; i += 1) {
        name = keys[i];
        value = data[name];
        value = Array.isArray(value) ? value : [value];

        for (var j = 0; j < value.length; j += 1) {
          form.append(name, value[j]);
        }
      }

      message.state.body = true;

      this.pass(message, form, callback);
    };

    return FormdataEncoder;
  }(Worker));

  var HtmlEncoder = /*@__PURE__*/(function (Worker) {
    function HtmlEncoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) HtmlEncoder.__proto__ = Worker;
    HtmlEncoder.prototype = Object.create( Worker && Worker.prototype );
    HtmlEncoder.prototype.constructor = HtmlEncoder;

    HtmlEncoder.prototype.getType = function getType () {
      return 'text/html';
    };

    HtmlEncoder.prototype.act = function act (message, data, callback) {
      try {
        this.encode(message, data, callback);
      } catch (error) {
        throw new Error('500 ' + error.message);
      }
    };

    HtmlEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true &&
        message.body.dataType !== this.getType();
    };

    HtmlEncoder.prototype.encode = function encode (message, data, callback) {
      data = data.encode();

      message.body.length = buffer_1.byteLength(data);
      message.state.body = true;

      this.pass(message, data, callback);
    };

    return HtmlEncoder;
  }(Worker));

  var JsonEncoder = /*@__PURE__*/(function (Worker) {
    function JsonEncoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) JsonEncoder.__proto__ = Worker;
    JsonEncoder.prototype = Object.create( Worker && Worker.prototype );
    JsonEncoder.prototype.constructor = JsonEncoder;

    JsonEncoder.prototype.getType = function getType () {
      return 'application/json';
    };

    JsonEncoder.prototype.act = function act (message, data, callback) {
      try {
        this.encode(message, data, callback);
      } catch (error) {
        throw new Error('500 ' + error.message);
      }
    };

    JsonEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true &&
        message.body.dataType !== this.getType();
    };

    JsonEncoder.prototype.encode = function encode (message, data, callback) {
      data = JSON.stringify(data);

      message.body.length = buffer_1.byteLength(data);
      message.state.body = true;

      this.pass(message, data, callback);
    };

    return JsonEncoder;
  }(Worker));

  var MsgpackEncoder = /*@__PURE__*/(function (Worker) {
    function MsgpackEncoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) MsgpackEncoder.__proto__ = Worker;
    MsgpackEncoder.prototype = Object.create( Worker && Worker.prototype );
    MsgpackEncoder.prototype.constructor = MsgpackEncoder;

    MsgpackEncoder.prototype.getType = function getType () {
      return 'application/msgpack';
    };

    MsgpackEncoder.prototype.act = function act (message, data, callback) {
      try {
        this.encode(message, data, callback);
      } catch (error) {
        throw new Error('500 ' + error.message);
      }
    };

    MsgpackEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true &&
        message.body.dataType !== this.getType();
    };

    MsgpackEncoder.prototype.encode = function encode$1 (message, data, callback) {
      data = msgpackLite.encode(data);

      message.body.length = buffer_1.byteLength(data);
      message.state.body = true;

      this.pass(message, data, callback);
    };

    return MsgpackEncoder;
  }(Worker));

  var PlainEncoder = /*@__PURE__*/(function (Worker) {
    function PlainEncoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) PlainEncoder.__proto__ = Worker;
    PlainEncoder.prototype = Object.create( Worker && Worker.prototype );
    PlainEncoder.prototype.constructor = PlainEncoder;

    PlainEncoder.prototype.getType = function getType () {
      return 'text/plain';
    };

    PlainEncoder.prototype.act = function act (message, data, callback) {
      try {
        this.encode(message, data, callback);
      } catch (error) {
        throw new Error('500 ' + error.message);
      }
    };

    PlainEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true &&
        message.body.dataType !== this.getType();
    };

    PlainEncoder.prototype.encode = function encode (message, data, callback) {
      data = String(data);

      message.body.length = buffer_1.byteLength(data);
      message.state.body = true;

      this.pass(message, data, callback);
    };

    return PlainEncoder;
  }(Worker));

  var TransferEncodingEncoder = /*@__PURE__*/(function (Manager) {
    function TransferEncodingEncoder () {
      Manager.apply(this, arguments);
    }

    if ( Manager ) TransferEncodingEncoder.__proto__ = Manager;
    TransferEncodingEncoder.prototype = Object.create( Manager && Manager.prototype );
    TransferEncodingEncoder.prototype.constructor = TransferEncodingEncoder;

    TransferEncodingEncoder.prototype.decide = function decide (message, data) {
      if (typeof message.body.transfer !== 'undefined') {
        return true;
      }

      if (typeof data === 'undefined') {
        return false;
      }

      var transfer = message.headers['transfer-encoding'];

      if (typeof transfer === 'undefined') {
        return false;
      }

      for (var i = 0; i < transfer.length; i += 1) {
        if (typeof this._pool[transfer[i]] === 'undefined') {
          throw new Error(("501 Encoder not implemented (" + (transfer[i]) + ")"));
        }
      }

      message.body.transfer = transfer
        .slice(0)
        .reverse();

      return true;
    };

    TransferEncodingEncoder.prototype.names = function names (message) {
      return message.body.transfer.slice(0);
    };

    return TransferEncodingEncoder;
  }(Manager));

  var UrlencodedEncoder = /*@__PURE__*/(function (Worker) {
    function UrlencodedEncoder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) UrlencodedEncoder.__proto__ = Worker;
    UrlencodedEncoder.prototype = Object.create( Worker && Worker.prototype );
    UrlencodedEncoder.prototype.constructor = UrlencodedEncoder;

    UrlencodedEncoder.prototype.getType = function getType () {
      return 'application/x-www-form-urlencoded';
    };

    UrlencodedEncoder.prototype.act = function act (message, data, callback) {
      try {
        this.encode(message, data, callback);
      } catch (error) {
        throw new Error('500 ' + error.message);
      }
    };

    UrlencodedEncoder.prototype.decide = function decide (message) {
      return message.state.body !== true &&
        message.body.dataType !== this.getType();
    };

    UrlencodedEncoder.prototype.encode = function encode (message, data, callback) {
      data = lib.stringify(data);

      message.body.length = buffer_1.byteLength(data);
      message.state.body = true;

      this.pass(message, data, callback);
    };

    return UrlencodedEncoder;
  }(Worker));

  var ConnectionHeader = /*@__PURE__*/(function (Worker) {
    function ConnectionHeader () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) ConnectionHeader.__proto__ = Worker;
    ConnectionHeader.prototype = Object.create( Worker && Worker.prototype );
    ConnectionHeader.prototype.constructor = ConnectionHeader;

    ConnectionHeader.prototype.act = function act (message, data, callback) {
      this.setHeader(message);
      this.pass(message, data, callback);
    };

    ConnectionHeader.prototype.decide = function decide (message) {
      return typeof message.headers.connection === 'undefined';
    };

    ConnectionHeader.prototype.err = function err (message, data, callback) {
      this.setHeader(message);
      this.fail(message, data, callback);
    };

    ConnectionHeader.prototype.setHeader = function setHeader (message) {
      if (message.status) {
        this.setResponseHeader(message);
      } else {
        this.setRequestHeader(message);
      }
    };

    ConnectionHeader.prototype.setRequestHeader = function setRequestHeader (message) {
      message.headers.connection = 'keep-alive';
    };

    ConnectionHeader.prototype.setResponseHeader = function setResponseHeader (message) {
      message.headers.connection = 'close';

      if (
        message.protocol.version === '1.1' &&
        message.status === 200
      ) {
        message.headers.connection = 'keep-alive';
      }
    };

    return ConnectionHeader;
  }(Worker));

  var ContentEncodingHeader = /*@__PURE__*/(function (Worker) {
    function ContentEncodingHeader(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._encodings = null;
      this.setEncodings(options.encodings);
    }

    if ( Worker ) ContentEncodingHeader.__proto__ = Worker;
    ContentEncodingHeader.prototype = Object.create( Worker && Worker.prototype );
    ContentEncodingHeader.prototype.constructor = ContentEncodingHeader;

    ContentEncodingHeader.prototype.getEncodings = function getEncodings () {
      return this._encodings;
    };

    ContentEncodingHeader.prototype.setEncodings = function setEncodings (value) {
      if ( value === void 0 ) value = [];

      this._encodings = value;
      return this;
    };

    ContentEncodingHeader.prototype.addEncoding = function addEncoding (value) {
      this._encondings.push(value);
      return this;
    };

    ContentEncodingHeader.prototype.act = function act (message, data, callback) {
      var acceptable = message
        .parseHeader('accept-encoding')
        .parseAcceptable('*');

      var preferred = message.headers['content-encoding'];
      var actual = [];

      var accept = null;
      var prefer = null;

      for (var i = 0; i < preferred.length; i += 1) {
        prefer = preferred[i];

        for (var j = 0; j < acceptable.length; j += 1) {
          if (acceptable[j].q === 0) {
            continue;
          }

          accept = acceptable[j][0];

          if (accept === '*' || prefer === accept) {
            actual.push(prefer);
            break;
          }
        }
      }

      message.body.content = actual;

      if (actual.length > 0) {
        message.headers['content-encoding'] = actual;
      } else {
        delete message.headers['content-encoding'];
      }

      this.pass(message, data, callback);
    };

    ContentEncodingHeader.prototype.decide = function decide (message, data) {
      if (
        typeof data !== 'undefined' &&
        typeof message.headers['content-encoding'] !== 'undefined' &&
        typeof message.body.content === 'undefined'
      ) {
        return true;
      }

      return false;
    };

    return ContentEncodingHeader;
  }(Worker));

  var ContentLengthHeader = /*@__PURE__*/(function (Worker) {
    function ContentLengthHeader () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) ContentLengthHeader.__proto__ = Worker;
    ContentLengthHeader.prototype = Object.create( Worker && Worker.prototype );
    ContentLengthHeader.prototype.constructor = ContentLengthHeader;

    ContentLengthHeader.prototype.act = function act (message, data, callback) {
      this.setHeader(message, data);
      this.pass(message, data, callback);
    };

    ContentLengthHeader.prototype.decide = function decide (message) {
      if (typeof message.headers['content-length'] !== 'undefined') {
        return false;
      }

      var encoding = message.headers['transfer-encoding'] || '';
      return encoding.indexOf('chunked') === -1;
    };

    ContentLengthHeader.prototype.err = function err (message, data, callback) {
      this.setHeader(message, data);
      this.fail(message, data, callback);
    };

    ContentLengthHeader.prototype.setHeader = function setHeader (message, data) {
      var length = 0;

      if (typeof message.body.length !== 'undefined') {
        length = message.body.length;
      }

      if (typeof data !== 'undefined' && data !== null) {
        length = buffer_1.byteLength(data);
      }

      message.headers['content-length'] = length;
    };

    return ContentLengthHeader;
  }(Worker));

  var methods = ['POST', 'PUT'];

  var ContentTypeHeader = /*@__PURE__*/(function (Worker) {
    function ContentTypeHeader(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._types = null;
      this.setTypes(options.types);
    }

    if ( Worker ) ContentTypeHeader.__proto__ = Worker;
    ContentTypeHeader.prototype = Object.create( Worker && Worker.prototype );
    ContentTypeHeader.prototype.constructor = ContentTypeHeader;

    ContentTypeHeader.prototype.getTypes = function getTypes () {
      return this._types;
    };

    ContentTypeHeader.prototype.setTypes = function setTypes (value) {
      if ( value === void 0 ) value = [];

      this._types = value;
      return this;
    };

    ContentTypeHeader.prototype.addType = function addType (value) {
      this._types.push(value);
      return this;
    };

    ContentTypeHeader.prototype.act = function act (message, data, callback) {
      this.setHeader(message, data);
      this.pass(message, data, callback);
    };

    ContentTypeHeader.prototype.setHeader = function setHeader (message, data) {
      if (message.status) {
        this.setResponseHeader(message);
      } else {
        this.setRequestHeader(message, data);
      }
    };

    ContentTypeHeader.prototype.setRequestHeader = function setRequestHeader (message, data) {
      if (methods.indexOf(message.method) === -1) {
        return;
      }

      var keys = Object.keys(data);

      var key = null;
      var type = this._types[0];
      var values = null;

      for (var i = 0; i < keys.length; i += 1) {
        key = keys[i];

        values = data[key];
        values = Array.isArray(values) ? values : [values];

        for (var j = 0; j < values.length; j += 1) {
          if (values[j] instanceof File) {
            type = 'multipart/form-data';
          }
        }
      }

      if (this._types.indexOf(type) > -1) {
        message.headers['content-type'] = type;
      }
    };

    ContentTypeHeader.prototype.setResponseHeader = function setResponseHeader (message) {
      var assign, assign$1;

      var acceptable = message
        .parseHeader('Accept')
        .parseAcceptable('*/*');

      var asub = null;
      var atype = null;

      var isub = null;
      var itype = null;

      var msub = null;
      var mtype = null;

      for (var i = 0; i < acceptable.length; i += 1) {
        if (acceptable[i].q === 0) {
          continue;
        }

        for (var j = 0; j < this._types.length; j += 1) {
          (assign = acceptable[i][0].split('/'), atype = assign[0], asub = assign[1]);
          (assign$1 = this._types[j].split('/'), itype = assign$1[0], isub = assign$1[1]);

          mtype = atype === '*' || atype === itype;
          msub = asub === '*' || asub === isub;

          if (mtype === true && msub === true) {
            message.headers['content-type'] = this._types[j];
            break;
          }
        }
      }
    };

    ContentTypeHeader.prototype.decide = function decide (message, data) {
      if (
        typeof data !== 'undefined' &&
        typeof message.headers['content-type'] === 'undefined'
      ) {
        return true;
      }

      return false;
    };

    return ContentTypeHeader;
  }(Worker));

  var DateHeader = /*@__PURE__*/(function (Worker) {
    function DateHeader(options) {
      Worker.call(this, options);

      this._date = null;

      this.setDate();
      this.setInterval();
    }

    if ( Worker ) DateHeader.__proto__ = Worker;
    DateHeader.prototype = Object.create( Worker && Worker.prototype );
    DateHeader.prototype.constructor = DateHeader;

    DateHeader.prototype.act = function act (message, data, callback) {
      this.setHeader(message);
      this.pass(message, data, callback);
    };

    DateHeader.prototype.decide = function decide (message) {
      return typeof message.headers.date === 'undefined';
    };

    DateHeader.prototype.err = function err (message, data, callback) {
      this.setHeader(message);
      this.fail(message, data, callback);
    };

    DateHeader.prototype.setHeader = function setHeader (message) {
      message.headers.date = this._date;
    };

    DateHeader.prototype.setDate = function setDate () {
      this._date = new Date().toUTCString();
    };

    DateHeader.prototype.setInterval = function setInterval$1 () {
      var this$1 = this;

      setInterval(function () { return this$1.setDate(); }, 1000);
    };

    return DateHeader;
  }(Worker));

  var TransferEncodingHeader = /*@__PURE__*/(function (Worker) {
    function TransferEncodingHeader(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._encodings = null;
      this.setEncodings(options.encodings);
    }

    if ( Worker ) TransferEncodingHeader.__proto__ = Worker;
    TransferEncodingHeader.prototype = Object.create( Worker && Worker.prototype );
    TransferEncodingHeader.prototype.constructor = TransferEncodingHeader;

    TransferEncodingHeader.prototype.getEncodings = function getEncodings () {
      return this._encodings;
    };

    TransferEncodingHeader.prototype.setEncodings = function setEncodings (value) {
      if ( value === void 0 ) value = [];

      this._encodings = value;
      return this;
    };

    TransferEncodingHeader.prototype.addEncoding = function addEncoding (value) {
      this._encondings.push(value);
      return this;
    };

    TransferEncodingHeader.prototype.act = function act (message, data, callback) {
      var acceptable = message
        .parseHeader('TE')
        .parseAcceptable('*');

      var preferred = message.headers['transfer-encoding'];
      var actual = [];

      var accept = null;
      var prefer = null;

      for (var i = 0; i < preferred.length; i += 1) {
        prefer = preferred[i];

        if (prefer === 'chunked') {
          actual.push(prefer);
          continue;
        }

        for (var j = 0; j < acceptable.length; j += 1) {
          if (acceptable[j].q === 0) {
            continue;
          }

          accept = acceptable[j][0];

          if (accept === '*' || prefer === accept) {
            actual.push(prefer);
            break;
          }
        }
      }

      message.body.transfer = actual;

      if (actual.length > 0) {
        message.headers['transfer-encoding'] = actual;
      } else {
        delete message.headers['transfer-encoding'];
      }

      this.pass(message, data, callback);
    };

    TransferEncodingHeader.prototype.decide = function decide (message, data) {
      if (
        typeof data !== 'undefined' &&
        typeof message.headers['transfer-encoding'] !== 'undefined' &&
        typeof message.body.transfer === 'undefined'
      ) {
        return true;
      }

      return false;
    };

    return TransferEncodingHeader;
  }(Worker));

  var BrowserMediator = /*@__PURE__*/(function (Worker) {
    function BrowserMediator () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) BrowserMediator.__proto__ = Worker;
    BrowserMediator.prototype = Object.create( Worker && Worker.prototype );
    BrowserMediator.prototype.constructor = BrowserMediator;

    BrowserMediator.prototype.act = function act (request, data, callback) {
      if ( callback === void 0 ) callback = function () {};

      this.handleProgress(request, data, callback);
      this.bindSocket(request, data, callback);
      this.setHeaders(request);

      request.socket.send(data);
    };

    BrowserMediator.prototype.err = function err (request, error, callback) {
      this.fail(request.createResponse(), error, callback);
    };

    BrowserMediator.prototype.bindSocket = function bindSocket (request, data, callback) {
      var this$1 = this;

      request.socket.onerror = function () {
        this$1.handleError(request, data, callback);
      };

      request.socket.onload = function () {
        this$1.handleLoad(request, data, callback);
      };

      request.socket.onprogress = function (event) {
        this$1.handleProgress(request, data, callback, event);
      };

      request.socket.upload.onprogress = request.socket.onprogress;
    };

    BrowserMediator.prototype.unbindSocket = function unbindSocket (request) {
      request.socket.onerror = null;
      request.socket.onload = null;
      request.socket.onprogress = null;
      request.socket.upload.onprogress = null;
    };

    BrowserMediator.prototype.handleError = function handleError (request, data, callback) {
      this.handleProgress(request, data, callback, { total: 1 });
      this.unbindSocket(request);

      var response = request.createResponse();
      response.status = request.socket.status;

      var error = new Error(
        (request.socket.status ? request.socket.status + ' ' : '') +
        'Could not complete request'
      );

      this.fail(response, error);
    };

    BrowserMediator.prototype.handleLoad = function handleLoad (request, data, callback) {
      this.handleProgress(request, data, callback, { total: 1 });
      this.unbindSocket(request);

      var responseText = request.socket.responseText;
      var responseHeaders = request.socket.getAllResponseHeaders();

      if (responseHeaders.match('content-length') === null) {
        responseHeaders = responseHeaders
          .replace(/(content|transfer)-encoding.+\r\n/g, '');

        responseHeaders = 'content-length: ' +
          buffer_1.byteLength(responseText) + '\r\n' +
          responseHeaders;
      }

      var responseData = 'HTTP/1.1 ' +
        request.socket.status + ' ' + request.socket.statusText + '\r\n' +
        responseHeaders +
        (responseHeaders.slice(-4) === '\r\n\r\n' ? '' : '\r\n') +
        responseText;

      this.pass(
        request.createResponse(),
        buffer_1.from(responseData),
        callback
      );
    };

    BrowserMediator.prototype.handleProgress = function handleProgress (request, data, callback, event) {
      if ( event === void 0 ) event = {};

      callback(defaultsDeep$1(event, {
        lengthComputable: true,
        loaded: 1,
        total: 10
      }));
    };

    BrowserMediator.prototype.setHeaders = function setHeaders (request) {
      var names = Object.keys(request.headers || {});
      var name = null;

      for (var i = 0; i < names.length; i += 1) {
        name = names[i];

        if (request.headers[name] === 'multipart/form-data') {
          continue;
        }

        request.socket.setRequestHeader(name, request.headers[name]);
      }
    };

    return BrowserMediator;
  }(Worker));

  var ClientMediator = /*@__PURE__*/(function (Streamer) {
    function ClientMediator () {
      Streamer.apply(this, arguments);
    }

    if ( Streamer ) ClientMediator.__proto__ = Streamer;
    ClientMediator.prototype = Object.create( Streamer && Streamer.prototype );
    ClientMediator.prototype.constructor = ClientMediator;

    ClientMediator.prototype.act = function act (request) {
      this.read(request.createResponse());
    };

    ClientMediator.prototype.err = function err (request, error, callback) {
      this.fail(request.createResponse(), error, callback);
    };

    ClientMediator.prototype.stream = function stream (response) {
      return response.socket;
    };

    return ClientMediator;
  }(Streamer));

  var BodyParser = /*@__PURE__*/(function (Worker) {
    function BodyParser(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._maxLength = null;
      this.setMaxLength(options.maxLength);
    }

    if ( Worker ) BodyParser.__proto__ = Worker;
    BodyParser.prototype = Object.create( Worker && Worker.prototype );
    BodyParser.prototype.constructor = BodyParser;

    BodyParser.prototype.getMaxLength = function getMaxLength () {
      return this._maxLength;
    };

    BodyParser.prototype.setMaxLength = function setMaxLength (maxLength) {
      if ( maxLength === void 0 ) maxLength = -1;

      this._maxLength = maxLength;
      return this;
    };

    BodyParser.prototype.act = function act (message, data, callback) {
      var contentLength = message.headers['content-length'];

      if (typeof contentLength !== 'undefined') {
        contentLength = Number(contentLength);

        if (Number.isNaN(contentLength)) {
          throw new Error('411 Invalid Content-Length header');
        }

        message.headers['content-length'] = contentLength;
      } else {
        contentLength = 0;
      }

      if (this._maxLength > -1) {
        if (contentLength > this._maxLength) {
          throw new Error('413 Content length exceeds maximum');
        }
      }

      data = data.slice(message.parser.begin);

      message.body.length = (message.body.length || 0) + data.length;
      message.parser.begin = 0;

      if (message.body.length > contentLength) {
        data = data.slice(0, contentLength - message.body.length);
        message.body.length = contentLength;
      }

      if (message.body.length === contentLength) {
        message.state.body = true;
      }

      if (this._maxLength > -1) {
        if (message.body.length > this._maxLength) {
          throw new Error('413 Body length exceeds maximum');
        }
      }

      if (data.length === 0) {
        data = '';
      }

      this.pass(message, data, callback);
    };

    BodyParser.prototype.decide = function decide (message, data) {
      var encoding = message.headers['transfer-encoding'] || '';

      if (
        data !== null &&
        message.state.body !== true &&
        encoding.indexOf('chunked') === -1
      ) {
        return true;
      }

      return false;
    };

    return BodyParser;
  }(Worker));

  var HeaderFieldsParser = /*@__PURE__*/(function (Worker) {
    function HeaderFieldsParser(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._maxLength = null;
      this.setMaxLength(options.maxLength);
    }

    if ( Worker ) HeaderFieldsParser.__proto__ = Worker;
    HeaderFieldsParser.prototype = Object.create( Worker && Worker.prototype );
    HeaderFieldsParser.prototype.constructor = HeaderFieldsParser;

    HeaderFieldsParser.prototype.getMaxLength = function getMaxLength () {
      return this._maxLength;
    };

    HeaderFieldsParser.prototype.setMaxLength = function setMaxLength (maxLength) {
      if ( maxLength === void 0 ) maxLength = 8 * 1024;

      this._maxLength = maxLength;
      return this;
    };

    HeaderFieldsParser.prototype.act = function act (message, data, callback) {
      for (; message.parser.end < data.length; message.parser.end += 1) {
        if (message.state.headers === true) {
          break;
        }

        this.processCode(message, data);
      }

      if (message.state.headers === true) {
        this.pass(message, data, callback);
      } else {
        message.parser.data = data.slice(message.parser.begin);
      }
    };

    HeaderFieldsParser.prototype.decide = function decide (message) {
      return message.state.headers !== true;
    };

    HeaderFieldsParser.prototype.processCode = function processCode (message, data) {
      message.parser.length = (message.parser.length || 0) + 1;

      if (message.parser.length > this._maxLength) {
        throw new Error('413 Header length exceeds maximum');
      }

      var code = data[message.parser.end];

      if (code === 32) {
        this.processSpace(message, data);
      } else if (code === 58) {
        this.processColon(message, data);
      } else if (code === 10) {
        this.processLineFeed(message, data);
      } else if (code !== 13) {
        message.parser.spaces = 0;
      }
    };

    HeaderFieldsParser.prototype.processColon = function processColon (message, data) {
      if (message.parser.key) {
        return;
      }

      message.parser.key = data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end - message.parser.spaces
      );

      message.parser.begin = message.parser.end + 1;
    };

    HeaderFieldsParser.prototype.processLineFeed = function processLineFeed (message, data) {
      var next = data[message.parser.end + 1];

      if (next === 9 || next === 32) {
        return;
      }

      if (!message.parser.key) {
        message.parser.begin = message.parser.end + 1;
        message.parser.length = null;
        message.parser.spaces = null;
        message.state.headers = true;
        return;
      }

      var key = message.parser.key.toLowerCase();

      var value = data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end - message.parser.spaces - 1
      );

      if (typeof message.headers[key] !== 'undefined') {
        if (message.headers[key].indexOf(value) === -1) {
          value = message.headers[key] + ', ' + value;
        }
      }

      message.headers[key] = value;
      message.parser.key = null;
      message.parser.begin = message.parser.end + 1;
    };

    HeaderFieldsParser.prototype.processSpace = function processSpace (message) {
      if (message.parser.begin === message.parser.end) {
        message.parser.begin = message.parser.end + 1;
      } else {
        message.parser.spaces += 1;
      }
    };

    return HeaderFieldsParser;
  }(Worker));

  var RequestLineParser = /*@__PURE__*/(function (Worker) {
    function RequestLineParser(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._maxLength = null;
      this.setMaxLength(options.maxLength);
    }

    if ( Worker ) RequestLineParser.__proto__ = Worker;
    RequestLineParser.prototype = Object.create( Worker && Worker.prototype );
    RequestLineParser.prototype.constructor = RequestLineParser;

    RequestLineParser.prototype.getMaxLength = function getMaxLength () {
      return this._maxLength;
    };

    RequestLineParser.prototype.setMaxLength = function setMaxLength (maxLength) {
      if ( maxLength === void 0 ) maxLength = 8 * 1024;

      this._maxLength = maxLength;
      return this;
    };

    RequestLineParser.prototype.act = function act (message, data, callback) {
      for (; message.parser.end < data.length; message.parser.end += 1) {
        if (message.state.line === true) {
          break;
        }

        this.processCode(message, data);
      }

      if (message.state.line === true) {
        this.pass(message, data, callback);
      } else {
        message.parser.data = data.slice(message.parser.begin);
      }
    };

    RequestLineParser.prototype.decide = function decide (message) {
      return message.state.line !== true;
    };

    RequestLineParser.prototype.processCode = function processCode (message, data) {
      message.parser.length = (message.parser.length || 0) + 1;

      if (message.parser.length > this._maxLength) {
        throw new Error('413 Header length exceeds maximum');
      }

      var code = data[message.parser.end];

      if (code === 32) {
        this.processSpace(message, data);
      } else if (code === 47) {
        this.processSlash(message, data);
      } else if (code === 10) {
        this.processLineFeed(message, data);
      }
    };

    RequestLineParser.prototype.processLineFeed = function processLineFeed (message, data) {
      this.processProtocolVersion(message, data);
      message.state.line = true;
    };

    RequestLineParser.prototype.processMethod = function processMethod (message, data) {
      message.method = data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end
      );

      message.parser.begin = message.parser.end + 1;
    };

    RequestLineParser.prototype.processProtocolName = function processProtocolName (message, data) {
      message.protocol.name = data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end
      );

      message.parser.begin = message.parser.end + 1;
    };

    RequestLineParser.prototype.processProtocolVersion = function processProtocolVersion (message, data) {
      message.protocol.version = data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end - 1
      );

      message.parser.begin = message.parser.end + 1;
    };

    RequestLineParser.prototype.processSlash = function processSlash (message, data) {
      if (typeof message.url !== 'undefined') {
        this.processProtocolName(message, data);
      }
    };

    RequestLineParser.prototype.processSpace = function processSpace (message, data) {
      if (message.parser.begin === 0) {
        this.processMethod(message, data);
      } else {
        this.processUrl(message, data);
      }
    };

    RequestLineParser.prototype.processUrl = function processUrl (message, data) {
      message.url = Url.parse(data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end
      ));

      message.parser.begin = message.parser.end + 1;
    };

    return RequestLineParser;
  }(Worker));

  var ResponseLineParser = /*@__PURE__*/(function (Worker) {
    function ResponseLineParser(options) {
      if ( options === void 0 ) options = {};

      Worker.call(this, options);

      this._maxLength = null;
      this.setMaxLength(options.maxLength);
    }

    if ( Worker ) ResponseLineParser.__proto__ = Worker;
    ResponseLineParser.prototype = Object.create( Worker && Worker.prototype );
    ResponseLineParser.prototype.constructor = ResponseLineParser;

    ResponseLineParser.prototype.getMaxLength = function getMaxLength () {
      return this._maxLength;
    };

    ResponseLineParser.prototype.setMaxLength = function setMaxLength (maxLength) {
      if ( maxLength === void 0 ) maxLength = 8 * 1024;

      this._maxLength = maxLength;
      return this;
    };

    ResponseLineParser.prototype.act = function act (message, data, callback) {
      if (
        data === null ||
        data.length === 0
      ) {
        throw new Error('Empty reply from server');
      }

      for (; message.parser.end < data.length; message.parser.end += 1) {
        if (message.state.line === true) {
          break;
        }

        this.processCode(message, data);
      }

      if (message.state.line === true) {
        this.pass(message, data, callback);
      } else {
        message.parser.data = data.slice(message.parser.begin);
      }
    };

    ResponseLineParser.prototype.decide = function decide (message) {
      return message.state.line !== true;
    };

    ResponseLineParser.prototype.processCode = function processCode (message, data) {
      message.parser.length = (message.parser.length || 0) + 1;

      if (message.parser.length > this._maxLength) {
        throw new Error('413 Header length exceeds maximum');
      }

      var code = data[message.parser.end];

      if (code === 32) {
        this.processSpace(message, data);
      } else if (code === 47) {
        this.processSlash(message, data);
      } else if (code === 10) {
        this.processLineFeed(message, data);
      }
    };

    ResponseLineParser.prototype.processLineFeed = function processLineFeed (message) {
      message.parser.begin = message.parser.end + 1;
      message.state.line = true;
    };

    ResponseLineParser.prototype.processProtocolName = function processProtocolName (message, data) {
      message.protocol.name = data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end
      );

      message.parser.begin = message.parser.end + 1;
    };

    ResponseLineParser.prototype.processProtocolVersion = function processProtocolVersion (message, data) {
      message.protocol.version = data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end
      );

      message.parser.begin = message.parser.end + 1;
    };

    ResponseLineParser.prototype.processSlash = function processSlash (message, data) {
      if (typeof message.protocol.name === 'undefined') {
        this.processProtocolName(message, data);
      }
    };

    ResponseLineParser.prototype.processSpace = function processSpace (message, data) {
      if (typeof message.protocol.version === 'undefined') {
        this.processProtocolVersion(message, data);
      } else if (typeof message.status === 'undefined') {
        this.processStatus(message, data);
      }
    };

    ResponseLineParser.prototype.processStatus = function processStatus (message, data) {
      message.status = Number(data.toString(
        'utf-8',
        message.parser.begin,
        message.parser.end
      ));

      message.parser.begin = message.parser.end + 1;
    };

    return ResponseLineParser;
  }(Worker));

  var TrailerFieldsParser = /*@__PURE__*/(function (HeaderFieldsParser) {
    function TrailerFieldsParser () {
      HeaderFieldsParser.apply(this, arguments);
    }

    if ( HeaderFieldsParser ) TrailerFieldsParser.__proto__ = HeaderFieldsParser;
    TrailerFieldsParser.prototype = Object.create( HeaderFieldsParser && HeaderFieldsParser.prototype );
    TrailerFieldsParser.prototype.constructor = TrailerFieldsParser;

    TrailerFieldsParser.prototype.act = function act (message, data, callback) {
      message.parser.begin = 0;
      message.parser.end = 0;
      message.parser.trailer = true;

      HeaderFieldsParser.prototype.act.call(this, message, data, callback);
    };

    TrailerFieldsParser.prototype.decide = function decide (message, data) {
      return data !== null &&
        message.state.body === true &&
        message.state.headers === false;
    };

    TrailerFieldsParser.prototype.pass = function pass (message, data, callback) {
      if (message.state.headers === true) {
        if (message.parser.trailer === true) {
          data = data.slice(message.parser.end);
        }

        HeaderFieldsParser.prototype.pass.call(this, message, data, callback);
      }
    };

    return TrailerFieldsParser;
  }(HeaderFieldsParser));

  var DataResolver = /*@__PURE__*/(function (Worker) {
    function DataResolver () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) DataResolver.__proto__ = Worker;
    DataResolver.prototype = Object.create( Worker && Worker.prototype );
    DataResolver.prototype.constructor = DataResolver;

    DataResolver.prototype.act = function act (request, data, callback) {
      var response = request.createResponse();

      if (typeof data.status === 'undefined') {
        data.status = request.method === 'POST' ? 201 : 200;
      }

      if (typeof response.status === 'undefined') {
        response.status = data.status;
      }

      this.pass(response, data, callback);
    };

    DataResolver.prototype.decide = function decide (request, data) {
      if (
        request.method !== 'GET' ||
        typeof data.data !== 'undefined'
      ) {
        return true;
      }

      return false;
    };

    return DataResolver;
  }(Worker));

  var FileResolver = /*@__PURE__*/(function (Streamer) {
    function FileResolver () {
      Streamer.apply(this, arguments);
    }

    if ( Streamer ) FileResolver.__proto__ = Streamer;
    FileResolver.prototype = Object.create( Streamer && Streamer.prototype );
    FileResolver.prototype.constructor = FileResolver;

    FileResolver.prototype.act = function act (request, data, callback) {
      var this$1 = this;

      var response = request.createResponse();

      if (typeof data.status === 'undefined') {
        data.status = 200;
      }

      if (typeof response.status === 'undefined') {
        response.status = data.status;
      }

      fs$1.stat(data.file.path, function (error, stats) {
        if (error) {
          return this$1.handleError(request, error, callback);
        }

        response.headers['content-length'] = stats.size;
        response.headers['content-type'] = data.file.type;

        if (data.file.path.slice(-3) === '.gz') {
          response.headers['content-encoding'] = ['gzip'];
        }

        return this$1.read(response, data);
      });
    };

    FileResolver.prototype.handleError = function handleError (request, error, callback) {
      var newError = new Error(("404 File not found (" + (error.message) + ")"));
      this.fail(request, newError, callback);
    };

    FileResolver.prototype.decide = function decide (request, data) {
      if (
        request.method === 'GET' &&
        typeof data.file !== 'undefined'
      ) {
        return true;
      }

      return false;
    };

    FileResolver.prototype.end = function end (response) {
      response.state.body = true;
      this.pass(response, null);
    };

    FileResolver.prototype.stream = function stream (response, data) {
      return fs$1.createReadStream(data.file.path);
    };

    return FileResolver;
  }(Streamer));

  var filter$1 = [401, 403, 500];

  var ErrorResolver = /*@__PURE__*/(function (Worker) {
    function ErrorResolver () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) ErrorResolver.__proto__ = Worker;
    ErrorResolver.prototype = Object.create( Worker && Worker.prototype );
    ErrorResolver.prototype.constructor = ErrorResolver;

    ErrorResolver.prototype.act = function act (request, data, callback) {
      var error = new Error('404 Object not found' +
        " (" + (request.method) + " " + (request.url.path) + ")");
      return this.err(request, error, callback);
    };

    ErrorResolver.prototype.decide = function decide (response) {
      return typeof response.status === 'undefined';
    };

    ErrorResolver.prototype.err = function err (request, error, callback) {
      this.log('fail', request, error);

      var response = request.createResponse();
      var match = error.message.match(/(\d{3})?([^(]*)/);

      response.status = match === null ? 500 : Number(match[1] || 500);

      if (filter$1.indexOf(response.status) > -1) {
        match[2] = http.STATUS_CODES[response.status];
      }

      var data = {
        data: response.status < 500 ? error.data : null,
        message: match[2].trim(),
        status: response.status
      };

      this.pass(response, data, callback);
    };

    return ErrorResolver;
  }(Worker));

  var ContinueResponder = /*@__PURE__*/(function (Worker) {
    function ContinueResponder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) ContinueResponder.__proto__ = Worker;
    ContinueResponder.prototype = Object.create( Worker && Worker.prototype );
    ContinueResponder.prototype.constructor = ContinueResponder;

    ContinueResponder.prototype.decide = function decide (message) {
      return message.headers.expect === '100-continue';
    };

    ContinueResponder.prototype.act = function act (message) {
      message.socket.write('HTTP/1.1 100 Continue\r\n\r\n');
      delete message.headers.expect;
    };

    return ContinueResponder;
  }(Worker));

  var UpgradeResponder = /*@__PURE__*/(function (Worker) {
    function UpgradeResponder () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) UpgradeResponder.__proto__ = Worker;
    UpgradeResponder.prototype = Object.create( Worker && Worker.prototype );
    UpgradeResponder.prototype.constructor = UpgradeResponder;

    UpgradeResponder.prototype.decide = function decide (message) {
      return message.headers.upgrade === 'websocket';
    };

    UpgradeResponder.prototype.act = function act (message, data) {
      message.socket.removeAllListeners('data');
      message.socket.server.emit('upgrade', message, message.socket, data);
    };

    return UpgradeResponder;
  }(Worker));

  var AgentRouter = /*@__PURE__*/(function (Router) {
    function AgentRouter(options) {
      Router.call(this, options);
      this._agents = null;
    }

    if ( Router ) AgentRouter.__proto__ = Router;
    AgentRouter.prototype = Object.create( Router && Router.prototype );
    AgentRouter.prototype.constructor = AgentRouter;

    AgentRouter.prototype.act = function act (request, data, callback) {
      if (this._agents === null) {
        this._agents = this.createAgents();
      }

      var userAgent = request.headers['user-agent'];

      var agent = null;
      var params = null;

      for (var i = 0; i < this._agents.length; i += 1) {
        agent = this._agents[i];
        params = agent.regexp.exec(userAgent);

        if (params !== null) {
          this.pass(agent.name, request, data, callback);
          return;
        }
      }

      this.pass('default', request, data, callback);
    };

    AgentRouter.prototype.createAgents = function createAgents () {
      var agents = [];
      var names = Object.keys(this._workers);

      var name = null;

      for (var i = 0; i < names.length; i += 1) {
        name = names[i];

        agents[agents.length] = {
          name: name,
          regexp: new RegExp(name)
        };
      }

      return agents;
    };

    return AgentRouter;
  }(Router));

  var ResourceRouter = /*@__PURE__*/(function (Router) {
    function ResourceRouter(options) {
      Router.call(this, options);
      this._resources = null;
    }

    if ( Router ) ResourceRouter.__proto__ = Router;
    ResourceRouter.prototype = Object.create( Router && Router.prototype );
    ResourceRouter.prototype.constructor = ResourceRouter;

    ResourceRouter.prototype.act = function act (request, data, callback) {
      if (this._resources === null) {
        this._resources = this.createResources();
      }

      var params = null;
      var resource = null;

      for (var i = 0; i < this._resources.length; i += 1) {
        resource = this._resources[i];
        params = resource.regexp.exec(("" + (request.url.path)));

        if (params !== null) {
          if (resource.methods.indexOf(request.method) === -1) {
            return this.handleMethodError(request, data, callback,
              resource.methods);
          }

          request.params = params;
          return this.pass(resource.name, request, data, callback);
        }
      }

      return this.handlePathError(request, data, callback);
    };

    ResourceRouter.prototype.createResources = function createResources () {
      var assign;

      var resources = {};
      var names = Object.keys(this._workers);

      var method = null;
      var name = null;
      var path = null;

      for (var i = 0; i < names.length; i += 1) {
        name = names[i];
        (assign = name.split(' '), method = assign[0], path = assign[1]);

        resources[path] = resources[path] || {
          methods: [],
          name: name,
          regexp: new RegExp(path)
        };

        resources[path].methods.push(method);
      }

      return Object.values(resources);
    };

    ResourceRouter.prototype.handlePathError = function handlePathError (request, data, callback) {
      var response = request.createResponse();

      var error = new Error('404 Resource not found' +
        " (" + (request.method) + " " + (request.url.path) + ")");

      this.fail(response, error, callback);
    };

    ResourceRouter.prototype.handleMethodError = function handleMethodError (request, data, callback, methods) {
      var response = request.createResponse();
      response.headers.allow = methods;

      var error = new Error('405 Method not allowed' +
        " (" + (request.method) + " " + (request.url.path) + ")");

      this.fail(response, error, callback);
    };

    return ResourceRouter;
  }(Router));

  var MethodRouter = /*@__PURE__*/(function (ResourceRouter) {
    function MethodRouter () {
      ResourceRouter.apply(this, arguments);
    }

    if ( ResourceRouter ) MethodRouter.__proto__ = ResourceRouter;
    MethodRouter.prototype = Object.create( ResourceRouter && ResourceRouter.prototype );
    MethodRouter.prototype.constructor = MethodRouter;

    MethodRouter.prototype.act = function act (request, data, callback) {
      if (this._workers[request.method]) {
        return this.pass(request.method, request, data, callback);
      }

      return this.handleMethodError(request, data, callback,
        Object.keys(this._workers));
    };

    return MethodRouter;
  }(ResourceRouter));

  var PathRouter = /*@__PURE__*/(function (ResourceRouter) {
    function PathRouter(options) {
      ResourceRouter.call(this, options);
      this._paths = null;
    }

    if ( ResourceRouter ) PathRouter.__proto__ = ResourceRouter;
    PathRouter.prototype = Object.create( ResourceRouter && ResourceRouter.prototype );
    PathRouter.prototype.constructor = PathRouter;

    PathRouter.prototype.act = function act (request, data, callback) {
      if (this._paths === null) {
        this._paths = this.createPaths();
      }

      var path = null;
      var params = null;

      for (var i = 0; i < this._paths.length; i += 1) {
        path = this._paths[i];
        params = path.regexp.exec(request.url.path);

        if (params !== null) {
          request.params = params;
          return this.pass(path.name, request, data, callback);
        }
      }

      return this.handlePathError(request, data, callback);
    };

    PathRouter.prototype.createPaths = function createPaths () {
      var paths = [];
      var names = Object.keys(this._workers);

      var name = null;

      for (var i = 0; i < names.length; i += 1) {
        name = names[i];

        paths[paths.length] = {
          name: name,
          regexp: new RegExp(name)
        };
      }

      return paths;
    };

    return PathRouter;
  }(ResourceRouter));

  var ResponseTransformer = /*@__PURE__*/(function (Worker) {
    function ResponseTransformer () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) ResponseTransformer.__proto__ = Worker;
    ResponseTransformer.prototype = Object.create( Worker && Worker.prototype );
    ResponseTransformer.prototype.constructor = ResponseTransformer;

    ResponseTransformer.prototype.act = function act (response, data, callback) {
      if (response.mustEnd()) {
        response.end();
      }

      if (response.status < 400) {
        this.pass(response, data, callback);
        return;
      }

      var error = new Error(
        response.status +
        ' ' +
        (data.message || 'Error')
      );

      error.data = data.data || data;
      error.status = response.status;

      this.fail(response, error, callback);
    };

    ResponseTransformer.prototype.err = function err (request, error, callback) {
      var response = request.createResponse();

      error = new Error(("500 " + (error.message)));
      error.status = 500;

      this.fail(response, error, callback);
    };

    return ResponseTransformer;
  }(Worker));

  var BodyWriter = /*@__PURE__*/(function (Streamer) {
    function BodyWriter () {
      Streamer.apply(this, arguments);
    }

    if ( Streamer ) BodyWriter.__proto__ = Streamer;
    BodyWriter.prototype = Object.create( Streamer && Streamer.prototype );
    BodyWriter.prototype.constructor = BodyWriter;

    BodyWriter.prototype.act = function act (message, data, callback) {
      this.writeData(message, data, callback);
      this.pass(message, data, callback);
    };

    BodyWriter.prototype.err = function err (message, data, callback) {
      this.writeData(message, data, callback);
      this.fail(message, data, callback);
    };

    BodyWriter.prototype.stream = function stream (message) {
      return message.socket;
    };

    BodyWriter.prototype.writeData = function writeData (message, data, callback) {
      if (
        buffer_1.isBuffer(data) ||
        typeof data === 'string'
      ) {
        this.write(message, data, callback);
      }

      if (message.state.body === true) {
        if (message.mustEnd()) {
          message.end();
        }
      }
    };

    return BodyWriter;
  }(Streamer));

  var HeaderFieldsWriter = /*@__PURE__*/(function (Worker) {
    function HeaderFieldsWriter () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) HeaderFieldsWriter.__proto__ = Worker;
    HeaderFieldsWriter.prototype = Object.create( Worker && Worker.prototype );
    HeaderFieldsWriter.prototype.constructor = HeaderFieldsWriter;

    HeaderFieldsWriter.prototype.act = function act (message, data, callback) {
      data = this.writeData(message, data);
      this.pass(message, data, callback);
    };

    HeaderFieldsWriter.prototype.err = function err (message, data, callback) {
      data = this.writeData(message, data);
      this.fail(message, data, callback);
    };

    HeaderFieldsWriter.prototype.decide = function decide (message) {
      return message.state.headers !== true;
    };

    HeaderFieldsWriter.prototype.isEmpty = function isEmpty (data) {
      return typeof data === 'undefined' || data === null;
    };

    HeaderFieldsWriter.prototype.writeData = function writeData (message, data) {
      var keys = Object.keys(message.headers);

      var headers = '';
      var key = null;
      var value = null;

      for (var i = 0; i < keys.length; i += 1) {
        key = keys[i];
        value = message.headers[key];

        if (value) {
          headers += key + ': ' + value + '\r\n';
        }
      }

      if (buffer_1.isBuffer(data)) {
        data = buffer_1.concat([
          buffer_1.from(headers + '\r\n'),
          buffer_1.from(data)
        ]);
      } else {
        data = headers + '\r\n' + (this.isEmpty(data) ? '' : data);
      }

      message.state.headers = true;

      return data;
    };

    return HeaderFieldsWriter;
  }(Worker));

  var RequestLineWriter = /*@__PURE__*/(function (Worker) {
    function RequestLineWriter () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) RequestLineWriter.__proto__ = Worker;
    RequestLineWriter.prototype = Object.create( Worker && Worker.prototype );
    RequestLineWriter.prototype.constructor = RequestLineWriter;

    RequestLineWriter.prototype.act = function act (message, data, callback) {
      data = message.method + ' ' +
        message.url.formatPath() + ' HTTP/1.1' +
        '\r\n' +
        data;

      message.state.line = true;

      this.pass(message, data, callback);
    };

    RequestLineWriter.prototype.decide = function decide (message) {
      return message.state.line !== true;
    };

    return RequestLineWriter;
  }(Worker));

  var ResponseLineWriter = /*@__PURE__*/(function (Worker) {
    function ResponseLineWriter () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) ResponseLineWriter.__proto__ = Worker;
    ResponseLineWriter.prototype = Object.create( Worker && Worker.prototype );
    ResponseLineWriter.prototype.constructor = ResponseLineWriter;

    ResponseLineWriter.prototype.act = function act (message, data, callback) {
      data = this.writeData(message, data);
      this.pass(message, data, callback);
    };

    ResponseLineWriter.prototype.err = function err (message, data, callback) {
      data = this.writeData(message, data);
      this.fail(message, data, callback);
    };

    ResponseLineWriter.prototype.decide = function decide (message) {
      return message.state.line !== true;
    };

    ResponseLineWriter.prototype.writeData = function writeData (message, data) {
      var line = 'HTTP/1.1 ' +
        (message.status || 200) + ' ' +
        http.STATUS_CODES[message.status || 200] +
        '\r\n';

      if (buffer_1.isBuffer(data)) {
        data = buffer_1.concat([buffer_1.from(line), data]);
      } else {
        data = line + data;
      }

      message.state.line = true;

      return data;
    };

    return ResponseLineWriter;
  }(Worker));

  var TrailerFieldsWriter = /*@__PURE__*/(function (Worker) {
    function TrailerFieldsWriter () {
      Worker.apply(this, arguments);
    }

    if ( Worker ) TrailerFieldsWriter.__proto__ = Worker;
    TrailerFieldsWriter.prototype = Object.create( Worker && Worker.prototype );
    TrailerFieldsWriter.prototype.constructor = TrailerFieldsWriter;

    TrailerFieldsWriter.prototype.act = function act (message, data, callback) {
      var writeTrailers = (typeof message.body.te !== 'undefined' &&
        message.body.te.indexOf('trailers') !== -1);

      if (writeTrailers === true) {
        data = this.writeTrailers(message, data);
      }

      data += '\r\n';

      this.pass(message, data, callback);
    };

    TrailerFieldsWriter.prototype.decide = function decide (message) {
      var encoding = message.headers['transfer-encoding'] || '';

      if (
        message.state.body === true &&
        encoding.indexOf('chunked') !== -1
      ) {
        return true;
      }

      return false;
    };

    TrailerFieldsWriter.prototype.writeTrailers = function writeTrailers (message, data) {
      var keys = Object.keys(message.trailers);
      var key = '';

      for (var i = 0; i < keys.length; i += 1) {
        key = keys[i];
        data += key + ': ' + message.trailers[key] + '\r\n';
      }

      return data;
    };

    return TrailerFieldsWriter;
  }(Worker));

  function createBrowser(type) {
    if ( type === void 0 ) type = 'create';

    var bodyParser = new BodyParser();
    var browserConnector = new BrowserConnector();
    var browserMediator = new BrowserMediator();
    var chunkedDecoder = new ChunkedDecoder();
    var chunkedEncoder = new ChunkedEncoder();
    var contentEncodingDecoder = new ContentEncodingDecoder();
    var contentEncodingEncoder = new ContentEncodingEncoder();
    var contentTypeDecoder = new ContentTypeDecoder();
    var contentTypeEncoder = new ContentTypeEncoder();
    var contentTypeHeader = new ContentTypeHeader();
    var formdataEncoder = new FormdataEncoder();
    var headerFieldsParser = new HeaderFieldsParser();
    var htmlDecoder = new HtmlDecoder();
    var htmlEncoder = new HtmlEncoder();
    var jsonDecoder = new JsonDecoder();
    var jsonEncoder = new JsonEncoder();
    var msgpackDecoder = new MsgpackDecoder();
    var msgpackEncoder = new MsgpackEncoder();
    var plainDecoder = new PlainDecoder();
    var plainEncoder = new PlainEncoder();
    var responseLineParser = new ResponseLineParser();
    var responseTransformer = new ResponseTransformer();
    var trailerFieldsParser = new TrailerFieldsParser();
    var transferEncodingDecoder = new TransferEncodingDecoder();
    var transferEncodingEncoder = new TransferEncodingEncoder();
    var urlencodedDecoder = new UrlencodedDecoder();
    var urlencodedEncoder = new UrlencodedEncoder();

    browserConnector
      .connect(contentTypeHeader)
      .connect(contentTypeEncoder)
      .connect(contentEncodingEncoder)
      .connect(transferEncodingEncoder)
      .connect(browserMediator)
      .connect(responseLineParser)
      .connect(headerFieldsParser)
      .connect(bodyParser)
      .connect(transferEncodingDecoder)
      .connect(trailerFieldsParser)
      .connect(contentEncodingDecoder)
      .connect(contentTypeDecoder)
      .connect(responseTransformer);

    browserConnector
      .bypass(browserMediator);

    browserMediator
      .bypass(responseTransformer);

    contentTypeDecoder
      .setStrict(false)
      .manage(htmlDecoder.getType(), htmlDecoder)
      .manage(jsonDecoder.getType(), jsonDecoder)
      .manage(msgpackDecoder.getType(), msgpackDecoder)
      .manage(urlencodedDecoder.getType(), urlencodedDecoder)
      .manage(plainDecoder.getType(), plainDecoder);

    contentTypeEncoder
      .setStrict(false)
      .manage(htmlEncoder.getType(), htmlEncoder)
      .manage(jsonEncoder.getType(), jsonEncoder)
      .manage(msgpackEncoder.getType(), msgpackEncoder)
      .manage(formdataEncoder.getType(), formdataEncoder)
      .manage(plainEncoder.getType(), plainEncoder)
      .manage(urlencodedEncoder.getType(), urlencodedEncoder);

    contentTypeHeader
      .addType(jsonEncoder.getType())
      .addType(formdataEncoder.getType());

    transferEncodingDecoder
      .manage(chunkedDecoder.getEncoding(), chunkedDecoder);

    transferEncodingEncoder
      .manage(chunkedEncoder.getEncoding(), chunkedEncoder);

    return Object[type]({
      connector: browserConnector,
      transformer: responseTransformer
    });
  }

  function createClient(type) {
    if ( type === void 0 ) type = 'values';

    var bodyParser = new BodyParser();
    var bodyWriter = new BodyWriter();
    var clientConnector = new ClientConnector();
    var clientMediator = new ClientMediator();
    var chunkedDecoder = new ChunkedDecoder();
    var chunkedEncoder = new ChunkedEncoder();
    var connectionHeader = new ConnectionHeader();
    var contentEncodingDecoder = new ContentEncodingDecoder();
    var contentEncodingEncoder = new ContentEncodingEncoder();
    var contentLengthHeader = new ContentLengthHeader();
    var contentTypeDecoder = new ContentTypeDecoder();
    var contentTypeEncoder = new ContentTypeEncoder();
    var contentTypeHeader = new ContentTypeHeader();
    var dateHeader = new DateHeader();
    var formdataEncoder = new FormdataEncoder();
    var headerFieldsParser = new HeaderFieldsParser();
    var headerFieldsWriter = new HeaderFieldsWriter();
    var htmlDecoder = new HtmlDecoder();
    var htmlEncoder = new HtmlEncoder();
    var jsonDecoder = new JsonDecoder();
    var jsonEncoder = new JsonEncoder();
    var msgpackDecoder = new MsgpackDecoder();
    var msgpackEncoder = new MsgpackEncoder();
    var plainDecoder = new PlainDecoder();
    var plainEncoder = new PlainEncoder();
    var requestLineWriter = new RequestLineWriter();
    var responseLineParser = new ResponseLineParser();
    var responseTransformer = new ResponseTransformer();
    var trailerFieldsParser = new TrailerFieldsParser();
    var trailerFieldsWriter = new TrailerFieldsWriter();
    var transferEncodingDecoder = new TransferEncodingDecoder();
    var transferEncodingEncoder = new TransferEncodingEncoder();
    var urlencodedDecoder = new UrlencodedDecoder();
    var urlencodedEncoder = new UrlencodedEncoder();

    clientConnector
      .connect(contentTypeHeader)
      .connect(contentTypeEncoder)
      .connect(contentEncodingEncoder)
      .connect(transferEncodingEncoder)
      .connect(contentLengthHeader)
      .connect(connectionHeader)
      .connect(dateHeader)
      .connect(headerFieldsWriter)
      .connect(requestLineWriter)
      .connect(trailerFieldsWriter)
      .connect(bodyWriter)
      .connect(clientMediator)
      .connect(responseLineParser)
      .connect(headerFieldsParser)
      .connect(bodyParser)
      .connect(transferEncodingDecoder)
      .connect(trailerFieldsParser)
      .connect(contentEncodingDecoder)
      .connect(contentTypeDecoder)
      .connect(responseTransformer);

    clientConnector
      .bypass(clientMediator);

    clientMediator
      .bypass(responseTransformer);

    contentTypeDecoder
      .setStrict(false)
      .manage(htmlDecoder.getType(), htmlDecoder)
      .manage(jsonDecoder.getType(), jsonDecoder)
      .manage(msgpackDecoder.getType(), msgpackDecoder)
      .manage(urlencodedDecoder.getType(), urlencodedDecoder)
      .manage(plainDecoder.getType(), plainDecoder);

    contentTypeEncoder
      .setStrict(false)
      .manage(htmlEncoder.getType(), htmlEncoder)
      .manage(jsonEncoder.getType(), jsonEncoder)
      .manage(msgpackEncoder.getType(), msgpackEncoder)
      .manage(formdataEncoder.getType(), formdataEncoder)
      .manage(plainEncoder.getType(), plainEncoder)
      .manage(urlencodedEncoder.getType(), urlencodedEncoder);

    contentTypeHeader
      .addType(jsonEncoder.getType())
      .addType(formdataEncoder.getType());

    transferEncodingDecoder
      .manage(chunkedDecoder.getEncoding(), chunkedDecoder);

    transferEncodingEncoder
      .manage(chunkedEncoder.getEncoding(), chunkedEncoder);

    return Object[type]({
      connector: clientConnector,
      transformer: responseTransformer
    });
  }

  function createServer(options) {
    if ( options === void 0 ) options = {};

    var listen = options.listen; if ( listen === void 0 ) listen = 3000;

    var bodyParser = new BodyParser();
    var bodyWriter = new BodyWriter();
    var chunkedDecoder = new ChunkedDecoder();
    var chunkedEncoder = new ChunkedEncoder();
    var connectionHeader = new ConnectionHeader();
    var contentEncodingDecoder = new ContentEncodingDecoder();
    var contentEncodingEncoder = new ContentEncodingEncoder();
    var contentEncodingHeader = new ContentEncodingHeader();
    var contentLengthHeader = new ContentLengthHeader();
    var contentTypeDecoder = new ContentTypeDecoder();
    var contentTypeEncoder = new ContentTypeEncoder();
    var contentTypeHeader = new ContentTypeHeader();
    var continueResponder = new ContinueResponder();
    var dataResolver = new DataResolver();
    var dateHeader = new DateHeader();
    var fileResolver = new FileResolver();
    var errorResolver = new ErrorResolver();
    var formdataEncoder = new FormdataEncoder();
    var formdataDecoder = new FormdataDecoder();
    var headerFieldsParser = new HeaderFieldsParser();
    var headerFieldsWriter = new HeaderFieldsWriter();
    var htmlDecoder = new HtmlDecoder();
    var htmlEncoder = new HtmlEncoder();
    var jsonDecoder = new JsonDecoder();
    var jsonEncoder = new JsonEncoder();
    var msgpackDecoder = new MsgpackDecoder();
    var msgpackEncoder = new MsgpackEncoder();
    var plainDecoder = new PlainDecoder();
    var plainEncoder = new PlainEncoder();
    var requestLineParser = new RequestLineParser();
    var responseLineWriter = new ResponseLineWriter();
    var serverConnector = new ServerConnector();
    var trailerFieldsParser = new TrailerFieldsParser();
    var trailerFieldsWriter = new TrailerFieldsWriter();
    var transferEncodingDecoder = new TransferEncodingDecoder();
    var transferEncodingEncoder = new TransferEncodingEncoder();
    var transferEncodingHeader = new TransferEncodingHeader();
    var upgradeResponder = new UpgradeResponder();
    var urlencodedDecoder = new UrlencodedDecoder();
    var urlencodedEncoder = new UrlencodedEncoder();

    serverConnector
      .connect(requestLineParser)
      .connect(headerFieldsParser)
      .connect(continueResponder)
      .connect(upgradeResponder)
      .connect(bodyParser)
      .connect(transferEncodingDecoder)
      .connect(trailerFieldsParser)
      .connect(contentEncodingDecoder)
      .connect(contentTypeDecoder);

    dataResolver
      .connect(fileResolver)
      .connect(errorResolver)
      .connect(contentTypeHeader)
      .connect(contentEncodingHeader)
      .connect(transferEncodingHeader)
      .connect(contentTypeEncoder)
      .connect(contentEncodingEncoder)
      .connect(transferEncodingEncoder)
      .connect(contentLengthHeader)
      .connect(connectionHeader)
      .connect(dateHeader)
      .connect(headerFieldsWriter)
      .connect(responseLineWriter)
      .connect(trailerFieldsWriter)
      .connect(bodyWriter);

    contentTypeDecoder
      .setStrict(false)
      .manage(htmlDecoder.getType(), htmlDecoder)
      .manage(jsonDecoder.getType(), jsonDecoder)
      .manage(msgpackDecoder.getType(), msgpackDecoder)
      .manage(formdataDecoder.getType(), formdataDecoder)
      .manage(urlencodedDecoder.getType(), urlencodedDecoder)
      .manage(plainDecoder.getType(), plainDecoder);

    contentTypeEncoder
      .setStrict(false)
      .manage(htmlEncoder.getType(), htmlEncoder)
      .manage(jsonEncoder.getType(), jsonEncoder)
      .manage(msgpackEncoder.getType(), msgpackEncoder)
      .manage(formdataEncoder.getType(), formdataEncoder)
      .manage(plainEncoder.getType(), plainEncoder)
      .manage(urlencodedEncoder.getType(), urlencodedEncoder);

    transferEncodingDecoder
      .manage(chunkedDecoder.getEncoding(), chunkedDecoder);

    transferEncodingEncoder
      .manage(chunkedEncoder.getEncoding(), chunkedEncoder);

    contentTypeHeader
      .addType(jsonEncoder.getType())
      .addType(msgpackEncoder.getType())
      .addType(formdataEncoder.getType())
      .addType(urlencodedEncoder.getType())
      .addType(plainEncoder.getType());

    if (listen) {
      net.createServer(function (socket) {
        serverConnector.handle(socket);
      }).listen(listen);
    }

    return {
      connector: serverConnector,
      decoder: contentTypeDecoder,
      resolver: dataResolver,
      writer: bodyWriter
    };
  }



  var index$2 = /*#__PURE__*/Object.freeze({
    createBrowser: createBrowser,
    createClient: createClient,
    createServer: createServer,
    Header: Header,
    Message: Message,
    Request: Request,
    Response: Response,
    Url: Url,
    CsvStruct: CsvStruct,
    HtmlStruct: HtmlStruct,
    User: User,
    BodyParser: BodyParser,
    HeaderFieldsParser: HeaderFieldsParser,
    RequestLineParser: RequestLineParser,
    ResponseLineParser: ResponseLineParser,
    TrailerFieldsParser: TrailerFieldsParser,
    PasswordChecker: PasswordChecker,
    RoleChecker: RoleChecker,
    UserChecker: UserChecker,
    HtmlDecoder: HtmlDecoder,
    ChunkedDecoder: ChunkedDecoder,
    ContentTypeDecoder: ContentTypeDecoder,
    CsvDecoder: CsvDecoder,
    FormdataDecoder: FormdataDecoder,
    ContentEncodingDecoder: ContentEncodingDecoder,
    JsonDecoder: JsonDecoder,
    MsgpackDecoder: MsgpackDecoder,
    PlainDecoder: PlainDecoder,
    TransferEncodingDecoder: TransferEncodingDecoder,
    UrlencodedDecoder: UrlencodedDecoder,
    HtmlEncoder: HtmlEncoder,
    ChunkedEncoder: ChunkedEncoder,
    ContentTypeEncoder: ContentTypeEncoder,
    CsvEncoder: CsvEncoder,
    FormdataEncoder: FormdataEncoder,
    ContentEncodingEncoder: ContentEncodingEncoder,
    JsonEncoder: JsonEncoder,
    MsgpackEncoder: MsgpackEncoder,
    PlainEncoder: PlainEncoder,
    TransferEncodingEncoder: TransferEncodingEncoder,
    UrlencodedEncoder: UrlencodedEncoder,
    ConnectionHeader: ConnectionHeader,
    ContentEncodingHeader: ContentEncodingHeader,
    ContentLengthHeader: ContentLengthHeader,
    ContentTypeHeader: ContentTypeHeader,
    DateHeader: DateHeader,
    TransferEncodingHeader: TransferEncodingHeader,
    BrowserMediator: BrowserMediator,
    ClientMediator: ClientMediator,
    BrowserConnector: BrowserConnector,
    ClientConnector: ClientConnector,
    ServerConnector: ServerConnector,
    DataResolver: DataResolver,
    FileResolver: FileResolver,
    ErrorResolver: ErrorResolver,
    ContinueResponder: ContinueResponder,
    UpgradeResponder: UpgradeResponder,
    AgentRouter: AgentRouter,
    MethodRouter: MethodRouter,
    PathRouter: PathRouter,
    ResourceRouter: ResourceRouter,
    ResponseTransformer: ResponseTransformer,
    BodyWriter: BodyWriter,
    HeaderFieldsWriter: HeaderFieldsWriter,
    RequestLineWriter: RequestLineWriter,
    ResponseLineWriter: ResponseLineWriter,
    TrailerFieldsWriter: TrailerFieldsWriter
  });

  var Request$1 = /*@__PURE__*/(function (Action) {
    function Request(options) {
      if ( options === void 0 ) options = {};

      Action.call(this, options);

      this._client = null;
      this._indicator = null;
      this._list = null;
      this._object = null;
      this._resource = null;

      this.setClient(options.client);
      this.setIndicator(options.indicator);
      this.setList(options.list);
      this.setObject(options.object);
      this.setResource(options.resource);
    }

    if ( Action ) Request.__proto__ = Action;
    Request.prototype = Object.create( Action && Action.prototype );
    Request.prototype.constructor = Request;

    Request.prototype.getOptions = function getOptions () {
      return Object.assign(Action.prototype.getOptions.call(this), {
        indicator: this._indicator,
        list: this._list,
        object: this._object,
        resource: this._resource
      });
    };

    Request.prototype.getClient = function getClient () {
      return this._client;
    };

    Request.prototype.setClient = function setClient (value) {
      if ( value === void 0 ) value = null;

      this._client = value;
      return this;
    };

    Request.prototype.getIndicator = function getIndicator () {
      return this._indicator;
    };

    Request.prototype.setIndicator = function setIndicator (value) {
      if ( value === void 0 ) value = null;

      this._indicator = value;
      return this;
    };

    Request.prototype.getList = function getList () {
      return this._list;
    };

    Request.prototype.setList = function setList (value) {
      if ( value === void 0 ) value = false;

      this._list = value;
      return this;
    };

    Request.prototype.getObject = function getObject () {
      return this._object;
    };

    Request.prototype.setObject = function setObject (value) {
      if ( value === void 0 ) value = null;

      this._object = value;
      return this;
    };

    Request.prototype.getResource = function getResource () {
      return this._resource;
    };

    Request.prototype.setResource = function setResource (value) {
      if ( value === void 0 ) value = null;

      this._resource = value;
      return this;
    };

    Request.prototype.client = function client (value) {
      return this.setClient(value);
    };

    Request.prototype.indicator = function indicator (value) {
      return this.setIndicator(value);
    };

    Request.prototype.list = function list () {
      return this.setList(true);
    };

    Request.prototype.object = function object (value) {
      return this.setObject(value);
    };

    Request.prototype.resource = function resource (value) {
      return this.setResource(value);
    };

    Request.prototype.resolveAfter = function resolveAfter (box, data) {
      var this$1 = this;

      if (this._client === null) {
        this._client = createBrowser();
      }

      var options = this.resolveValue(box, data, this._resource);

      if (typeof options === 'string') {
        var ref = options.split(' ');
        var method = ref[0];
        var url = ref[1]; if ( url === void 0 ) url = null;

        if (url === null) {
          url = method;
          method = void 0;
        }

        url = Url.parse(url);

        options = {
          method: method,
          url: {
            path: url.path,
            query: url.query
          }
        };
      }

      options = defaultsDeep({}, options, {
        extra: {
          box: box
        },
        url: {
          hostname: window.location.hostname,
          port: window.location.port,
          query: {},
          scheme: window.location.protocol.slice(0, -1)
        }
      });

      if (this._list) {
        this.resolveList(box, options);
      } else if (this._object) {
        this.resolveObject(box, options);
      }

      this._client.transformer.connect(new Worker({
        act: function (b, result) {
          this$1._client.transformer.setWorker(null);
          this$1.pass(box, result);
        },
        err: function (b, error) {
          this$1._client.transformer.setWorker(null);
          this$1.fail(box, error);
        }
      }));

      this._client.connector.handle(options, data, function (event) {
        this$1.resolveValue(box, event, this$1._indicator);
      });
    };

    Request.prototype.resolveList = function resolveList (box, options) {
      var names = ['count', 'offset', 'search'];
      var list = box.list || {};

      var name = null;

      for (var i = 0; i < names.length; i += 1) {
        name = names[i];

        if (typeof list[name] !== 'undefined') {
          options.url.query[name] = list[name];
        }
      }
    };

    Request.prototype.resolveObject = function resolveObject (box, options) {
      options.url.path += '/' + box.params[this._object];
    };

    return Request;
  }(Action));

  var Route$1 = /*@__PURE__*/(function (Action) {
    function Route(options) {
      if ( options === void 0 ) options = {};

      Action.call(this, options);

      this._object = null;
      this._view = null;

      this.setObject(options.object);
      this.setView(options.view);
    }

    if ( Action ) Route.__proto__ = Action;
    Route.prototype = Object.create( Action && Action.prototype );
    Route.prototype.constructor = Route;

    Route.prototype.getOptions = function getOptions () {
      return Object.assign(Action.prototype.getOptions.call(this), {
        object: this._object,
        view: this._view
      });
    };

    Route.prototype.getObject = function getObject () {
      return this._object;
    };

    Route.prototype.setObject = function setObject (value) {
      if ( value === void 0 ) value = null;

      this._object = value;
      return this;
    };

    Route.prototype.getView = function getView () {
      return this._view;
    };

    Route.prototype.setView = function setView (value) {
      if ( value === void 0 ) value = null;

      this._view = value;
      return this;
    };

    Route.prototype.object = function object (value) {
      return this.setObject(value);
    };

    Route.prototype.view = function view (value) {
      return this.setView(value);
    };

    Route.prototype.resolveAfter = function resolveAfter (box, data) {
      var route = this.resolveValue(box, data, this._view);

      if (this._object) {
        route = this.resolveObject(box, data, route);
      }

      ViewRouter.handle(box, data, route);
    };

    Route.prototype.resolveObject = function resolveObject (box, data, route) {
      var ref = route.split('@');
      var path = ref[0];
      var name = ref[1];
      var object = (this._object) + "=" + (data[this._object]);
      return (path + ":" + object + "@" + name);
    };

    return Route;
  }(Action));

  /** Used to match property names within property paths. */
  var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp$1 = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey$1(value, object) {
    if (isArray$2(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol$3(value)) {
      return true;
    }
    return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) ||
      (object != null && value in Object(object));
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT$2 = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize$2(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT$2);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize$2.Cache || MapCache$1);
    return memoized;
  }

  // Expose `MapCache`.
  memoize$2.Cache = MapCache$1;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE$2 = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped$2(func) {
    var result = memoize$2(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE$2) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */
  var rePropName$2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar$2 = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath$2 = memoizeCapped$2(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName$2, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar$2, '$1') : (number || match));
    });
    return result;
  });

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath$1(value, object) {
    if (isArray$2(value)) {
      return value;
    }
    return isKey$1(value, object) ? [value] : stringToPath$2(toString$1(value));
  }

  /** Used as references for various `Number` constants. */
  var INFINITY$5 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey$2(value) {
    if (typeof value == 'string' || isSymbol$3(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$5) ? '-0' : result;
  }

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet$1(object, path, value, customizer) {
    if (!isObject$2(object)) {
      return object;
    }
    path = castPath$1(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey$2(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject$2(objValue)
            ? objValue
            : (isIndex(path[index + 1]) ? [] : {});
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  /**
   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
   * it's created. Arrays are created for missing index properties while objects
   * are created for all other missing properties. Use `_.setWith` to customize
   * `path` creation.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.set(object, 'a[0].b.c', 4);
   * console.log(object.a[0].b.c);
   * // => 4
   *
   * _.set(object, ['x', '0', 'y', 'z'], 5);
   * console.log(object.x[0].y.z);
   * // => 5
   */
  function set$4(object, path, value) {
    return object == null ? object : baseSet$1(object, path, value);
  }

  var Input = /*@__PURE__*/(function (Node) {
    function Input(options) {
      if ( options === void 0 ) options = {};

      Node.call(this, options);

      this._default = null;
      this.setDefault(options.default);

      this.name('input');
    }

    if ( Node ) Input.__proto__ = Node;
    Input.prototype = Object.create( Node && Node.prototype );
    Input.prototype.constructor = Input;

    Input.prototype.getOptions = function getOptions () {
      return Object.assign(Node.prototype.getOptions.call(this), {
        default: this._default
      });
    };

    Input.prototype.getDefault = function getDefault () {
      return this._default;
    };

    Input.prototype.setDefault = function setDefault (value) {
      if ( value === void 0 ) value = null;

      this._default = value;
      return this;
    };

    Input.prototype.default = function default$1 (value) {
      return this.setDefault(value);
    };

    Input.prototype.clean = function clean (box, data) {
      var name = this.resolveAttribute(box, data, 'name');
      var value = data[name];

      if (Array.isArray(value) === false) {
        this.cleanBefore(box, data, name, value);
        return;
      }

      for (var i = 0; i < value.length; i += 1) {
        this.cleanBefore(box, data, (name + "." + i), value[i]);
      }
    };

    Input.prototype.cleanAfter = function cleanAfter () {};

    Input.prototype.cleanBefore = function cleanBefore (box, data, name, value) {
      this.cleanInput(box, data, name, value);
    };

    Input.prototype.cleanInput = function cleanInput (box, data, name, value) {
      var isAllowed = this.isAllowed(box, data);

      if (isAllowed === false) {
        value = '';
        this.setValue(data, name, value);
      }

      var isEmpty = this.isEmpty(value);

      if (
        isEmpty === true &&
        this._default !== null
      ) {
        value = this.resolveValue(box, data, this._default);
        this.setValue(data, name, value);
      }

      this.cleanAfter(box, data, name, value);
    };

    Input.prototype.isAboveMin = function isAboveMin (value, min) {
      if (typeof min === 'undefined') {
        return true;
      }

      return value >= min;
    };

    Input.prototype.isBelowMax = function isBelowMax (value, max) {
      if (typeof max === 'undefined') {
        return true;
      }

      return value <= max;
    };

    Input.prototype.isDefined = function isDefined (value, required) {
      if (typeof required === 'undefined') {
        return true;
      }

      return this.isEmpty(value) === false;
    };

    Input.prototype.isEmpty = function isEmpty (value) {
      return typeof value === 'undefined' ||
        value === null ||
        value === '';
    };

    Input.prototype.isPattern = function isPattern (value, pattern) {
      if (typeof pattern === 'undefined') {
        return true;
      }

      return new RegExp(pattern).test(String(value));
    };

    Input.prototype.setValue = function setValue (object, key, value) {
      set$4(object, key, value);
    };

    Input.prototype.setError = function setError (error, name, value, reason, options) {
      if ( options === void 0 ) options = {};

      value = Object.assign({}, options, {
        reason: reason,
        type: this.constructor.name.toLowerCase(),
        value: value
      });

      this.setValue(error, name, value);
    };

    Input.prototype.validate = function validate (box, data, error) {
      var name = this.resolveAttribute(box, data, 'name');
      var value = data[name];

      var multiple = this.resolveAttribute(box, data, 'multiple');

      if (typeof multiple !== 'undefined') {
        if (Array.isArray(value) === false) {
          this.setError(error, name, value, 'array');
          return null;
        }
      }

      if (Array.isArray(value) === false) {
        return this.validateBefore(box, data, error, name, value);
      }

      for (var i = 0; i < value.length; i += 1) {
        this.validateBefore(box, data, error, (name + "." + i), value[i]);
      }

      return null;
    };

    Input.prototype.validateAfter = function validateAfter () {};

    Input.prototype.validateBefore = function validateBefore (box, data, error, name, value) {
      return this.validateInput(box, data, error, name, value);
    };

    Input.prototype.validateInput = function validateInput (box, data, error, name, value) {
      var required = this.resolveAttribute(box, data, 'required');

      if (this.isDefined(value, required) === false) {
        return this.setError(error, name, value, 'required');
      }

      if (this.isEmpty(value) === true) {
        return null;
      }

      var pattern = this.resolveAttribute(box, data, 'pattern');

      if (this.isPattern(value, pattern) === false) {
        return this.setError(error, name, value, 'pattern', { pattern: pattern });
      }

      var maxlength = this.resolveAttribute(box, data, 'maxlength');

      if (this.isBelowMax(String(value).length, maxlength) === false) {
        return this.setError(error, name, value, 'maxlength', { maxlength: maxlength });
      }

      var max = this.resolveAttribute(box, data, 'max');

      if (this.isBelowMax(value, max) === false) {
        return this.setError(error, name, value, 'max', { max: max });
      }

      var min = this.resolveAttribute(box, data, 'min');

      if (this.isAboveMin(value, min) === false) {
        return this.setError(error, name, value, 'min', { min: min });
      }

      return this.validateAfter(box, data, error, name, value);
    };

    return Input;
  }(Node$1));

  var Validate = /*@__PURE__*/(function (Action) {
    function Validate () {
      Action.apply(this, arguments);
    }

    if ( Action ) Validate.__proto__ = Action;
    Validate.prototype = Object.create( Action && Action.prototype );
    Validate.prototype.constructor = Validate;

    Validate.prototype.resolveAfter = function resolveAfter (box, data) {
      for (var i = 0; i < this._args.length; i += 1) {
        this.validate(box, data, this._args[i]);
      }
    };

    Validate.prototype.validate = function validate (box, data, snippet) {
      var snippets = snippet.find(function (s) { return s instanceof Input; });
      var error = {};

      for (var i = 0; i < snippets.length; i += 1) {
        snippets[i].clean(box, data, error);
      }

      for (var i$1 = 0; i$1 < snippets.length; i$1 += 1) {
        snippets[i$1].validate(box, data, error);
      }

      var hasError = Object.keys(error).length > 0;

      if (hasError) {
        var newError = new Error('400 Input invalid');
        newError.data = error;
        this.fail(box, newError);
      } else {
        this.pass(box, data);
      }
    };

    return Validate;
  }(Action));



  var action = /*#__PURE__*/Object.freeze({
    Async: Async,
    Request: Request$1,
    Route: Route$1,
    Validate: Validate
  });

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now$1 = function() {
    return root$2.Date.now();
  };

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to match leading and trailing whitespace. */
  var reTrim$1 = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol$3(value)) {
      return NAN;
    }
    if (isObject$2(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$2(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim$1, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT$3 = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$2 = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$3);
    }
    wait = toNumber(wait) || 0;
    if (isObject$2(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$2(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now$1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now$1());
    }

    function debounced() {
      var time = now$1(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT$4 = 'Expected a function';

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$4);
    }
    if (isObject$2(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  var Event$1 = /*@__PURE__*/(function (Action) {
    function Event(options) {
      if ( options === void 0 ) options = {};

      Action.call(this, options);

      this._name = null;
      this._throttle = null;

      this.setName(options.name);
      this.setThrottle(options.throttle);
    }

    if ( Action ) Event.__proto__ = Action;
    Event.prototype = Object.create( Action && Action.prototype );
    Event.prototype.constructor = Event;

    Event.prototype.getName = function getName () {
      return this._name;
    };

    Event.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = null;

      this._name = value;
      return this;
    };

    Event.prototype.getThrottle = function getThrottle () {
      return this._throttle;
    };

    Event.prototype.setThrottle = function setThrottle (value) {
      if ( value === void 0 ) value = 0;

      this._throttle = value;
      return this;
    };

    Event.prototype.name = function name (value) {
      return this.setName(value);
    };

    Event.prototype.throttle = function throttle (value) {
      return this.setThrottle(value);
    };

    Event.prototype.removeBefore = function removeBefore () {
      for (var i = 0; i < this._args.length; i += 1) {
        this.unbind(this._args[i]);
      }

      this.removeOuter();
    };

    Event.prototype.resolveAfter = function resolveAfter () {
      var result = [];

      for (var i = 0; i < this._args.length; i += 1) {
        result[result.length] = this._args[i].node();
      }

      return result;
    };

    Event.prototype.resolveInner = function resolveInner (box, data) {
      for (var i = 0; i < this._args.length; i += 1) {
        this.bind(box, data, this._args[i]);
      }

      return this.resolveAfter(box, data);
    };

    Event.prototype.bind = function bind (box, data, snippet) {
      var this$1 = this;

      var node = this.resolveValue(box, data, snippet);

      if (node === null) {
        return;
      }

      var throttled = throttle(function (newEvent) {
        this$1.handleBefore(box, data, snippet, newEvent);
      }, this._throttle);

      node.on(this._name, function () {
        throttled(event$1);
      });
    };

    Event.prototype.handle = function handle (box, data) {
      this.pass(box, data);
      return false;
    };

    Event.prototype.handleBefore = function handleBefore (box, data, snippet, newEvent) {
      if (newEvent) {
        newEvent.preventDefault();
      }

      if (box.busy === true) {
        return;
      }

      box.busy = this.handle(box, data, snippet, newEvent);
    };

    Event.prototype.unbind = function unbind (snippet) {
      snippet.node().on(this._name, null);
    };

    return Event;
  }(Action));

  var Click = /*@__PURE__*/(function (Event) {
    function Click(options) {
      Event.call(this, options);
      this.name('click');
    }

    if ( Event ) Click.__proto__ = Event;
    Click.prototype = Object.create( Event && Event.prototype );
    Click.prototype.constructor = Click;

    Click.prototype.handle = function handle (box, data) {
      if (event.target.closest('.click') !== null) {
        this.pass(box, data);
      }

      return false;
    };

    return Click;
  }(Event$1));

  var Fold = /*@__PURE__*/(function (Event) {
    function Fold(options) {
      if ( options === void 0 ) options = {};

      Event.call(this, options);

      this._filter = null;
      this._storage = null;

      this.setFilter(options.filter);
      this.setStorage(options.storage);

      this.name('click');
    }

    if ( Event ) Fold.__proto__ = Event;
    Fold.prototype = Object.create( Event && Event.prototype );
    Fold.prototype.constructor = Fold;

    Fold.prototype.getOptions = function getOptions () {
      return Object.assign(Event.prototype.getOptions.call(this), {
        filter: this._filter,
        storage: this._storage
      });
    };

    Fold.prototype.getFilter = function getFilter () {
      return this._filter;
    };

    Fold.prototype.setFilter = function setFilter (value) {
      if ( value === void 0 ) value = null;

      this._filter = value;
      return this;
    };

    Fold.prototype.getStorage = function getStorage () {
      return this._storage;
    };

    Fold.prototype.setStorage = function setStorage (value) {
      if ( value === void 0 ) value = localStorage;

      this._storage = value;
      return this;
    };

    Fold.prototype.filter = function filter (value) {
      return this.setFilter(value);
    };

    Fold.prototype.storage = function storage (value) {
      return this.setStorage(value);
    };

    Fold.prototype.resolveAfter = function resolveAfter (box, data) {
      var result = [];
      var snippet = null;

      for (var i = 0; i < this._args.length; i += 1) {
        snippet = this._args[i];

        this.load(box, data, snippet);
        this.fold(box, data, snippet, true);

        result[result.length] = snippet.node();
      }

      return result;
    };

    Fold.prototype.handle = function handle (box, data, snippet, event) {
      var handle = select(event.target);
      var mustFold = handle.classed('fold handle');

      if (mustFold === true) {
        this.fold(box, data, snippet);
        this.save(box, data, snippet);
      }

      return false;
    };

    Fold.prototype.attach = function attach (item, immediate) {
      item.style('width');

      if (immediate) {
        item.style('transition-duration', '0s');
      }

      item
        .classed('out', false)
        .on('transitionend.scola-fold', function () {
          item
            .style('height', null)
            .style('transition-duration', null)
            .on('.scola-fold', null);
        });

      var duration = parseFloat(
        item.style('transition-duration')
      );

      if (duration === 0) {
        item.dispatch('transitionend');
      }
    };

    Fold.prototype.detach = function detach (item, immediate) {
      var height = item.node().getBoundingClientRect().height;

      item.style('height', height);
      item.style('width');

      if (immediate) {
        item.style('transition-duration', '0s');
      }

      item
        .classed('out', true)
        .on('transitionend.scola-fold', function () {
          item
            .style('transition-duration', null)
            .on('transitionend.scola-fold', null)
            .remove();
        });

      var duration = parseFloat(item.style('transition-duration'));

      if (height === 0 || duration === 0) {
        item.dispatch('transitionend');
      }
    };

    Fold.prototype.fold = function fold (box, data, snippet, immediate) {
      if ( immediate === void 0 ) immediate = false;

      var group = snippet.node();
      var isFolded = group.classed('folded');

      var snippets = this._filter ?
        this._filter(snippet) :
        snippet.find(function (s) { return s.node && s.node().classed('item'); });

      group.classed('folded', !isFolded);

      if (isFolded) {
        this.show(snippets, immediate);
      } else {
        this.hide(snippets, immediate);
      }
    };

    Fold.prototype.hide = function hide (snippets, immediate) {
      var item = null;

      for (var i = 0; i < snippets.length; i += 1) {
        item = snippets[i].node();

        item.next = item.node().nextSibling;
        item.parent = item.node().parentNode;

        this.detach(item, immediate);
      }
    };

    Fold.prototype.load = function load (box, data, snippet) {
      var isFolded = Boolean(
        Number(
          this._storage.getItem(("fold-" + (this._id)))
        )
      );

      snippet
        .node()
        .classed('folded', !isFolded);
    };

    Fold.prototype.save = function save (box, data, snippet) {
      var isFolded = snippet
        .node()
        .classed('folded');

      this._storage.setItem(
        ("fold-" + (this._id)),
        Number(isFolded)
      );
    };

    Fold.prototype.show = function show (snippets, immediate) {
      var item = null;

      for (var i = snippets.length - 1; i >= 0; i -= 1) {
        item = snippets[i].node();

        if (item.parent) {
          if (item.next) {
            item.parent.insertBefore(item.node(), item.next);
          } else {
            item.parent.appendChild(item.node());
          }
        }

        this.attach(item, immediate);
      }
    };

    return Fold;
  }(Event$1));

  var Input$1 = /*@__PURE__*/(function (Event) {
    function Input(options) {
      Event.call(this, options);

      this
        .name('input')
        .throttle(500);
    }

    if ( Event ) Input.__proto__ = Event;
    Input.prototype = Object.create( Event && Event.prototype );
    Input.prototype.constructor = Input;

    Input.prototype.handle = function handle (box, data, snippet, event) {
      var node = select(event.srcElement);
      var minLength = node.attr('minlength');
      var value = node.property('value');

      if (typeof minLength !== 'undefined') {
        if (
          value.length >= minLength ||
          value.length === 0
        ) {
          box.input = value;
          this.pass(box, data);
        }
      } else {
        box.input = value;
        this.pass(box, data);
      }

      return false;
    };

    return Input;
  }(Event$1));

  var collectionUtils = createCommonjsModule(function (module) {

  var utils = module.exports = {};

  /**
   * Loops through the collection and calls the callback for each element. if the callback returns truthy, the loop is broken and returns the same value.
   * @public
   * @param {*} collection The collection to loop through. Needs to have a length property set and have indices set from 0 to length - 1.
   * @param {function} callback The callback to be called for each element. The element will be given as a parameter to the callback. If this callback returns truthy, the loop is broken and the same value is returned.
   * @returns {*} The value that a callback has returned (if truthy). Otherwise nothing.
   */
  utils.forEach = function(collection, callback) {
      for(var i = 0; i < collection.length; i++) {
          var result = callback(collection[i]);
          if(result) {
              return result;
          }
      }
  };
  });

  var elementUtils = function(options) {
      var getState = options.stateHandler.getState;

      /**
       * Tells if the element has been made detectable and ready to be listened for resize events.
       * @public
       * @param {element} The element to check.
       * @returns {boolean} True or false depending on if the element is detectable or not.
       */
      function isDetectable(element) {
          var state = getState(element);
          return state && !!state.isDetectable;
      }

      /**
       * Marks the element that it has been made detectable and ready to be listened for resize events.
       * @public
       * @param {element} The element to mark.
       */
      function markAsDetectable(element) {
          getState(element).isDetectable = true;
      }

      /**
       * Tells if the element is busy or not.
       * @public
       * @param {element} The element to check.
       * @returns {boolean} True or false depending on if the element is busy or not.
       */
      function isBusy(element) {
          return !!getState(element).busy;
      }

      /**
       * Marks the object is busy and should not be made detectable.
       * @public
       * @param {element} element The element to mark.
       * @param {boolean} busy If the element is busy or not.
       */
      function markBusy(element, busy) {
          getState(element).busy = !!busy;
      }

      return {
          isDetectable: isDetectable,
          markAsDetectable: markAsDetectable,
          isBusy: isBusy,
          markBusy: markBusy
      };
  };

  var listenerHandler = function(idHandler) {
      var eventListeners = {};

      /**
       * Gets all listeners for the given element.
       * @public
       * @param {element} element The element to get all listeners for.
       * @returns All listeners for the given element.
       */
      function getListeners(element) {
          var id = idHandler.get(element);

          if (id === undefined) {
              return [];
          }

          return eventListeners[id] || [];
      }

      /**
       * Stores the given listener for the given element. Will not actually add the listener to the element.
       * @public
       * @param {element} element The element that should have the listener added.
       * @param {function} listener The callback that the element has added.
       */
      function addListener(element, listener) {
          var id = idHandler.get(element);

          if(!eventListeners[id]) {
              eventListeners[id] = [];
          }

          eventListeners[id].push(listener);
      }

      function removeListener(element, listener) {
          var listeners = getListeners(element);
          for (var i = 0, len = listeners.length; i < len; ++i) {
              if (listeners[i] === listener) {
                listeners.splice(i, 1);
                break;
              }
          }
      }

      function removeAllListeners(element) {
        var listeners = getListeners(element);
        if (!listeners) { return; }
        listeners.length = 0;
      }

      return {
          get: getListeners,
          add: addListener,
          removeListener: removeListener,
          removeAllListeners: removeAllListeners
      };
  };

  var idGenerator = function() {
      var idCount = 1;

      /**
       * Generates a new unique id in the context.
       * @public
       * @returns {number} A unique id in the context.
       */
      function generate() {
          return idCount++;
      }

      return {
          generate: generate
      };
  };

  var idHandler = function(options) {
      var idGenerator     = options.idGenerator;
      var getState        = options.stateHandler.getState;

      /**
       * Gets the resize detector id of the element.
       * @public
       * @param {element} element The target element to get the id of.
       * @returns {string|number|null} The id of the element. Null if it has no id.
       */
      function getId(element) {
          var state = getState(element);

          if (state && state.id !== undefined) {
              return state.id;
          }

          return null;
      }

      /**
       * Sets the resize detector id of the element. Requires the element to have a resize detector state initialized.
       * @public
       * @param {element} element The target element to set the id of.
       * @returns {string|number|null} The id of the element.
       */
      function setId(element) {
          var state = getState(element);

          if (!state) {
              throw new Error("setId required the element to have a resize detection state.");
          }

          var id = idGenerator.generate();

          state.id = id;

          return id;
      }

      return {
          get: getId,
          set: setId
      };
  };

  /* global console: false */

  /**
   * Reporter that handles the reporting of logs, warnings and errors.
   * @public
   * @param {boolean} quiet Tells if the reporter should be quiet or not.
   */
  var reporter = function(quiet) {
      function noop() {
          //Does nothing.
      }

      var reporter = {
          log: noop,
          warn: noop,
          error: noop
      };

      if(!quiet && window.console) {
          var attachFunction = function(reporter, name) {
              //The proxy is needed to be able to call the method with the console context,
              //since we cannot use bind.
              reporter[name] = function reporterProxy() {
                  var arguments$1 = arguments;

                  var f = console[name];
                  if (f.apply) { //IE9 does not support console.log.apply :)
                      f.apply(console, arguments);
                  } else {
                      for (var i = 0; i < arguments.length; i++) {
                          f(arguments$1[i]);
                      }
                  }
              };
          };

          attachFunction(reporter, "log");
          attachFunction(reporter, "warn");
          attachFunction(reporter, "error");
      }

      return reporter;
  };

  var browserDetector = createCommonjsModule(function (module) {

  var detector = module.exports = {};

  detector.isIE = function(version) {
      function isAnyIeVersion() {
          var agent = navigator.userAgent.toLowerCase();
          return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
      }

      if(!isAnyIeVersion()) {
          return false;
      }

      if(!version) {
          return true;
      }

      //Shamelessly stolen from https://gist.github.com/padolsey/527683
      var ieVersion = (function(){
          var undef,
              v = 3,
              div = document.createElement("div"),
              all = div.getElementsByTagName("i");

          do {
              div.innerHTML = "<!--[if gt IE " + (++v) + "]><i></i><![endif]-->";
          }
          while (all[0]);

          return v > 4 ? v : undef;
      }());

      return version === ieVersion;
  };

  detector.isLegacyOpera = function() {
      return !!window.opera;
  };
  });

  var utils_1 = createCommonjsModule(function (module) {

  var utils = module.exports = {};

  utils.getOption = getOption;

  function getOption(options, name, defaultValue) {
      var value = options[name];

      if((value === undefined || value === null) && defaultValue !== undefined) {
          return defaultValue;
      }

      return value;
  }
  });

  var batchProcessor = function batchProcessorMaker(options) {
      options             = options || {};
      var reporter        = options.reporter;
      var asyncProcess    = utils_1.getOption(options, "async", true);
      var autoProcess     = utils_1.getOption(options, "auto", true);

      if(autoProcess && !asyncProcess) {
          reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
          asyncProcess = true;
      }

      var batch = Batch();
      var asyncFrameHandler;
      var isProcessing = false;

      function addFunction(level, fn) {
          if(!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {
              // Since this is async, it is guaranteed to be executed after that the fn is added to the batch.
              // This needs to be done before, since we're checking the size of the batch to be 0.
              processBatchAsync();
          }

          batch.add(level, fn);
      }

      function processBatch() {
          // Save the current batch, and create a new batch so that incoming functions are not added into the currently processing batch.
          // Continue processing until the top-level batch is empty (functions may be added to the new batch while processing, and so on).
          isProcessing = true;
          while (batch.size()) {
              var processingBatch = batch;
              batch = Batch();
              processingBatch.process();
          }
          isProcessing = false;
      }

      function forceProcessBatch(localAsyncProcess) {
          if (isProcessing) {
              return;
          }

          if(localAsyncProcess === undefined) {
              localAsyncProcess = asyncProcess;
          }

          if(asyncFrameHandler) {
              cancelFrame(asyncFrameHandler);
              asyncFrameHandler = null;
          }

          if(localAsyncProcess) {
              processBatchAsync();
          } else {
              processBatch();
          }
      }

      function processBatchAsync() {
          asyncFrameHandler = requestFrame(processBatch);
      }

      function cancelFrame(listener) {
          // var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
          var cancel = clearTimeout;
          return cancel(listener);
      }

      function requestFrame(callback) {
          // var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(fn) { return window.setTimeout(fn, 20); };
          var raf = function(fn) { return setTimeout(fn, 0); };
          return raf(callback);
      }

      return {
          add: addFunction,
          force: forceProcessBatch
      };
  };

  function Batch() {
      var batch       = {};
      var size        = 0;
      var topLevel    = 0;
      var bottomLevel = 0;

      function add(level, fn) {
          if(!fn) {
              fn = level;
              level = 0;
          }

          if(level > topLevel) {
              topLevel = level;
          } else if(level < bottomLevel) {
              bottomLevel = level;
          }

          if(!batch[level]) {
              batch[level] = [];
          }

          batch[level].push(fn);
          size++;
      }

      function process() {
          for(var level = bottomLevel; level <= topLevel; level++) {
              var fns = batch[level];

              for(var i = 0; i < fns.length; i++) {
                  var fn = fns[i];
                  fn();
              }
          }
      }

      function getSize() {
          return size;
      }

      return {
          add: add,
          process: process,
          size: getSize
      };
  }

  var prop = "_erd";

  function initState(element) {
      element[prop] = {};
      return getState(element);
  }

  function getState(element) {
      return element[prop];
  }

  function cleanState(element) {
      delete element[prop];
  }

  var stateHandler = {
      initState: initState,
      getState: getState,
      cleanState: cleanState
  };

  var object = function(options) {
      options             = options || {};
      var reporter        = options.reporter;
      var batchProcessor  = options.batchProcessor;
      var getState        = options.stateHandler.getState;

      if(!reporter) {
          throw new Error("Missing required dependency: reporter.");
      }

      /**
       * Adds a resize event listener to the element.
       * @public
       * @param {element} element The element that should have the listener added.
       * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.
       */
      function addListener(element, listener) {
          if(!getObject(element)) {
              throw new Error("Element is not detectable by this strategy.");
          }

          function listenerProxy() {
              listener(element);
          }

          if(browserDetector.isIE(8)) {
              //IE 8 does not support object, but supports the resize event directly on elements.
              getState(element).object = {
                  proxy: listenerProxy
              };
              element.attachEvent("onresize", listenerProxy);
          } else {
              var object = getObject(element);
              object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
          }
      }

      /**
       * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.
       * @private
       * @param {object} options Optional options object.
       * @param {element} element The element to make detectable
       * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.
       */
      function makeDetectable(options, element, callback) {
          if (!callback) {
              callback = element;
              element = options;
              options = null;
          }

          options = options || {};
          var debug = options.debug;

          function injectObject(element, callback) {
              var OBJECT_STYLE = "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;";

              //The target element needs to be positioned (everything except static) so the absolute positioned object will be positioned relative to the target element.

              // Position altering may be performed directly or on object load, depending on if style resolution is possible directly or not.
              var positionCheckPerformed = false;

              // The element may not yet be attached to the DOM, and therefore the style object may be empty in some browsers.
              // Since the style object is a reference, it will be updated as soon as the element is attached to the DOM.
              var style = window.getComputedStyle(element);
              var width = element.offsetWidth;
              var height = element.offsetHeight;

              getState(element).startSize = {
                  width: width,
                  height: height
              };

              function mutateDom() {
                  function alterPositionStyles() {
                      if(style.position === "static") {
                          element.style.position = "relative";

                          var removeRelativeStyles = function(reporter, element, style, property) {
                              function getNumericalValue(value) {
                                  return value.replace(/[^-\d\.]/g, "");
                              }

                              var value = style[property];

                              if(value !== "auto" && getNumericalValue(value) !== "0") {
                                  reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                                  element.style[property] = 0;
                              }
                          };

                          //Check so that there are no accidental styles that will make the element styled differently now that is is relative.
                          //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).
                          removeRelativeStyles(reporter, element, style, "top");
                          removeRelativeStyles(reporter, element, style, "right");
                          removeRelativeStyles(reporter, element, style, "bottom");
                          removeRelativeStyles(reporter, element, style, "left");
                      }
                  }

                  function onObjectLoad() {
                      // The object has been loaded, which means that the element now is guaranteed to be attached to the DOM.
                      if (!positionCheckPerformed) {
                          alterPositionStyles();
                      }

                      /*jshint validthis: true */

                      function getDocument(element, callback) {
                          //Opera 12 seem to call the object.onload before the actual document has been created.
                          //So if it is not present, poll it with an timeout until it is present.
                          //TODO: Could maybe be handled better with object.onreadystatechange or similar.
                          if(!element.contentDocument) {
                              setTimeout(function checkForObjectDocument() {
                                  getDocument(element, callback);
                              }, 100);

                              return;
                          }

                          callback(element.contentDocument);
                      }

                      //Mutating the object element here seems to fire another load event.
                      //Mutating the inner document of the object element is fine though.
                      var objectElement = this;

                      //Create the style element to be added to the object.
                      getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
                          //Notify that the element is ready to be listened to.
                          callback(element);
                      });
                  }

                  // The element may be detached from the DOM, and some browsers does not support style resolving of detached elements.
                  // The alterPositionStyles needs to be delayed until we know the element has been attached to the DOM (which we are sure of when the onObjectLoad has been fired), if style resolution is not possible.
                  if (style.position !== "") {
                      alterPositionStyles();
                      positionCheckPerformed = true;
                  }

                  //Add an object element as a child to the target element that will be listened to for resize events.
                  var object = document.createElement("object");
                  object.style.cssText = OBJECT_STYLE;
                  object.tabIndex = -1;
                  object.type = "text/html";
                  object.setAttribute("aria-hidden", "true");
                  object.onload = onObjectLoad;

                  //Safari: This must occur before adding the object to the DOM.
                  //IE: Does not like that this happens before, even if it is also added after.
                  if(!browserDetector.isIE()) {
                      object.data = "about:blank";
                  }

                  element.appendChild(object);
                  getState(element).object = object;

                  //IE: This must occur after adding the object to the DOM.
                  if(browserDetector.isIE()) {
                      object.data = "about:blank";
                  }
              }

              if(batchProcessor) {
                  batchProcessor.add(mutateDom);
              } else {
                  mutateDom();
              }
          }

          if(browserDetector.isIE(8)) {
              //IE 8 does not support objects properly. Luckily they do support the resize event.
              //So do not inject the object and notify that the element is already ready to be listened to.
              //The event handler for the resize event is attached in the utils.addListener instead.
              callback(element);
          } else {
              injectObject(element, callback);
          }
      }

      /**
       * Returns the child object of the target element.
       * @private
       * @param {element} element The target element.
       * @returns The object element of the target.
       */
      function getObject(element) {
          return getState(element).object;
      }

      function uninstall(element) {
          if(browserDetector.isIE(8)) {
              element.detachEvent("onresize", getState(element).object.proxy);
          } else {
              element.removeChild(getObject(element));
          }
          delete getState(element).object;
      }

      return {
          makeDetectable: makeDetectable,
          addListener: addListener,
          uninstall: uninstall
      };
  };

  var forEach$1 = collectionUtils.forEach;

  var scroll = function(options) {
      options             = options || {};
      var reporter        = options.reporter;
      var batchProcessor  = options.batchProcessor;
      var getState        = options.stateHandler.getState;
      var hasState        = options.stateHandler.hasState;
      var idHandler       = options.idHandler;

      if (!batchProcessor) {
          throw new Error("Missing required dependency: batchProcessor");
      }

      if (!reporter) {
          throw new Error("Missing required dependency: reporter.");
      }

      //TODO: Could this perhaps be done at installation time?
      var scrollbarSizes = getScrollbarSizes();

      // Inject the scrollbar styling that prevents them from appearing sometimes in Chrome.
      // The injected container needs to have a class, so that it may be styled with CSS (pseudo elements).
      var styleId = "erd_scroll_detection_scrollbar_style";
      var detectionContainerClass = "erd_scroll_detection_container";
      injectScrollStyle(styleId, detectionContainerClass);

      function getScrollbarSizes() {
          var width = 500;
          var height = 500;

          var child = document.createElement("div");
          child.style.cssText = "position: absolute; width: " + width*2 + "px; height: " + height*2 + "px; visibility: hidden; margin: 0; padding: 0;";

          var container = document.createElement("div");
          container.style.cssText = "position: absolute; width: " + width + "px; height: " + height + "px; overflow: scroll; visibility: none; top: " + -width*3 + "px; left: " + -height*3 + "px; visibility: hidden; margin: 0; padding: 0;";

          container.appendChild(child);

          document.body.insertBefore(container, document.body.firstChild);

          var widthSize = width - container.clientWidth;
          var heightSize = height - container.clientHeight;

          document.body.removeChild(container);

          return {
              width: widthSize,
              height: heightSize
          };
      }

      function injectScrollStyle(styleId, containerClass) {
          function injectStyle(style, method) {
              method = method || function (element) {
                  document.head.appendChild(element);
              };

              var styleElement = document.createElement("style");
              styleElement.innerHTML = style;
              styleElement.id = styleId;
              method(styleElement);
              return styleElement;
          }

          if (!document.getElementById(styleId)) {
              var containerAnimationClass = containerClass + "_animation";
              var containerAnimationActiveClass = containerClass + "_animation_active";
              var style = "/* Created by the element-resize-detector library. */\n";
              style += "." + containerClass + " > div::-webkit-scrollbar { display: none; }\n\n";
              style += "." + containerAnimationActiveClass + " { -webkit-animation-duration: 0.1s; animation-duration: 0.1s; -webkit-animation-name: " + containerAnimationClass + "; animation-name: " + containerAnimationClass + "; }\n";
              style += "@-webkit-keyframes " + containerAnimationClass +  " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";
              style += "@keyframes " + containerAnimationClass +          " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";
              injectStyle(style);
          }
      }

      function addAnimationClass(element) {
          element.className += " " + detectionContainerClass + "_animation_active";
      }

      function addEvent(el, name, cb) {
          if (el.addEventListener) {
              el.addEventListener(name, cb);
          } else if(el.attachEvent) {
              el.attachEvent("on" + name, cb);
          } else {
              return reporter.error("[scroll] Don't know how to add event listeners.");
          }
      }

      function removeEvent(el, name, cb) {
          if (el.removeEventListener) {
              el.removeEventListener(name, cb);
          } else if(el.detachEvent) {
              el.detachEvent("on" + name, cb);
          } else {
              return reporter.error("[scroll] Don't know how to remove event listeners.");
          }
      }

      function getExpandElement(element) {
          return getState(element).container.childNodes[0].childNodes[0].childNodes[0];
      }

      function getShrinkElement(element) {
          return getState(element).container.childNodes[0].childNodes[0].childNodes[1];
      }

      /**
       * Adds a resize event listener to the element.
       * @public
       * @param {element} element The element that should have the listener added.
       * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.
       */
      function addListener(element, listener) {
          var listeners = getState(element).listeners;

          if (!listeners.push) {
              throw new Error("Cannot add listener to an element that is not detectable.");
          }

          getState(element).listeners.push(listener);
      }

      /**
       * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.
       * @private
       * @param {object} options Optional options object.
       * @param {element} element The element to make detectable
       * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.
       */
      function makeDetectable(options, element, callback) {
          if (!callback) {
              callback = element;
              element = options;
              options = null;
          }

          options = options || {};

          function debug() {
              if (options.debug) {
                  var args = Array.prototype.slice.call(arguments);
                  args.unshift(idHandler.get(element), "Scroll: ");
                  if (reporter.log.apply) {
                      reporter.log.apply(null, args);
                  } else {
                      for (var i = 0; i < args.length; i++) {
                          reporter.log(args[i]);
                      }
                  }
              }
          }

          function isDetached(element) {
              function isInDocument(element) {
                  return element === element.ownerDocument.body || element.ownerDocument.body.contains(element);
              }

              if (!isInDocument(element)) {
                  return true;
              }

              // FireFox returns null style in hidden iframes. See https://github.com/wnr/element-resize-detector/issues/68 and https://bugzilla.mozilla.org/show_bug.cgi?id=795520
              if (window.getComputedStyle(element) === null) {
                  return true;
              }

              return false;
          }

          function isUnrendered(element) {
              // Check the absolute positioned container since the top level container is display: inline.
              var container = getState(element).container.childNodes[0];
              var style = window.getComputedStyle(container);
              return !style.width || style.width.indexOf("px") === -1; //Can only compute pixel value when rendered.
          }

          function getStyle() {
              // Some browsers only force layouts when actually reading the style properties of the style object, so make sure that they are all read here,
              // so that the user of the function can be sure that it will perform the layout here, instead of later (important for batching).
              var elementStyle            = window.getComputedStyle(element);
              var style                   = {};
              style.position              = elementStyle.position;
              style.width                 = element.offsetWidth;
              style.height                = element.offsetHeight;
              style.top                   = elementStyle.top;
              style.right                 = elementStyle.right;
              style.bottom                = elementStyle.bottom;
              style.left                  = elementStyle.left;
              style.widthCSS              = elementStyle.width;
              style.heightCSS             = elementStyle.height;
              return style;
          }

          function storeStartSize() {
              var style = getStyle();
              getState(element).startSize = {
                  width: style.width,
                  height: style.height
              };
              debug("Element start size", getState(element).startSize);
          }

          function initListeners() {
              getState(element).listeners = [];
          }

          function storeStyle() {
              debug("storeStyle invoked.");
              if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
              }

              var style = getStyle();
              getState(element).style = style;
          }

          function storeCurrentSize(element, width, height) {
              getState(element).lastWidth = width;
              getState(element).lastHeight  = height;
          }

          function getExpandChildElement(element) {
              return getExpandElement(element).childNodes[0];
          }

          function getWidthOffset() {
              return 2 * scrollbarSizes.width + 1;
          }

          function getHeightOffset() {
              return 2 * scrollbarSizes.height + 1;
          }

          function getExpandWidth(width) {
              return width + 10 + getWidthOffset();
          }

          function getExpandHeight(height) {
              return height + 10 + getHeightOffset();
          }

          function getShrinkWidth(width) {
              return width * 2 + getWidthOffset();
          }

          function getShrinkHeight(height) {
              return height * 2 + getHeightOffset();
          }

          function positionScrollbars(element, width, height) {
              var expand          = getExpandElement(element);
              var shrink          = getShrinkElement(element);
              var expandWidth     = getExpandWidth(width);
              var expandHeight    = getExpandHeight(height);
              var shrinkWidth     = getShrinkWidth(width);
              var shrinkHeight    = getShrinkHeight(height);
              expand.scrollLeft   = expandWidth;
              expand.scrollTop    = expandHeight;
              shrink.scrollLeft   = shrinkWidth;
              shrink.scrollTop    = shrinkHeight;
          }

          function injectContainerElement() {
              var container = getState(element).container;

              if (!container) {
                  container                   = document.createElement("div");
                  container.className         = detectionContainerClass;
                  container.style.cssText     = "visibility: hidden; display: inline; width: 0px; height: 0px; z-index: -1; overflow: hidden; margin: 0; padding: 0;";
                  getState(element).container = container;
                  addAnimationClass(container);
                  element.appendChild(container);

                  var onAnimationStart = function () {
                      getState(element).onRendered && getState(element).onRendered();
                  };

                  addEvent(container, "animationstart", onAnimationStart);

                  // Store the event handler here so that they may be removed when uninstall is called.
                  // See uninstall function for an explanation why it is needed.
                  getState(element).onAnimationStart = onAnimationStart;
              }

              return container;
          }

          function injectScrollElements() {
              function alterPositionStyles() {
                  var style = getState(element).style;

                  if(style.position === "static") {
                      element.style.position = "relative";

                      var removeRelativeStyles = function(reporter, element, style, property) {
                          function getNumericalValue(value) {
                              return value.replace(/[^-\d\.]/g, "");
                          }

                          var value = style[property];

                          if(value !== "auto" && getNumericalValue(value) !== "0") {
                              reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                              element.style[property] = 0;
                          }
                      };

                      //Check so that there are no accidental styles that will make the element styled differently now that is is relative.
                      //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).
                      removeRelativeStyles(reporter, element, style, "top");
                      removeRelativeStyles(reporter, element, style, "right");
                      removeRelativeStyles(reporter, element, style, "bottom");
                      removeRelativeStyles(reporter, element, style, "left");
                  }
              }

              function getLeftTopBottomRightCssText(left, top, bottom, right) {
                  left = (!left ? "0" : (left + "px"));
                  top = (!top ? "0" : (top + "px"));
                  bottom = (!bottom ? "0" : (bottom + "px"));
                  right = (!right ? "0" : (right + "px"));

                  return "left: " + left + "; top: " + top + "; right: " + right + "; bottom: " + bottom + ";";
              }

              debug("Injecting elements");

              if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
              }

              alterPositionStyles();

              var rootContainer = getState(element).container;

              if (!rootContainer) {
                  rootContainer = injectContainerElement();
              }

              // Due to this WebKit bug https://bugs.webkit.org/show_bug.cgi?id=80808 (currently fixed in Blink, but still present in WebKit browsers such as Safari),
              // we need to inject two containers, one that is width/height 100% and another that is left/top -1px so that the final container always is 1x1 pixels bigger than
              // the targeted element.
              // When the bug is resolved, "containerContainer" may be removed.

              // The outer container can occasionally be less wide than the targeted when inside inline elements element in WebKit (see https://bugs.webkit.org/show_bug.cgi?id=152980).
              // This should be no problem since the inner container either way makes sure the injected scroll elements are at least 1x1 px.

              var scrollbarWidth          = scrollbarSizes.width;
              var scrollbarHeight         = scrollbarSizes.height;
              var containerContainerStyle = "position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; width: 100%; height: 100%; left: 0px; top: 0px;";
              var containerStyle          = "position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; " + getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth);
              var expandStyle             = "position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;";
              var shrinkStyle             = "position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;";
              var expandChildStyle        = "position: absolute; left: 0; top: 0;";
              var shrinkChildStyle        = "position: absolute; width: 200%; height: 200%;";

              var containerContainer      = document.createElement("div");
              var container               = document.createElement("div");
              var expand                  = document.createElement("div");
              var expandChild             = document.createElement("div");
              var shrink                  = document.createElement("div");
              var shrinkChild             = document.createElement("div");

              // Some browsers choke on the resize system being rtl, so force it to ltr. https://github.com/wnr/element-resize-detector/issues/56
              // However, dir should not be set on the top level container as it alters the dimensions of the target element in some browsers.
              containerContainer.dir              = "ltr";

              containerContainer.style.cssText    = containerContainerStyle;
              containerContainer.className        = detectionContainerClass;
              container.className                 = detectionContainerClass;
              container.style.cssText             = containerStyle;
              expand.style.cssText                = expandStyle;
              expandChild.style.cssText           = expandChildStyle;
              shrink.style.cssText                = shrinkStyle;
              shrinkChild.style.cssText           = shrinkChildStyle;

              expand.appendChild(expandChild);
              shrink.appendChild(shrinkChild);
              container.appendChild(expand);
              container.appendChild(shrink);
              containerContainer.appendChild(container);
              rootContainer.appendChild(containerContainer);

              function onExpandScroll() {
                  getState(element).onExpand && getState(element).onExpand();
              }

              function onShrinkScroll() {
                  getState(element).onShrink && getState(element).onShrink();
              }

              addEvent(expand, "scroll", onExpandScroll);
              addEvent(shrink, "scroll", onShrinkScroll);

              // Store the event handlers here so that they may be removed when uninstall is called.
              // See uninstall function for an explanation why it is needed.
              getState(element).onExpandScroll = onExpandScroll;
              getState(element).onShrinkScroll = onShrinkScroll;
          }

          function registerListenersAndPositionElements() {
              function updateChildSizes(element, width, height) {
                  var expandChild             = getExpandChildElement(element);
                  var expandWidth             = getExpandWidth(width);
                  var expandHeight            = getExpandHeight(height);
                  expandChild.style.width     = expandWidth + "px";
                  expandChild.style.height    = expandHeight + "px";
              }

              function updateDetectorElements(done) {
                  var width           = element.offsetWidth;
                  var height          = element.offsetHeight;

                  debug("Storing current size", width, height);

                  // Store the size of the element sync here, so that multiple scroll events may be ignored in the event listeners.
                  // Otherwise the if-check in handleScroll is useless.
                  storeCurrentSize(element, width, height);

                  // Since we delay the processing of the batch, there is a risk that uninstall has been called before the batch gets to execute.
                  // Since there is no way to cancel the fn executions, we need to add an uninstall guard to all fns of the batch.

                  batchProcessor.add(0, function performUpdateChildSizes() {
                      if (!getState(element)) {
                          debug("Aborting because element has been uninstalled");
                          return;
                      }

                      if (!areElementsInjected()) {
                          debug("Aborting because element container has not been initialized");
                          return;
                      }

                      if (options.debug) {
                          var w = element.offsetWidth;
                          var h = element.offsetHeight;

                          if (w !== width || h !== height) {
                              reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                          }
                      }

                      updateChildSizes(element, width, height);
                  });

                  batchProcessor.add(1, function updateScrollbars() {
                      if (!getState(element)) {
                          debug("Aborting because element has been uninstalled");
                          return;
                      }

                      if (!areElementsInjected()) {
                          debug("Aborting because element container has not been initialized");
                          return;
                      }

                      positionScrollbars(element, width, height);
                  });

                  if (done) {
                      batchProcessor.add(2, function () {
                          if (!getState(element)) {
                              debug("Aborting because element has been uninstalled");
                              return;
                          }

                          if (!areElementsInjected()) {
                            debug("Aborting because element container has not been initialized");
                            return;
                          }

                          done();
                      });
                  }
              }

              function areElementsInjected() {
                  return !!getState(element).container;
              }

              function notifyListenersIfNeeded() {
                  function isFirstNotify() {
                      return getState(element).lastNotifiedWidth === undefined;
                  }

                  debug("notifyListenersIfNeeded invoked");

                  var state = getState(element);

                  // Don't notify the if the current size is the start size, and this is the first notification.
                  if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {
                      return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");
                  }

                  // Don't notify if the size already has been notified.
                  if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {
                      return debug("Not notifying: Size already notified");
                  }


                  debug("Current size not notified, notifying...");
                  state.lastNotifiedWidth = state.lastWidth;
                  state.lastNotifiedHeight = state.lastHeight;
                  forEach$1(getState(element).listeners, function (listener) {
                      listener(element);
                  });
              }

              function handleRender() {
                  debug("startanimation triggered.");

                  if (isUnrendered(element)) {
                      debug("Ignoring since element is still unrendered...");
                      return;
                  }

                  debug("Element rendered.");
                  var expand = getExpandElement(element);
                  var shrink = getShrinkElement(element);
                  if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {
                      debug("Scrollbars out of sync. Updating detector elements...");
                      updateDetectorElements(notifyListenersIfNeeded);
                  }
              }

              function handleScroll() {
                  debug("Scroll detected.");

                  if (isUnrendered(element)) {
                      // Element is still unrendered. Skip this scroll event.
                      debug("Scroll event fired while unrendered. Ignoring...");
                      return;
                  }

                  var width = element.offsetWidth;
                  var height = element.offsetHeight;

                  if (width !== getState(element).lastWidth || height !== getState(element).lastHeight) {
                      debug("Element size changed.");
                      updateDetectorElements(notifyListenersIfNeeded);
                  } else {
                      debug("Element size has not changed (" + width + "x" + height + ").");
                  }
              }

              debug("registerListenersAndPositionElements invoked.");

              if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
              }

              getState(element).onRendered = handleRender;
              getState(element).onExpand = handleScroll;
              getState(element).onShrink = handleScroll;

              var style = getState(element).style;
              updateChildSizes(element, style.width, style.height);
          }

          function finalizeDomMutation() {
              debug("finalizeDomMutation invoked.");

              if (!getState(element)) {
                  debug("Aborting because element has been uninstalled");
                  return;
              }

              var style = getState(element).style;
              storeCurrentSize(element, style.width, style.height);
              positionScrollbars(element, style.width, style.height);
          }

          function ready() {
              callback(element);
          }

          function install() {
              debug("Installing...");
              initListeners();
              storeStartSize();

              batchProcessor.add(0, storeStyle);
              batchProcessor.add(1, injectScrollElements);
              batchProcessor.add(2, registerListenersAndPositionElements);
              batchProcessor.add(3, finalizeDomMutation);
              batchProcessor.add(4, ready);
          }

          debug("Making detectable...");

          if (isDetached(element)) {
              debug("Element is detached");

              injectContainerElement();

              debug("Waiting until element is attached...");

              getState(element).onRendered = function () {
                  debug("Element is now attached");
                  install();
              };
          } else {
              install();
          }
      }

      function uninstall(element) {
          var state = getState(element);

          if (!state) {
              // Uninstall has been called on a non-erd element.
              return;
          }

          // Uninstall may have been called in the following scenarios:
          // (1) Right between the sync code and async batch (here state.busy = true, but nothing have been registered or injected).
          // (2) In the ready callback of the last level of the batch by another element (here, state.busy = true, but all the stuff has been injected).
          // (3) After the installation process (here, state.busy = false and all the stuff has been injected).
          // So to be on the safe side, let's check for each thing before removing.

          // We need to remove the event listeners, because otherwise the event might fire on an uninstall element which results in an error when trying to get the state of the element.
          state.onExpandScroll && removeEvent(getExpandElement(element), "scroll", state.onExpandScroll);
          state.onShrinkScroll && removeEvent(getShrinkElement(element), "scroll", state.onShrinkScroll);
          state.onAnimationStart && removeEvent(state.container, "animationstart", state.onAnimationStart);

          state.container && element.removeChild(state.container);
      }

      return {
          makeDetectable: makeDetectable,
          addListener: addListener,
          uninstall: uninstall
      };
  };

  var forEach$2                 = collectionUtils.forEach;









  //Detection strategies.



  function isCollection(obj) {
      return Array.isArray(obj) || obj.length !== undefined;
  }

  function toArray(collection) {
      if (!Array.isArray(collection)) {
          var array = [];
          forEach$2(collection, function (obj) {
              array.push(obj);
          });
          return array;
      } else {
          return collection;
      }
  }

  function isElement(obj) {
      return obj && obj.nodeType === 1;
  }

  /**
   * @typedef idHandler
   * @type {object}
   * @property {function} get Gets the resize detector id of the element.
   * @property {function} set Generate and sets the resize detector id of the element.
   */

  /**
   * @typedef Options
   * @type {object}
   * @property {boolean} callOnAdd    Determines if listeners should be called when they are getting added.
                                      Default is true. If true, the listener is guaranteed to be called when it has been added.
                                      If false, the listener will not be guarenteed to be called when it has been added (does not prevent it from being called).
   * @property {idHandler} idHandler  A custom id handler that is responsible for generating, setting and retrieving id's for elements.
                                      If not provided, a default id handler will be used.
   * @property {reporter} reporter    A custom reporter that handles reporting logs, warnings and errors.
                                      If not provided, a default id handler will be used.
                                      If set to false, then nothing will be reported.
   * @property {boolean} debug        If set to true, the the system will report debug messages as default for the listenTo method.
   */

  /**
   * Creates an element resize detector instance.
   * @public
   * @param {Options?} options Optional global options object that will decide how this instance will work.
   */
  var elementResizeDetector = function(options) {
      options = options || {};

      //idHandler is currently not an option to the listenTo function, so it should not be added to globalOptions.
      var idHandler$1;

      if (options.idHandler) {
          // To maintain compatability with idHandler.get(element, readonly), make sure to wrap the given idHandler
          // so that readonly flag always is true when it's used here. This may be removed next major version bump.
          idHandler$1 = {
              get: function (element) { return options.idHandler.get(element, true); },
              set: options.idHandler.set
          };
      } else {
          var idGenerator$1 = idGenerator();
          var defaultIdHandler = idHandler({
              idGenerator: idGenerator$1,
              stateHandler: stateHandler
          });
          idHandler$1 = defaultIdHandler;
      }

      //reporter is currently not an option to the listenTo function, so it should not be added to globalOptions.
      var reporter$1 = options.reporter;

      if(!reporter$1) {
          //If options.reporter is false, then the reporter should be quiet.
          var quiet = reporter$1 === false;
          reporter$1 = reporter(quiet);
      }

      //batchProcessor is currently not an option to the listenTo function, so it should not be added to globalOptions.
      var batchProcessor$1 = getOption(options, "batchProcessor", batchProcessor({ reporter: reporter$1 }));

      //Options to be used as default for the listenTo function.
      var globalOptions = {};
      globalOptions.callOnAdd     = !!getOption(options, "callOnAdd", true);
      globalOptions.debug         = !!getOption(options, "debug", false);

      var eventListenerHandler    = listenerHandler(idHandler$1);
      var elementUtils$1            = elementUtils({
          stateHandler: stateHandler
      });

      //The detection strategy to be used.
      var detectionStrategy;
      var desiredStrategy = getOption(options, "strategy", "object");
      var strategyOptions = {
          reporter: reporter$1,
          batchProcessor: batchProcessor$1,
          stateHandler: stateHandler,
          idHandler: idHandler$1
      };

      if(desiredStrategy === "scroll") {
          if (browserDetector.isLegacyOpera()) {
              reporter$1.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
              desiredStrategy = "object";
          } else if (browserDetector.isIE(9)) {
              reporter$1.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");
              desiredStrategy = "object";
          }
      }

      if(desiredStrategy === "scroll") {
          detectionStrategy = scroll(strategyOptions);
      } else if(desiredStrategy === "object") {
          detectionStrategy = object(strategyOptions);
      } else {
          throw new Error("Invalid strategy name: " + desiredStrategy);
      }

      //Calls can be made to listenTo with elements that are still being installed.
      //Also, same elements can occur in the elements list in the listenTo function.
      //With this map, the ready callbacks can be synchronized between the calls
      //so that the ready callback can always be called when an element is ready - even if
      //it wasn't installed from the function itself.
      var onReadyCallbacks = {};

      /**
       * Makes the given elements resize-detectable and starts listening to resize events on the elements. Calls the event callback for each event for each element.
       * @public
       * @param {Options?} options Optional options object. These options will override the global options. Some options may not be overriden, such as idHandler.
       * @param {element[]|element} elements The given array of elements to detect resize events of. Single element is also valid.
       * @param {function} listener The callback to be executed for each resize event for each element.
       */
      function listenTo(options, elements, listener) {
          function onResizeCallback(element) {
              var listeners = eventListenerHandler.get(element);
              forEach$2(listeners, function callListenerProxy(listener) {
                  listener(element);
              });
          }

          function addListener(callOnAdd, element, listener) {
              eventListenerHandler.add(element, listener);

              if(callOnAdd) {
                  listener(element);
              }
          }

          //Options object may be omitted.
          if(!listener) {
              listener = elements;
              elements = options;
              options = {};
          }

          if(!elements) {
              throw new Error("At least one element required.");
          }

          if(!listener) {
              throw new Error("Listener required.");
          }

          if (isElement(elements)) {
              // A single element has been passed in.
              elements = [elements];
          } else if (isCollection(elements)) {
              // Convert collection to array for plugins.
              // TODO: May want to check so that all the elements in the collection are valid elements.
              elements = toArray(elements);
          } else {
              return reporter$1.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
          }

          var elementsReady = 0;

          var callOnAdd = getOption(options, "callOnAdd", globalOptions.callOnAdd);
          var onReadyCallback = getOption(options, "onReady", function noop() {});
          var debug = getOption(options, "debug", globalOptions.debug);

          forEach$2(elements, function attachListenerToElement(element) {
              if (!stateHandler.getState(element)) {
                  stateHandler.initState(element);
                  idHandler$1.set(element);
              }

              var id = idHandler$1.get(element);

              debug && reporter$1.log("Attaching listener to element", id, element);

              if(!elementUtils$1.isDetectable(element)) {
                  debug && reporter$1.log(id, "Not detectable.");
                  if(elementUtils$1.isBusy(element)) {
                      debug && reporter$1.log(id, "System busy making it detectable");

                      //The element is being prepared to be detectable. Do not make it detectable.
                      //Just add the listener, because the element will soon be detectable.
                      addListener(callOnAdd, element, listener);
                      onReadyCallbacks[id] = onReadyCallbacks[id] || [];
                      onReadyCallbacks[id].push(function onReady() {
                          elementsReady++;

                          if(elementsReady === elements.length) {
                              onReadyCallback();
                          }
                      });
                      return;
                  }

                  debug && reporter$1.log(id, "Making detectable...");
                  //The element is not prepared to be detectable, so do prepare it and add a listener to it.
                  elementUtils$1.markBusy(element, true);
                  return detectionStrategy.makeDetectable({ debug: debug }, element, function onElementDetectable(element) {
                      debug && reporter$1.log(id, "onElementDetectable");

                      if (stateHandler.getState(element)) {
                          elementUtils$1.markAsDetectable(element);
                          elementUtils$1.markBusy(element, false);
                          detectionStrategy.addListener(element, onResizeCallback);
                          addListener(callOnAdd, element, listener);

                          // Since the element size might have changed since the call to "listenTo", we need to check for this change,
                          // so that a resize event may be emitted.
                          // Having the startSize object is optional (since it does not make sense in some cases such as unrendered elements), so check for its existance before.
                          // Also, check the state existance before since the element may have been uninstalled in the installation process.
                          var state = stateHandler.getState(element);
                          if (state && state.startSize) {
                              var width = element.offsetWidth;
                              var height = element.offsetHeight;
                              if (state.startSize.width !== width || state.startSize.height !== height) {
                                  onResizeCallback(element);
                              }
                          }

                          if(onReadyCallbacks[id]) {
                              forEach$2(onReadyCallbacks[id], function(callback) {
                                  callback();
                              });
                          }
                      } else {
                          // The element has been unisntalled before being detectable.
                          debug && reporter$1.log(id, "Element uninstalled before being detectable.");
                      }

                      delete onReadyCallbacks[id];

                      elementsReady++;
                      if(elementsReady === elements.length) {
                          onReadyCallback();
                      }
                  });
              }

              debug && reporter$1.log(id, "Already detecable, adding listener.");

              //The element has been prepared to be detectable and is ready to be listened to.
              addListener(callOnAdd, element, listener);
              elementsReady++;
          });

          if(elementsReady === elements.length) {
              onReadyCallback();
          }
      }

      function uninstall(elements) {
          if(!elements) {
              return reporter$1.error("At least one element is required.");
          }

          if (isElement(elements)) {
              // A single element has been passed in.
              elements = [elements];
          } else if (isCollection(elements)) {
              // Convert collection to array for plugins.
              // TODO: May want to check so that all the elements in the collection are valid elements.
              elements = toArray(elements);
          } else {
              return reporter$1.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
          }

          forEach$2(elements, function (element) {
              eventListenerHandler.removeAllListeners(element);
              detectionStrategy.uninstall(element);
              stateHandler.cleanState(element);
          });
      }

      return {
          listenTo: listenTo,
          removeListener: eventListenerHandler.removeListener,
          removeAllListeners: eventListenerHandler.removeAllListeners,
          uninstall: uninstall
      };
  };

  function getOption(options, name, defaultValue) {
      var value = options[name];

      if((value === undefined || value === null) && defaultValue !== undefined) {
          return defaultValue;
      }

      return value;
  }

  var Resize = /*@__PURE__*/(function (Event) {
    function Resize () {
      Event.apply(this, arguments);
    }

    if ( Event ) Resize.__proto__ = Event;
    Resize.prototype = Object.create( Event && Event.prototype );
    Resize.prototype.constructor = Resize;

    Resize.prototype.bind = function bind (box, data, snippet) {
      var this$1 = this;

      var node = this
        .resolveValue(box, data, snippet)
        .node();

      var resizer = elementResizeDetector({
        callOnAdd: false
      });

      var debouncer = debounce(function () {
        this$1.handleBefore(box, data, snippet);
      }, 100);

      var height = node.offsetHeight;
      var width = node.offsetWidth;

      resizer.listenTo(node, function () {
        if (
          node.offsetHeight !== height ||
          node.offsetWidth !== width
        ) {
          debouncer();
        }

        height = node.offsetHeight;
        width = node.offsetWidth;
      });

      node.resizer = resizer;
    };

    Resize.prototype.unbind = function unbind (snippet) {
      var node = snippet.node().node();
      node.resizer.uninstall(node);
    };

    return Resize;
  }(Event$1));

  var Scroll = /*@__PURE__*/(function (Event) {
    function Scroll(options) {
      if ( options === void 0 ) options = {};

      Event.call(this, options);

      this._height = null;
      this.setHeight(options.height);

      this
        .name('scroll')
        .throttle(250);
    }

    if ( Event ) Scroll.__proto__ = Event;
    Scroll.prototype = Object.create( Event && Event.prototype );
    Scroll.prototype.constructor = Scroll;

    Scroll.prototype.getHeight = function getHeight () {
      return this._height;
    };

    Scroll.prototype.setHeight = function setHeight (value) {
      if ( value === void 0 ) value = 48;

      this._height = value;
      return this;
    };

    Scroll.prototype.height = function height (value) {
      return this.setHeight(value);
    };

    Scroll.prototype.resolveAfter = function resolveAfter (box, data) {
      var result = Event.prototype.resolveAfter.call(this, box, data);

      for (var i = 0; i < result.length; i += 1) {
        result[i].dispatch('scroll');
      }

      return result;
    };

    Scroll.prototype.resolveBefore = function resolveBefore (box, data) {
      defaultsDeep(box, {
        list: {
          count: 0,
          height: 0,
          offset: 0,
          total: 0
        }
      });

      return this.resolveOuter(box, data);
    };

    Scroll.prototype.handle = function handle (box, data, snippet) {
      if (box.list.total % box.list.count > 0) {
        return false;
      }

      var initialized = box.list.height > 0;

      if (initialized === false) {
        box.list.height = parseInt(snippet.node().style('height'), 10);
        box.list.count = Math.round(box.list.height / this._height) * 2;
      }

      var node = snippet.node().node();
      var top = box.list.height + node.scrollTop;
      var threshold = node.scrollHeight - (box.list.height / 4 * 2);

      if (top > threshold) {
        if (initialized === true) {
          box.list.offset += box.list.count;
        }

        this.pass(box, data);
        return true;
      }

      return false;
    };

    return Scroll;
  }(Event$1));

  var Submit = /*@__PURE__*/(function (Event) {
    function Submit(options) {
      Event.call(this, options);
      this.name('submit');
    }

    if ( Event ) Submit.__proto__ = Event;
    Submit.prototype = Object.create( Event && Event.prototype );
    Submit.prototype.constructor = Submit;

    Submit.prototype.handle = function handle (box, data, snippet) {
      data = {};

      var formData = new FormData(snippet.node().node());
      var keys = Array.from(formData.keys());

      var key = null;
      var value = null;

      for (var i = 0; i < keys.length; i += 1) {
        key = keys[i];

        value = formData.getAll(key);
        value = value.length === 1 ? value[0] : value;

        data[key] = value;
      }

      this.pass(box, data);

      return true;
    };

    return Submit;
  }(Event$1));

  var Tab = /*@__PURE__*/(function (Click) {
    function Tab () {
      Click.apply(this, arguments);
    }

    if ( Click ) Tab.__proto__ = Click;
    Tab.prototype = Object.create( Click && Click.prototype );
    Tab.prototype.constructor = Tab;

    Tab.prototype.resolveAfter = function resolveAfter (box, data) {
      box.tab = 0;

      var result = Click.prototype.resolveAfter.call(this, box, data);

      for (var i = 0; i < result.length; i += 1) {
        this.changeTab(box, data, result[i]);
      }

      return result;
    };

    Tab.prototype.changeTab = function changeTab (box, data, node) {
      var children = Array.from(node.node().children);
      node.classed('selected', true);

      selectAll(children).classed('selected', false);
      select(children[box.tab]).classed('selected', true);
    };

    Tab.prototype.handle = function handle (box, data, snippet) {
      var node = snippet.node();
      var children = Array.from(node.node().children);
      var tab = children.indexOf(event$1.target);

      if (tab === box.tab || tab < 0) {
        return false;
      }

      box.tab = tab;

      this.changeTab(box, data, node);
      this.pass(box, data);

      return false;
    };

    return Tab;
  }(Click));

  var Toggle = /*@__PURE__*/(function (Click) {
    function Toggle () {
      Click.apply(this, arguments);
    }

    if ( Click ) Toggle.__proto__ = Click;
    Toggle.prototype = Object.create( Click && Click.prototype );
    Toggle.prototype.constructor = Toggle;

    Toggle.prototype.handle = function handle (box, data, snippet) {
      var node = snippet.node();
      box.toggle = !node.classed('toggled');

      node.classed('toggled', box.toggle);
      this.pass(box, data);

      return false;
    };

    return Toggle;
  }(Click));



  var event$2 = /*#__PURE__*/Object.freeze({
    Click: Click,
    Fold: Fold,
    Input: Input$1,
    Resize: Resize,
    Scroll: Scroll,
    Submit: Submit,
    Tab: Tab,
    Toggle: Toggle
  });

  var Generator = /*@__PURE__*/(function (Node) {
    function Generator () {
      Node.apply(this, arguments);
    }

    if ( Node ) Generator.__proto__ = Node;
    Generator.prototype = Object.create( Node && Node.prototype );
    Generator.prototype.constructor = Generator;

    Generator.prototype.appendChild = function appendChild (box, data, snippet) {
      if ( snippet === void 0 ) snippet = null;

      if (snippet === null) {
        return null;
      }

      var node = snippet
        .clone()
        .resolve(box, data);

      node = Array.isArray(node) ? node[0] : node;

      var transition = select(node.node().parentNode)
        .classed('transition');

      node.classed('transition', transition);
      node.style('width');
      node.classed('in', true);

      return node;
    };

    Generator.prototype.removeChildren = function removeChildren () {
      var children = Array.from(this._node.node().childNodes);

      if (children.length === 0) {
        return;
      }

      children = selectAll(children)
        .classed('out', true)
        .on('transitionend.scola-generator', function (datum, index, nodes) {
          select(nodes[index]).on('.scola-generator', null);
          nodes[index].snippet.remove();
        });

      var duration = parseFloat(
        children.style('transition-duration')
      );

      if (duration === 0) {
        children.dispatch('transitionend');
      }
    };

    return Generator;
  }(Node$1));

  var Data = function Data(options) {
    if ( options === void 0 ) options = {};

    this._filter = null;
    this._exogenous = null;
    this._endogenous = null;
    this._position = null;

    this.setFilter(options.filter);
    this.setExogenous(options.exogenous);
    this.setEndogenous(options.endogenous);
    this.setPosition(options.position);
  };

  Data.prototype.getFilter = function getFilter () {
    return this._filter;
  };

  Data.prototype.setFilter = function setFilter (value) {
      if ( value === void 0 ) value = function () { return true; };

    this._filter = value;
    return this;
  };

  Data.prototype.getExogenous = function getExogenous () {
    return this._exogenous;
  };

  Data.prototype.setExogenous = function setExogenous (value) {
      if ( value === void 0 ) value = null;

    this._exogenous = value;
    return this;
  };

  Data.prototype.getEndogenous = function getEndogenous () {
    return this._endogenous;
  };

  Data.prototype.setEndogenous = function setEndogenous (value) {
      if ( value === void 0 ) value = null;

    this._endogenous = value;
    return this;
  };

  Data.prototype.getPosition = function getPosition () {
    return this._position;
  };

  Data.prototype.setPosition = function setPosition (value) {
      if ( value === void 0 ) value = [];

    this._position = value;
    return this;
  };

  Data.prototype.addPosition = function addPosition (value) {
    this._position[this._position.length] = value;
    return this;
  };

  Data.prototype.bottom = function bottom () {
    return this.addPosition('bottom');
  };

  Data.prototype.filter = function filter (value) {
    return this.setFilter(value);
  };

  Data.prototype.left = function left () {
    return this.addPosition('left');
  };

  Data.prototype.right = function right () {
    return this.addPosition('right');
  };

  Data.prototype.top = function top () {
    return this.addPosition('top');
  };

  Data.prototype.exogenous = function exogenous (value) {
    return this.setExogenous(value);
  };

  Data.prototype.endogenous = function endogenous (value) {
    return this.setEndogenous(value);
  };

  Data.prototype.prepare = function prepare (data) {
    var result = {
      data: {},
      keys: [],
      type: null
    };

    data = data.filter(this._filter);

    for (var i = 0; i < data.length; i += 1) {
      this.prepareValue(result, data[i]);
    }

    return result;
  };

  Data.prototype.prepareValue = function prepareValue () {};

  var Cumulate = /*@__PURE__*/(function (Data) {
    function Cumulate () {
      Data.apply(this, arguments);
    }

    if ( Data ) Cumulate.__proto__ = Data;
    Cumulate.prototype = Object.create( Data && Data.prototype );
    Cumulate.prototype.constructor = Cumulate;

    Cumulate.prototype.prepareValue = function prepareValue (result, datum) {
      var exogenous = this._exogenous(datum);
      var endogenous = this._endogenous(datum);

      if (typeof result.data[exogenous] === 'undefined') {
        result.data[exogenous] = [];
        result.keys[result.keys.length] = exogenous;
        result.type = 'cumulate';
      }

      var set = result.data[exogenous];
      var index = set.length;
      var previousKey = result.keys[result.keys.length - 2];
      var previous = typeof previousKey !== 'undefined' ?
        result.data[previousKey][index] : [0, 0];

      set[index] = [
        0,
        previous[1] + endogenous,
        datum
      ];

      result.size = set.length;
    };

    return Cumulate;
  }(Data));

  var Default = /*@__PURE__*/(function (Data) {
    function Default () {
      Data.apply(this, arguments);
    }

    if ( Data ) Default.__proto__ = Data;
    Default.prototype = Object.create( Data && Data.prototype );
    Default.prototype.constructor = Default;

    Default.prototype.prepareValue = function prepareValue (result, datum) {
      var exogenous = this._exogenous(datum);
      var endogenous = this._endogenous(datum);

      if (typeof result.data[exogenous] === 'undefined') {
        result.data[exogenous] = [];
        result.keys[result.keys.length] = exogenous;
        result.type = 'default';
      }

      var set = result.data[exogenous];
      var index = set.length;

      set[index] = [
        0,
        endogenous,
        datum
      ];

      result.size = set.length;
    };

    return Default;
  }(Data));

  var Group = /*@__PURE__*/(function (Data) {
    function Group(options) {
      if ( options === void 0 ) options = {};

      Data.call(this, options);

      this._index = null;
      this.setIndex(options.value);
    }

    if ( Data ) Group.__proto__ = Data;
    Group.prototype = Object.create( Data && Data.prototype );
    Group.prototype.constructor = Group;

    Group.prototype.getIndex = function getIndex () {
      return this._index;
    };

    Group.prototype.setIndex = function setIndex (value) {
      if ( value === void 0 ) value = null;

      this._index = value;
      return this;
    };

    Group.prototype.index = function index (value) {
      return this.setIndex(value);
    };

    Group.prototype.prepareValue = function prepareValue (result, datum) {
      var exogenous = this._exogenous(datum);
      var endogenous = this._endogenous(datum);

      if (typeof result.data[exogenous] === 'undefined') {
        result.data[exogenous] = [];
        result.keys[result.keys.length] = exogenous;
        result.type = 'group';
      }

      var set = result.data[exogenous];
      var index = this._index ? this._index(datum) : set.length;

      set[index] = [
        0,
        endogenous,
        datum
      ];

      result.size = set.length;
    };

    return Group;
  }(Data));

  var Stack$2 = /*@__PURE__*/(function (Data) {
    function Stack () {
      Data.apply(this, arguments);
    }

    if ( Data ) Stack.__proto__ = Data;
    Stack.prototype = Object.create( Data && Data.prototype );
    Stack.prototype.constructor = Stack;

    Stack.prototype.prepareValue = function prepareValue (result, datum) {
      var exogenous = this._exogenous(datum);
      var endogenous = this._endogenous(datum);

      if (typeof result.data[exogenous] === 'undefined') {
        result.data[exogenous] = [];
        result.keys[result.keys.length] = exogenous;
        result.type = 'stack';
      }

      var set = result.data[exogenous];
      var index = set.length;
      var previous = index > 0 ? set[index - 1] : [0, 0];

      set[index] = [
        previous[1],
        previous[1] + endogenous,
        datum
      ];

      result.size = set.length;
    };

    return Stack;
  }(Data));

  var Sum = /*@__PURE__*/(function (Data) {
    function Sum () {
      Data.apply(this, arguments);
    }

    if ( Data ) Sum.__proto__ = Data;
    Sum.prototype = Object.create( Data && Data.prototype );
    Sum.prototype.constructor = Sum;

    Sum.prototype.prepareValue = function prepareValue (result, datum) {
      var exogenous = this._exogenous(datum);
      var endogenous = this._endogenous(datum);

      if (typeof result.data[exogenous] === 'undefined') {
        result.data[exogenous] = [];
        result.keys[result.keys.length] = exogenous;
        result.type = 'sum';
      }

      var set = result.data[exogenous];
      var index = set.length;
      var previous = index > 0 ? set[index - 1] : [0, 0];

      set[0] = [
        0,
        previous[1] + endogenous,
        datum
      ];

      result.size = set.length;
    };

    return Sum;
  }(Data));



  var data = /*#__PURE__*/Object.freeze({
    Cumulate: Cumulate,
    Default: Default,
    Group: Group,
    Stack: Stack$2,
    Sum: Sum
  });

  var map$3 = Object.keys(data).reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase$1(name)] = {
        object: data[name]
      }, obj ));
  }, {});

  var Plot = /*@__PURE__*/(function (Generator) {
    function Plot(options) {
      if ( options === void 0 ) options = {};

      Generator.call(this, options);

      this._data = null;
      this.setData(options.data);

      this.class('transition');
    }

    if ( Generator ) Plot.__proto__ = Generator;
    Plot.prototype = Object.create( Generator && Generator.prototype );
    Plot.prototype.constructor = Plot;

    Plot.setup = function setup () {
      Plot.attachFactories(Plot, { map: map$3 });
    };

    Plot.prototype.getData = function getData () {
      return this._data;
    };

    Plot.prototype.setData = function setData (value) {
      if ( value === void 0 ) value = null;

      this._data = value;
      return this;
    };

    Plot.prototype.data = function data (value) {
      return this.setData(value(this));
    };

    Plot.prototype.appendTip = function appendTip (box, data, node, tip) {
      var this$1 = this;

      if (tip === null) {
        return;
      }

      node
        .on('mouseover.scola-plot', function () {
          data.target = event$1.target;
          this$1.resolveValue(box, data, tip.setParent(null));
        })
        .on('mouseout.scola-plot', function () {
          tip.remove();
        });
    };

    Plot.prototype.findScale = function findScale (type) {
      var position = this._data.getPosition();

      var ref = this._builder
        .selector(function (snippet) {
          if ((snippet instanceof Axis) === false) {
            return false;
          }

          var scale = snippet.getScale();

          return position.indexOf(scale.getPosition()) > -1 &&
            scale.getType() === type;
        })
        .resolve();
      var axis = ref[0];

      return axis.getScale();
    };

    Plot.prototype.prepare = function prepare (data) {
      return this._data.prepare(data);
    };

    Plot.prototype.removeInner = function removeInner () {
      this.removeChildren();
      this.removeAfter();
    };

    Plot.prototype.resolveBefore = function resolveBefore (box, data) {
      this.removeChildren();
      return this.resolveOuter(box, data);
    };

    return Plot;
  }(Generator));

  var Scale = function Scale(options) {
    if ( options === void 0 ) options = {};

    this._axis = null;
    this._domain = null;
    this._max = null;
    this._min = null;
    this._name = null;
    this._position = null;
    this._ppu = null;
    this._range = null;

    this.setAxis(options.axis);
    this.setDomain(options.domain);
    this.setMax(options.max);
    this.setMin(options.min);
    this.setName(options.name);
    this.setPosition(options.type);
    this.setPpu(options.ppu);
    this.setRange(options.range);
  };

  Scale.prototype.getAxis = function getAxis () {
    return this._axis;
  };

  Scale.prototype.setAxis = function setAxis (value) {
      if ( value === void 0 ) value = null;

    this._axis = value;
    return this;
  };

  Scale.prototype.getDomain = function getDomain () {
    return this._domain;
  };

  Scale.prototype.setDomain = function setDomain (value) {
      if ( value === void 0 ) value = null;

    this._domain = value;
    return this;
  };

  Scale.prototype.getMax = function getMax () {
    return this._max;
  };

  Scale.prototype.setMax = function setMax (value) {
      if ( value === void 0 ) value = 'auto';

    this._max = value;
    return this;
  };

  Scale.prototype.getMin = function getMin () {
    return this._min;
  };

  Scale.prototype.setMin = function setMin (value) {
      if ( value === void 0 ) value = 'auto';

    this._min = value;
    return this;
  };

  Scale.prototype.getName = function getName () {
    return this._name;
  };

  Scale.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = null;

    this._name = value;
    return this;
  };

  Scale.prototype.getPosition = function getPosition () {
    return this._position;
  };

  Scale.prototype.setPosition = function setPosition (value) {
      if ( value === void 0 ) value = null;

    this._position = value;
    return this;
  };

  Scale.prototype.getPpu = function getPpu () {
    return this._ppu;
  };

  Scale.prototype.setPpu = function setPpu (value) {
      if ( value === void 0 ) value = null;

    this._ppu = value;
    return this;
  };

  Scale.prototype.getRange = function getRange () {
    return this._range;
  };

  Scale.prototype.setRange = function setRange (value) {
      if ( value === void 0 ) value = null;

    this._range = value;
    return this;
  };

  Scale.prototype.getType = function getType () {
    return this._type;
  };

  Scale.prototype.setType = function setType (value) {
      if ( value === void 0 ) value = null;

    this._type = value;
    return this;
  };

  Scale.prototype.axis = function axis (value) {
    return this.setAxis(value);
  };

  Scale.prototype.bottom = function bottom () {
    return this.setPosition('bottom');
  };

  Scale.prototype.endogenous = function endogenous () {
    return this.setType('endogenous');
  };

  Scale.prototype.exogenous = function exogenous () {
    return this.setType('exogenous');
  };

  Scale.prototype.left = function left () {
    return this.setPosition('left');
  };

  Scale.prototype.max = function max (value) {
    return this.setMax(value);
  };

  Scale.prototype.min = function min (value) {
    return this.setMin(value);
  };

  Scale.prototype.position = function position (value) {
    return this.setPosition(value);
  };

  Scale.prototype.right = function right () {
    return this.setPosition('right');
  };

  Scale.prototype.top = function top () {
    return this.setPosition('top');
  };

  Scale.prototype.type = function type (value) {
    return this.setType(value);
  };

  Scale.prototype.calculateDistance = function calculateDistance () {};

  Scale.prototype.calculateTicks = function calculateTicks () {};

  Scale.prototype.mapOrientation = function mapOrientation () {
    return {
      bottom: 'x',
      left: 'y',
      right: 'y',
      top: 'x'
    } [this._position];
  };

  Scale.prototype.mapPosition = function mapPosition () {
    return {
      bottom: 'left',
      left: 'top',
      right: 'top',
      top: 'left'
    } [this._position];
  };

  Scale.prototype.mapRange = function mapRange () {
    return {
      bottom: 'width',
      left: 'height',
      right: 'height',
      top: 'width'
    } [this._position];
  };

  Scale.prototype.prepare = function prepare (data) {
    return this.prepareDomain(data);
  };

  Scale.prototype.prepareDomain = function prepareDomain (data) {
      var this$1 = this;

    this._domain = {
      keys: [],
      max: -Infinity,
      min: Infinity,
      size: 1,
      type: null
    };

    var plots = this._axis.getBuilder().selector(function (snippet) {
      return snippet instanceof Plot &&
        snippet.getData().getPosition().indexOf(this$1._position) > -1;
    }).resolve();

    var plotData = null;

    for (var i = 0; i < plots.length; i += 1) {
      plotData = plots[i].prepare(data);

      this._domain.size = plotData.size;
      this._domain.type = plotData.type;

      this.prepareDomainKeys(plotData);

      if (this._type === 'endogenous') {
        this.prepareDomainEndogenous(plotData);
      } else {
        this.prepareDomainExogenous(plotData);
      }
    }

    return this.prepareRange();
  };

  Scale.prototype.prepareDomainEndogenous = function prepareDomainEndogenous (data) {
    var key = null;
    var set = null;

    var values = [];

    for (var i = 0; i < data.keys.length; i += 1) {
      key = data.keys[i];
      set = data.data[key];

      for (var j = 0; j < set.length; j += 1) {
        values[values.length] = set[j][1];
      }
    }

    this.prepareDomainMax(values);
    this.prepareDomainMin(values);
  };

  Scale.prototype.prepareDomainExogenous = function prepareDomainExogenous () {};

  Scale.prototype.prepareDomainKeys = function prepareDomainKeys (data) {
    var key = null;

    for (var i = 0; i < data.keys.length; i += 1) {
      key = data.keys[i];

      if (this._domain.keys.indexOf(key) === -1) {
        this._domain.keys[this._domain.keys.length] = key;
      }
    }
  };

  Scale.prototype.prepareDomainMax = function prepareDomainMax (values) {
    var max = Math.max.apply(Math, [ this._domain.max ].concat( values ));
    var modifier = this.resolveValue(max, this._max);

    if (modifier === 'auto') {
      max = max < 0 ? 0 : max;
    } else if (modifier !== null) {
      max = modifier;
    }

    this._domain.max = max;
  };

  Scale.prototype.prepareDomainMin = function prepareDomainMin (values) {
    var min = Math.min.apply(Math, [ this._domain.min ].concat( values ));
    var modifier = this.resolveValue(min, this._min);

    if (modifier === 'auto') {
      min = min > 0 ? 0 : min;
    } else if (modifier !== null) {
      min = modifier;
    }

    this._domain.min = min;
  };

  Scale.prototype.prepareRange = function prepareRange () {
    var node = this._axis.node().node();
    var style = window.getComputedStyle(node);

    this._range = {
      height: this.prepareRangeFrom(
        style,
        ['height', 'padding-top', 'padding-bottom']
      ),
      width: this.prepareRangeFrom(
        style,
        ['width', 'padding-left', 'padding-right']
      )
    };

    return this.preparePpu();
  };

  Scale.prototype.prepareRangeFrom = function prepareRangeFrom (style, names) {
    return names.reduce(function (result, name) {
      var value = parseFloat(style[name]);
      return result === 0 ? value : result - value;
    }, 0);
  };

  Scale.prototype.preparePpu = function preparePpu () {
    var name = this.mapRange();

    this._ppu = this._range[name] /
      (this._domain.max - this._domain.min);

    return this;
  };

  Scale.prototype.resolveValue = function resolveValue (arg, value) {
    if (typeof value === 'function') {
      return this.resolveValue(arg, value(arg));
    }

    return value;
  };

  var Linear = /*@__PURE__*/(function (Scale) {
    function Linear(options) {
      if ( options === void 0 ) options = {};

      Scale.call(this, options);

      this._count = null;
      this._step = null;

      this.setCount(options.count);
      this.setStep(options.step);
    }

    if ( Scale ) Linear.__proto__ = Scale;
    Linear.prototype = Object.create( Scale && Scale.prototype );
    Linear.prototype.constructor = Linear;

    Linear.prototype.getCount = function getCount () {
      return this._count;
    };

    Linear.prototype.setCount = function setCount (value) {
      if ( value === void 0 ) value = null;

      this._count = value;
      return this;
    };

    Linear.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = 'linear';

      return Scale.prototype.setName.call(this, value);
    };

    Linear.prototype.getStep = function getStep () {
      return this._step;
    };

    Linear.prototype.setStep = function setStep (value) {
      if ( value === void 0 ) value = 1;

      this._step = value;
      return this;
    };

    Linear.prototype.count = function count (value) {
      return this.setCount(value);
    };

    Linear.prototype.step = function step (value) {
      return this.setStep(value);
    };

    Linear.prototype.calculateDistance = function calculateDistance (value) {
      var distance = (value - this._domain.min) * this._ppu;

      if (this.mapOrientation() === 'y') {
        distance = this._range.height - distance;
      }

      return Math.round(distance) + 0.5;
    };

    Linear.prototype.calculateTicks = function calculateTicks () {
      var count = this.resolveValue(this._domain, this._count);
      var step = this.resolveValue(this._domain, this._step);

      step = count !== null ?
        this._domain.max / (count - 1) :
        step;

      var ref = this._domain;
      var max = ref.max;
      var min = ref.min;
      var ticks = [];

      var distance = null;

      for (var value = max; value >= min; value -= step) {
        distance = this.calculateDistance(value);

        ticks[ticks.length] = [
          value,
          distance
        ];
      }

      return ticks;
    };

    Linear.prototype.prepareDomainExogenous = function prepareDomainExogenous () {
      this.prepareDomainMax(this._domain.keys);
      this.prepareDomainMin(this._domain.keys);
    };

    return Linear;
  }(Scale));

  var Ordinal = /*@__PURE__*/(function (Scale) {
    function Ordinal () {
      Scale.apply(this, arguments);
    }

    if ( Scale ) Ordinal.__proto__ = Scale;
    Ordinal.prototype = Object.create( Scale && Scale.prototype );
    Ordinal.prototype.constructor = Ordinal;

    Ordinal.prototype.setName = function setName (value) {
      if ( value === void 0 ) value = 'ordinal';

      return Scale.prototype.setName.call(this, value);
    };

    Ordinal.prototype.calculateDistance = function calculateDistance (value) {
      var distance = this._domain.keys.indexOf(value);

      distance = (distance - this._domain.min + 0.5) *
        this._ppu;

      return Math.round(distance) + 0.5;
    };

    Ordinal.prototype.calculateTicks = function calculateTicks () {
      var ticks = [];

      var distance = null;
      var key = null;

      for (var i = this._domain.keys.length - 1; i >= 0; i -= 1) {
        key = this._domain.keys[i];
        distance = this.calculateDistance(key);

        ticks[ticks.length] = [
          key,
          distance
        ];
      }

      return ticks;
    };

    Ordinal.prototype.prepareDomainExogenous = function prepareDomainExogenous () {
      this.prepareDomainMax([this._domain.keys.length]);
      this.prepareDomainMin([0]);
    };

    return Ordinal;
  }(Scale));



  var scale = /*#__PURE__*/Object.freeze({
    Linear: Linear,
    Ordinal: Ordinal
  });

  var map$4 = Object.keys(scale).reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase$1(name)] = {
        object: scale[name]
      }, obj ));
  }, {});

  var Axis = /*@__PURE__*/(function (Generator) {
    function Axis(options) {
      if ( options === void 0 ) options = {};

      Generator.call(this, options);

      this._scale = null;
      this.setScale(options.scale);

      this.class('transition');
    }

    if ( Generator ) Axis.__proto__ = Generator;
    Axis.prototype = Object.create( Generator && Generator.prototype );
    Axis.prototype.constructor = Axis;

    Axis.setup = function setup () {
      Axis.attachFactories(Axis, { map: map$4 });
    };

    Axis.prototype.getScale = function getScale () {
      return this._scale;
    };

    Axis.prototype.setScale = function setScale (value) {
      if ( value === void 0 ) value = new Linear();

      this._scale = value.setAxis(this);
      return this;
    };

    Axis.prototype.scale = function scale (value) {
      return this.setScale(value(this));
    };

    Axis.prototype.removeInner = function removeInner () {
      this.removeChildren();
      this.removeAfter();
    };

    Axis.prototype.resolveAfter = function resolveAfter () {
      this._node
        .classed(this._scale.mapOrientation(), true)
        .classed(this._scale.getName(), true)
        .classed(this._scale.getPosition(), true);

      return this._node;
    };

    Axis.prototype.resolveBefore = function resolveBefore (box, data) {
      this._scale.prepare(data);
      this.removeChildren();

      return this.resolveOuter(box, data);
    };

    Axis.prototype.resolveInner = function resolveInner (box, data) {
      var assign;

      var ref = this._args;
      var tick = ref[0];
      var ticks = this._scale.calculateTicks();

      var position = this._scale.mapPosition();

      var distance = null;
      var node = null;
      var value = null;

      for (var i = 0; i < ticks.length; i += 1) {
        (assign = ticks[i], value = assign[0], distance = assign[1]);
        node = this.appendChild(box, value, tick);
        node.style(position, Math.floor(distance) + 'px');
      }

      return this.resolveAfter(box, data);
    };

    return Axis;
  }(Generator));

  var Circle = /*@__PURE__*/(function (Plot) {
    function Circle(options) {
      if ( options === void 0 ) options = {};

      Plot.call(this, options);

      this._radius = null;
      this.setRadius(options.radius);

      this
        .name('g')
        .class('plot');
    }

    if ( Plot ) Circle.__proto__ = Plot;
    Circle.prototype = Object.create( Plot && Plot.prototype );
    Circle.prototype.constructor = Circle;

    Circle.prototype.getRadius = function getRadius () {
      return this._radius;
    };

    Circle.prototype.setRadius = function setRadius (value) {
      if ( value === void 0 ) value = 3;

      this._radius = value;
      return this;
    };

    Circle.prototype.radius = function radius (value) {
      return this.setRadius(value);
    };

    Circle.prototype.appendCircle = function appendCircle (box, key, j, set, endogenous, exogenous) {
      var ref = this._args;
      var circle = ref[0];
      var tip = ref[1];
      var ref$1 = set[j] || [0, 0, {}];
      var from = ref$1[0];
      var to = ref$1[1];
      var datum = ref$1[2];

      var data = {
        datum: datum,
        from: from,
        key: key,
        to: to
      };

      var radius = this.resolveValue(box, data, this._radius);

      var endogenousOrientation = endogenous.mapOrientation();
      var exogenousOrientation = exogenous.mapOrientation();

      var endogenousDistance = endogenous.calculateDistance(to);
      var exogenousDistance = exogenous.calculateDistance(key);

      var node = this.appendChild(box, data, circle)
        .attr('c' + endogenousOrientation, endogenousDistance)
        .attr('c' + exogenousOrientation, exogenousDistance)
        .attr('r', radius);

      this.appendTip(box, data, node, tip);
    };

    Circle.prototype.resolveInner = function resolveInner (box, data) {
      var endogenous = this.findScale('endogenous');
      var exogenous = this.findScale('exogenous');

      var key = null;
      var set = null;

      data = this.prepare(data);

      for (var i = 0; i < data.keys.length; i += 1) {
        key = data.keys[i];
        set = data.data[key];

        for (var j = 0; j < set.length; j += 1) {
          this.appendCircle(box, key, j, set, endogenous, exogenous);
        }
      }

      return this.resolveAfter(box, data);
    };

    return Circle;
  }(Plot));

  var Grid = /*@__PURE__*/(function (Generator) {
    function Grid(options) {
      Generator.call(this, options);
      this.class('transition');
    }

    if ( Generator ) Grid.__proto__ = Generator;
    Grid.prototype = Object.create( Generator && Generator.prototype );
    Grid.prototype.constructor = Grid;

    Grid.prototype.removeInner = function removeInner () {
      this.removeChildren();
      this.removeAfter();
    };

    Grid.prototype.resolveBefore = function resolveBefore (box, data) {
      this.removeChildren();
      return this.resolveOuter(box, data);
    };

    Grid.prototype.resolveInner = function resolveInner (box, data) {
      var assign;

      var ref = this._args;
      var line = ref[0];

      var axes = this._builder.selector(function (snippet) {
        return snippet instanceof Axis;
      }).resolve();

      var distance = null;
      var node = null;
      var orientation = null;
      var position = null;
      var property = null;
      var scale = null;
      var ticks = null;
      var value = null;

      for (var i = 0; i < axes.length; i += 1) {
        scale = axes[i].getScale();

        orientation = scale.mapOrientation();
        position = scale.getPosition();
        property = scale.mapPosition();
        ticks = scale.calculateTicks();

        for (var j = 0; j < ticks.length; j += 1) {
          (assign = ticks[j], value = assign[0], distance = assign[1]);
          node = this.appendChild(box, value, line);

          node
            .classed(orientation, true)
            .classed(position, true)
            .style(property, Math.floor(distance) + 'px');
        }
      }

      return this.resolveAfter(box, data);
    };

    return Grid;
  }(Generator));

  var Path = /*@__PURE__*/(function (Plot) {
    function Path(options) {
      if ( options === void 0 ) options = {};

      Plot.call(this, options);

      this._fill = null;
      this.setFill(options.fill);

      this
        .name('g')
        .class('plot');
    }

    if ( Plot ) Path.__proto__ = Plot;
    Path.prototype = Object.create( Plot && Plot.prototype );
    Path.prototype.constructor = Path;

    Path.prototype.getFill = function getFill () {
      return this._fill;
    };

    Path.prototype.setFill = function setFill (value) {
      if ( value === void 0 ) value = false;

      this._fill = value;
      return this;
    };

    Path.prototype.fill = function fill () {
      return this.setFill(true);
    };

    Path.prototype.mapIndex = function mapIndex (orientation) {
      return {
        x: 0,
        y: 1
      } [orientation];
    };

    Path.prototype.preparePath = function preparePath (box, data) {
      var endogenous = this.findScale('endogenous');
      var exogenous = this.findScale('exogenous');

      var fill = [];
      var stroke = [];

      var minSet = [
        [0, endogenous.getDomain().min]
      ];

      var key = null;
      var min = null;
      var set = null;
      var value = null;

      for (var i = 0; i < data.keys.length; i += 1) {
        key = data.keys[i];
        set = data.data[key];

        for (var j = 0; j < set.length; j += 1) {
          fill[j] = fill[j] || '';
          stroke[j] = stroke[j] || '';

          min = this.preparePoint(endogenous, exogenous, minSet, key, 0);
          value = this.preparePoint(endogenous, exogenous, set, key, j);

          if (i === 0) {
            fill[j] += 'M ' + min;
            stroke[j] += 'M ' + value;
          }

          fill[j] += ' L ' + value;
          stroke[j] += ' L ' + value;

          if (i === data.keys.length - 1) {
            fill[j] += ' L ' + min;
          }
        }
      }

      return [fill, stroke];
    };

    Path.prototype.preparePoint = function preparePoint (endogenous, exogenous, set, key, j) {
      var ref = set[j];
      var to = ref[1];

      var endogenousOrientation = endogenous.mapOrientation();
      var endogenousIndex = this.mapIndex(endogenousOrientation);

      var exogenousOrientation = exogenous.mapOrientation();
      var exogenousIndex = this.mapIndex(exogenousOrientation);

      var endogenousDistance = endogenous.calculateDistance(to);
      var exogenousDistance = exogenous.calculateDistance(key);

      var value = [];

      value[endogenousIndex] = endogenousDistance;
      value[exogenousIndex] = exogenousDistance;

      return value.join(' ');
    };

    Path.prototype.resolveInner = function resolveInner (box, data) {
      data = this.prepare(data);

      var ref = this.preparePath(box, data);
      var fill = ref[0];
      var stroke = ref[1];
      var ref$1 = this._args;
      var path = ref$1[0];

      for (var i = stroke.length - 1; i >= 0; i -= 1) {
        if (this._fill) {
          this.appendChild(box, data, path)
            .attr('d', fill[i])
            .classed('fill', true);
        }

        this.appendChild(box, data, path)
          .attr('d', stroke[i])
          .classed('stroke', true);
      }

      return this.resolveAfter(box, data);
    };

    return Path;
  }(Plot));

  var Rect = /*@__PURE__*/(function (Plot) {
    function Rect(options) {
      if ( options === void 0 ) options = {};

      Plot.call(this, options);

      this._padding = null;
      this.setPadding(options.padding);

      this
        .name('g')
        .class('plot');
    }

    if ( Plot ) Rect.__proto__ = Plot;
    Rect.prototype = Object.create( Plot && Plot.prototype );
    Rect.prototype.constructor = Rect;

    Rect.prototype.getPadding = function getPadding () {
      return this._padding;
    };

    Rect.prototype.setPadding = function setPadding (value) {
      if ( value === void 0 ) value = 0.1;

      this._padding = value;
      return this;
    };

    Rect.prototype.padding = function padding (value) {
      return this.setPadding(value);
    };

    Rect.prototype.appendRect = function appendRect (box, key, j, set, endogenous, exogenous) {
      var ref = this._args;
      var rect = ref[0];
      var tip = ref[1];
      var ref$1 = set[j] || [0, 0, {}];
      var from = ref$1[0];
      var to = ref$1[1];
      var datum = ref$1[2];

      var data = {
        datum: datum,
        from: from,
        key: key,
        to: to
      };

      var padding = this.resolveValue(box, data, this._padding);

      var endogenousRange = endogenous.mapRange();
      var endogenousOrientation = endogenous.mapOrientation();

      var begin = endogenous.calculateDistance(from);
      var end = endogenous.calculateDistance(to);

      if (begin === end) {
        end = endogenous.calculateDistance(3 / endogenous.getPpu());
      }

      var endogenousDistance = end;
      var endogenousSize = begin - end;

      if (begin < end) {
        endogenousDistance = begin;
        endogenousSize = end - begin;
      }

      var exogenousRange = exogenous.mapRange();
      var exogenousOrientation = exogenous.mapOrientation();

      var exogenousDistance = exogenous.calculateDistance(key);
      var exogenousSize = exogenous.getPpu();

      if (exogenous.getDomain().type === 'group') {
        exogenousSize /= exogenous.getDomain().size;
        exogenousDistance += j * exogenousSize;
        exogenousDistance -= exogenousSize;
      }

      exogenousDistance -= exogenousSize * 0.5;
      exogenousDistance += exogenousSize * padding;
      exogenousSize -= exogenousSize * padding * 2;

      var node = this.appendChild(box, data, rect)
        .attr(endogenousOrientation, endogenousDistance)
        .attr(endogenousRange, endogenousSize)
        .attr(exogenousOrientation, exogenousDistance)
        .attr(exogenousRange, exogenousSize)
        .classed('negative', to < 0)
        .classed('zero', to === 0);

      this.appendTip(box, data, node, tip);
    };

    Rect.prototype.resolveInner = function resolveInner (box, data) {
      var endogenous = this.findScale('endogenous');
      var exogenous = this.findScale('exogenous');

      var key = null;
      var set = null;

      data = this.prepare(data);

      for (var i = 0; i < data.keys.length; i += 1) {
        key = data.keys[i];
        set = data.data[key];

        for (var j = 0; j < set.length; j += 1) {
          this.appendRect(box, key, j, set, endogenous, exogenous);
        }
      }

      return this.resolveAfter(box, data);
    };

    return Rect;
  }(Plot));

  var Tick = /*@__PURE__*/(function (Node) {
    function Tick () {
      Node.apply(this, arguments);
    }

    if ( Node ) Tick.__proto__ = Node;
    Tick.prototype = Object.create( Node && Node.prototype );
    Tick.prototype.constructor = Tick;

    Tick.prototype.resolveAfter = function resolveAfter () {
      var text = this._node.text();

      this._node.text(null);

      this._node
        .append('div')
        .classed('text', true)
        .text(text);

      this._node
        .append('div')
        .classed('mark', true);

      return this._node;
    };

    return Tick;
  }(Node$1));



  var graph = /*#__PURE__*/Object.freeze({
    Axis: Axis,
    Circle: Circle,
    Grid: Grid,
    Path: Path,
    Plot: Plot,
    Rect: Rect,
    Tick: Tick
  });

  var Checkbox = /*@__PURE__*/(function (Input) {
    function Checkbox(options) {
      Input.call(this, options);

      this.attributes({
        type: 'checkbox'
      });
    }

    if ( Input ) Checkbox.__proto__ = Input;
    Checkbox.prototype = Object.create( Input && Input.prototype );
    Checkbox.prototype.constructor = Checkbox;

    return Checkbox;
  }(Input));

  var regexp = /^#[A-F0-9]{6}$/;

  var Color$1 = /*@__PURE__*/(function (Input) {
    function Color(options) {
      Input.call(this, options);

      this.attributes({
        type: 'color'
      });
    }

    if ( Input ) Color.__proto__ = Input;
    Color.prototype = Object.create( Input && Input.prototype );
    Color.prototype.constructor = Color;

    Color.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).trim().toUpperCase());
    };

    Color.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      if (regexp.test(value) === false) {
        return this.setError(error, name, value, 'type');
      }

      return null;
    };

    return Color;
  }(Input));

  // these aren't really private, but nor are they really useful to document

  /**
   * @private
   */
  var LuxonError = /*@__PURE__*/(function (Error) {
    function LuxonError () {
      Error.apply(this, arguments);
    }if ( Error ) LuxonError.__proto__ = Error;
    LuxonError.prototype = Object.create( Error && Error.prototype );
    LuxonError.prototype.constructor = LuxonError;

    

    return LuxonError;
  }(Error));

  /**
   * @private
   */
  var InvalidDateTimeError = /*@__PURE__*/(function (LuxonError) {
    function InvalidDateTimeError(reason) {
      LuxonError.call(this, ("Invalid DateTime: " + (reason.toMessage())));
    }

    if ( LuxonError ) InvalidDateTimeError.__proto__ = LuxonError;
    InvalidDateTimeError.prototype = Object.create( LuxonError && LuxonError.prototype );
    InvalidDateTimeError.prototype.constructor = InvalidDateTimeError;

    return InvalidDateTimeError;
  }(LuxonError));

  /**
   * @private
   */
  var InvalidIntervalError = /*@__PURE__*/(function (LuxonError) {
    function InvalidIntervalError(reason) {
      LuxonError.call(this, ("Invalid Interval: " + (reason.toMessage())));
    }

    if ( LuxonError ) InvalidIntervalError.__proto__ = LuxonError;
    InvalidIntervalError.prototype = Object.create( LuxonError && LuxonError.prototype );
    InvalidIntervalError.prototype.constructor = InvalidIntervalError;

    return InvalidIntervalError;
  }(LuxonError));

  /**
   * @private
   */
  var InvalidDurationError = /*@__PURE__*/(function (LuxonError) {
    function InvalidDurationError(reason) {
      LuxonError.call(this, ("Invalid Duration: " + (reason.toMessage())));
    }

    if ( LuxonError ) InvalidDurationError.__proto__ = LuxonError;
    InvalidDurationError.prototype = Object.create( LuxonError && LuxonError.prototype );
    InvalidDurationError.prototype.constructor = InvalidDurationError;

    return InvalidDurationError;
  }(LuxonError));

  /**
   * @private
   */
  var ConflictingSpecificationError = /*@__PURE__*/(function (LuxonError) {
    function ConflictingSpecificationError () {
      LuxonError.apply(this, arguments);
    }if ( LuxonError ) ConflictingSpecificationError.__proto__ = LuxonError;
    ConflictingSpecificationError.prototype = Object.create( LuxonError && LuxonError.prototype );
    ConflictingSpecificationError.prototype.constructor = ConflictingSpecificationError;

    

    return ConflictingSpecificationError;
  }(LuxonError));

  /**
   * @private
   */
  var InvalidUnitError = /*@__PURE__*/(function (LuxonError) {
    function InvalidUnitError(unit) {
      LuxonError.call(this, ("Invalid unit " + unit));
    }

    if ( LuxonError ) InvalidUnitError.__proto__ = LuxonError;
    InvalidUnitError.prototype = Object.create( LuxonError && LuxonError.prototype );
    InvalidUnitError.prototype.constructor = InvalidUnitError;

    return InvalidUnitError;
  }(LuxonError));

  /**
   * @private
   */
  var InvalidArgumentError = /*@__PURE__*/(function (LuxonError) {
    function InvalidArgumentError () {
      LuxonError.apply(this, arguments);
    }if ( LuxonError ) InvalidArgumentError.__proto__ = LuxonError;
    InvalidArgumentError.prototype = Object.create( LuxonError && LuxonError.prototype );
    InvalidArgumentError.prototype.constructor = InvalidArgumentError;

    

    return InvalidArgumentError;
  }(LuxonError));

  /**
   * @private
   */
  var ZoneIsAbstractError = /*@__PURE__*/(function (LuxonError) {
    function ZoneIsAbstractError() {
      LuxonError.call(this, "Zone is an abstract class");
    }

    if ( LuxonError ) ZoneIsAbstractError.__proto__ = LuxonError;
    ZoneIsAbstractError.prototype = Object.create( LuxonError && LuxonError.prototype );
    ZoneIsAbstractError.prototype.constructor = ZoneIsAbstractError;

    return ZoneIsAbstractError;
  }(LuxonError));

  /*
    This is just a junk drawer, containing anything used across multiple classes.
    Because Luxon is small(ish), this should stay small and we won't worry about splitting
    it up into, say, parsingUtil.js and basicUtil.js and so on. But they are divided up by feature area.
  */

  /**
   * @private
   */

  // TYPES

  function isUndefined(o) {
    return typeof o === "undefined";
  }

  function isNumber(o) {
    return typeof o === "number";
  }

  function isString(o) {
    return typeof o === "string";
  }

  function isDate(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  }

  // CAPABILITIES

  function hasIntl() {
    try {
      return typeof Intl !== "undefined" && Intl.DateTimeFormat;
    } catch (e) {
      return false;
    }
  }

  function hasFormatToParts() {
    return !isUndefined(Intl.DateTimeFormat.prototype.formatToParts);
  }

  function hasRelative() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e) {
      return false;
    }
  }

  // OBJECTS AND ARRAYS

  function maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }

  function bestBy(arr, by, compare) {
    if (arr.length === 0) {
      return undefined;
    }
    return arr.reduce(function (best, next) {
      var pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  }

  function pick(obj, keys) {
    return keys.reduce(function (a, k) {
      a[k] = obj[k];
      return a;
    }, {});
  }

  // NUMBERS AND STRINGS

  function numberBetween(thing, bottom, top) {
    return isNumber(thing) && thing >= bottom && thing <= top;
  }

  // x % n but takes the sign of n instead of x
  function floorMod(x, n) {
    return x - n * Math.floor(x / n);
  }

  function padStart(input, n) {
    if ( n === void 0 ) n = 2;

    if (input.toString().length < n) {
      return ("0".repeat(n) + input).slice(-n);
    } else {
      return input.toString();
    }
  }

  function parseInteger$1(string) {
    if (isUndefined(string) || string === null || string === "") {
      return undefined;
    } else {
      return parseInt(string, 10);
    }
  }

  function parseMillis(fraction) {
    // Return undefined (instead of 0) in these cases, where fraction is not set
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return undefined;
    } else {
      var f = parseFloat("0." + fraction) * 1000;
      return Math.floor(f);
    }
  }

  function roundTo(number, digits, towardZero) {
    if ( towardZero === void 0 ) towardZero = false;

    var factor = Math.pow( 10, digits ),
      rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number * factor) / factor;
  }

  // DATE BASICS

  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }

  function daysInMonth(year, month) {
    var modMonth = floorMod(month - 1, 12) + 1,
      modYear = year + (month - modMonth) / 12;

    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  }

  // covert a calendar object to a local timestamp (epoch, but with the offset baked in)
  function objToLocalTS(obj) {
    var d = Date.UTC(
      obj.year,
      obj.month - 1,
      obj.day,
      obj.hour,
      obj.minute,
      obj.second,
      obj.millisecond
    );

    // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that
    if (obj.year < 100 && obj.year >= 0) {
      d = new Date(d);
      d.setUTCFullYear(d.getUTCFullYear() - 1900);
    }
    return +d;
  }

  function weeksInWeekYear(weekYear) {
    var p1 =
        (weekYear +
          Math.floor(weekYear / 4) -
          Math.floor(weekYear / 100) +
          Math.floor(weekYear / 400)) %
        7,
      last = weekYear - 1,
      p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
    return p1 === 4 || p2 === 3 ? 53 : 52;
  }

  function untruncateYear(year) {
    if (year > 99) {
      return year;
    } else { return year > 60 ? 1900 + year : 2000 + year; }
  }

  // PARSING

  function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
    if ( timeZone === void 0 ) timeZone = null;

    var date = new Date(ts),
      intlOpts = {
        hour12: false,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };

    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }

    var modified = Object.assign({ timeZoneName: offsetFormat }, intlOpts),
      intl = hasIntl();

    if (intl && hasFormatToParts()) {
      var parsed = new Intl.DateTimeFormat(locale, modified)
        .formatToParts(date)
        .find(function (m) { return m.type.toLowerCase() === "timezonename"; });
      return parsed ? parsed.value : null;
    } else if (intl) {
      // this probably doesn't work for all locales
      var without = new Intl.DateTimeFormat(locale, intlOpts).format(date),
        included = new Intl.DateTimeFormat(locale, modified).format(date),
        diffed = included.substring(without.length),
        trimmed = diffed.replace(/^[, \u200e]+/, "");
      return trimmed;
    } else {
      return null;
    }
  }

  // signedOffset('-5', '30') -> -330
  function signedOffset(offHourStr, offMinuteStr) {
    var offHour = parseInt(offHourStr, 10) || 0,
      offMin = parseInt(offMinuteStr, 10) || 0,
      offMinSigned = offHour < 0 ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }

  // COERCION

  function asNumber(value) {
    var numericValue = Number(value);
    if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
      { throw new InvalidArgumentError(("Invalid unit value " + value)); }
    return numericValue;
  }

  function normalizeObject(obj, normalizer, nonUnitKeys) {
    var normalized = {};
    for (var u in obj) {
      if (obj.hasOwnProperty(u)) {
        if (nonUnitKeys.indexOf(u) >= 0) { continue; }
        var v = obj[u];
        if (v === undefined || v === null) { continue; }
        normalized[normalizer(u)] = asNumber(v);
      }
    }
    return normalized;
  }

  function formatOffset(offset, format) {
    var hours = Math.trunc(offset / 60),
      minutes = Math.abs(offset % 60),
      sign = hours >= 0 ? "+" : "-",
      base = "" + sign + (Math.abs(hours));

    switch (format) {
      case "short":
        return ("" + sign + (padStart(Math.abs(hours), 2)) + ":" + (padStart(minutes, 2)));
      case "narrow":
        return minutes > 0 ? (base + ":" + minutes) : base;
      case "techie":
        return ("" + sign + (padStart(Math.abs(hours), 2)) + (padStart(minutes, 2)));
      default:
        throw new RangeError(("Value format " + format + " is out of range for property format"));
    }
  }

  function timeObject(obj) {
    return pick(obj, ["hour", "minute", "second", "millisecond"]);
  }

  var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z_+-]{1,256}(\/[A-Za-z_+-]{1,256})?)?/;

  /**
   * @private
   */

  var n = "numeric",
    s = "short",
    l = "long",
    d2 = "2-digit";

  var DATE_SHORT = {
    year: n,
    month: n,
    day: n
  };

  var DATE_MED = {
    year: n,
    month: s,
    day: n
  };

  var DATE_FULL = {
    year: n,
    month: l,
    day: n
  };

  var DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
  };

  var TIME_SIMPLE = {
    hour: n,
    minute: d2
  };

  var TIME_WITH_SECONDS = {
    hour: n,
    minute: d2,
    second: d2
  };

  var TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: d2,
    second: d2,
    timeZoneName: s
  };

  var TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: d2,
    second: d2,
    timeZoneName: l
  };

  var TIME_24_SIMPLE = {
    hour: n,
    minute: d2,
    hour12: false
  };

  /**
   * {@link toLocaleString}; format like '09:30:23', always 24-hour.
   */
  var TIME_24_WITH_SECONDS = {
    hour: n,
    minute: d2,
    second: d2,
    hour12: false
  };

  /**
   * {@link toLocaleString}; format like '09:30:23 EDT', always 24-hour.
   */
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: d2,
    second: d2,
    hour12: false,
    timeZoneName: s
  };

  /**
   * {@link toLocaleString}; format like '09:30:23 Eastern Daylight Time', always 24-hour.
   */
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: d2,
    second: d2,
    hour12: false,
    timeZoneName: l
  };

  /**
   * {@link toLocaleString}; format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   */
  var DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: d2
  };

  /**
   * {@link toLocaleString}; format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   */
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: d2,
    second: d2
  };

  var DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: d2
  };

  var DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: d2,
    second: d2
  };

  var DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: d2
  };

  var DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: d2,
    timeZoneName: s
  };

  var DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: d2,
    second: d2,
    timeZoneName: s
  };

  var DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: d2,
    timeZoneName: l
  };

  var DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: d2,
    second: d2,
    timeZoneName: l
  };

  function stringify$1(obj) {
    return JSON.stringify(obj, Object.keys(obj).sort());
  }

  /**
   * @private
   */

  var monthsLong = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];

  var monthsShort = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];

  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

  function months(length) {
    switch (length) {
      case "narrow":
        return monthsNarrow;
      case "short":
        return monthsShort;
      case "long":
        return monthsLong;
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }

  var weekdaysLong = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday"
  ];

  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];

  function weekdays(length) {
    switch (length) {
      case "narrow":
        return weekdaysNarrow;
      case "short":
        return weekdaysShort;
      case "long":
        return weekdaysLong;
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }

  var meridiems = ["AM", "PM"];

  var erasLong = ["Before Christ", "Anno Domini"];

  var erasShort = ["BC", "AD"];

  var erasNarrow = ["B", "A"];

  function eras(length) {
    switch (length) {
      case "narrow":
        return erasNarrow;
      case "short":
        return erasShort;
      case "long":
        return erasLong;
      default:
        return null;
    }
  }

  function meridiemForDateTime(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  }

  function weekdayForDateTime(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  }

  function monthForDateTime(dt, length) {
    return months(length)[dt.month - 1];
  }

  function eraForDateTime(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  }

  function formatRelativeTime(unit, count, numeric, narrow) {
    if ( numeric === void 0 ) numeric = "always";
    if ( narrow === void 0 ) narrow = false;

    var units = {
      years: ["year", "yr."],
      quarters: ["quarer", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };

    var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

    if (numeric === "auto" && lastable) {
      var isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : ("next " + (units[unit][0]));
        case -1:
          return isDay ? "yesterday" : ("last " + (units[unit][0]));
        case 0:
          return isDay ? "today" : ("this " + (units[unit][0]));
        default: // fall through
      }
    }

    var isInPast = Object.is(count, -0) || count < 0,
      fmtValue = Math.abs(count),
      fmtUnit = narrow ? units[unit][1] : fmtValue === 1 ? units[unit][0] : unit;
    return isInPast ? (fmtValue + " " + fmtUnit + " ago") : ("in " + fmtValue + " " + fmtUnit);
  }

  function formatString(knownFormat) {
    // these all have the offsets removed because we don't have access to them
    // without all the intl stuff this is backfilling
    var filtered = pick(knownFormat, [
        "weekday",
        "era",
        "year",
        "month",
        "day",
        "hour",
        "minute",
        "second",
        "timeZoneName",
        "hour12"
      ]),
      key = stringify$1(filtered),
      dateTimeHuge = "EEEE, LLLL d, yyyy, h:mm a";
    switch (key) {
      case stringify$1(DATE_SHORT):
        return "M/d/yyyy";
      case stringify$1(DATE_MED):
        return "LLL d, yyyy";
      case stringify$1(DATE_FULL):
        return "LLLL d, yyyy";
      case stringify$1(DATE_HUGE):
        return "EEEE, LLLL d, yyyy";
      case stringify$1(TIME_SIMPLE):
        return "h:mm a";
      case stringify$1(TIME_WITH_SECONDS):
        return "h:mm:ss a";
      case stringify$1(TIME_WITH_SHORT_OFFSET):
        return "h:mm a";
      case stringify$1(TIME_WITH_LONG_OFFSET):
        return "h:mm a";
      case stringify$1(TIME_24_SIMPLE):
        return "HH:mm";
      case stringify$1(TIME_24_WITH_SECONDS):
        return "HH:mm:ss";
      case stringify$1(TIME_24_WITH_SHORT_OFFSET):
        return "HH:mm";
      case stringify$1(TIME_24_WITH_LONG_OFFSET):
        return "HH:mm";
      case stringify$1(DATETIME_SHORT):
        return "M/d/yyyy, h:mm a";
      case stringify$1(DATETIME_MED):
        return "LLL d, yyyy, h:mm a";
      case stringify$1(DATETIME_FULL):
        return "LLLL d, yyyy, h:mm a";
      case stringify$1(DATETIME_HUGE):
        return dateTimeHuge;
      case stringify$1(DATETIME_SHORT_WITH_SECONDS):
        return "M/d/yyyy, h:mm:ss a";
      case stringify$1(DATETIME_MED_WITH_SECONDS):
        return "LLL d, yyyy, h:mm:ss a";
      case stringify$1(DATETIME_MED_WITH_WEEKDAY):
        return "EEE, d LLL yyyy, h:mm a";
      case stringify$1(DATETIME_FULL_WITH_SECONDS):
        return "LLLL d, yyyy, h:mm:ss a";
      case stringify$1(DATETIME_HUGE_WITH_SECONDS):
        return "EEEE, LLLL d, yyyy, h:mm:ss a";
      default:
        return dateTimeHuge;
    }
  }

  /* eslint no-unused-vars: "off" */

  /**
   * @interface
   */
  var Zone = function Zone () {};

  var prototypeAccessors = { type: { configurable: true },name: { configurable: true },universal: { configurable: true },isValid: { configurable: true } };

  prototypeAccessors.type.get = function () {
    throw new ZoneIsAbstractError();
  };

  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  prototypeAccessors.name.get = function () {
    throw new ZoneIsAbstractError();
  };

  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  prototypeAccessors.universal.get = function () {
    throw new ZoneIsAbstractError();
  };

  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  Zone.prototype.offsetName = function offsetName (ts, opts) {
    throw new ZoneIsAbstractError();
  };

  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                        Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  Zone.prototype.formatOffset = function formatOffset (ts, format) {
    throw new ZoneIsAbstractError();
  };

  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  Zone.prototype.offset = function offset (ts) {
    throw new ZoneIsAbstractError();
  };

  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  Zone.prototype.equals = function equals (otherZone) {
    throw new ZoneIsAbstractError();
  };

  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  prototypeAccessors.isValid.get = function () {
    throw new ZoneIsAbstractError();
  };

  Object.defineProperties( Zone.prototype, prototypeAccessors );

  var singleton = null;

  /**
   * Represents the local zone for this Javascript environment.
   * @implements {Zone}
   */
  var LocalZone = /*@__PURE__*/(function (Zone) {
    function LocalZone () {
      Zone.apply(this, arguments);
    }

    if ( Zone ) LocalZone.__proto__ = Zone;
    LocalZone.prototype = Object.create( Zone && Zone.prototype );
    LocalZone.prototype.constructor = LocalZone;

    var prototypeAccessors = { type: { configurable: true },name: { configurable: true },universal: { configurable: true },isValid: { configurable: true } };
    var staticAccessors = { instance: { configurable: true } };

    staticAccessors.instance.get = function () {
      if (singleton === null) {
        singleton = new LocalZone();
      }
      return singleton;
    };

    /** @override **/
    prototypeAccessors.type.get = function () {
      return "local";
    };

    /** @override **/
    prototypeAccessors.name.get = function () {
      if (hasIntl()) {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      } else { return "local"; }
    };

    /** @override **/
    prototypeAccessors.universal.get = function () {
      return false;
    };

    /** @override **/
    LocalZone.prototype.offsetName = function offsetName (ts, ref) {
      var format = ref.format;
      var locale = ref.locale;

      return parseZoneInfo(ts, format, locale);
    };

    /** @override **/
    LocalZone.prototype.formatOffset = function formatOffset$1 (ts, format) {
      return formatOffset(this.offset(ts), format);
    };

    /** @override **/
    LocalZone.prototype.offset = function offset (ts) {
      return -new Date(ts).getTimezoneOffset();
    };

    /** @override **/
    LocalZone.prototype.equals = function equals (otherZone) {
      return otherZone.type === "local";
    };

    /** @override **/
    prototypeAccessors.isValid.get = function () {
      return true;
    };

    Object.defineProperties( LocalZone.prototype, prototypeAccessors );
    Object.defineProperties( LocalZone, staticAccessors );

    return LocalZone;
  }(Zone));

  var matchingRegex = RegExp(("^" + (ianaRegex.source) + "$"));

  var dtfCache = {};
  function makeDTF(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    }
    return dtfCache[zone];
  }

  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
  };

  function hackyOffset(dtf, date) {
    var formatted = dtf.format(date).replace(/\u200E/g, ""),
      parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
    var fMonth = parsed[1];
    var fDay = parsed[2];
    var fYear = parsed[3];
    var fHour = parsed[4];
    var fMinute = parsed[5];
    var fSecond = parsed[6];
    return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
  }

  function partsOffset(dtf, date) {
    var formatted = dtf.formatToParts(date),
      filled = [];
    for (var i = 0; i < formatted.length; i++) {
      var ref = formatted[i];
      var type = ref.type;
      var value = ref.value;
      var pos = typeToPos[type];

      if (!isUndefined(pos)) {
        filled[pos] = parseInt(value, 10);
      }
    }
    return filled;
  }

  var ianaZoneCache = {};
  /**
   * A zone identified by an IANA identifier, like America/New_York
   * @implements {Zone}
   */
  var IANAZone = /*@__PURE__*/(function (Zone) {
    function IANAZone(name) {
      Zone.call(this);
      /** @private **/
      this.zoneName = name;
      /** @private **/
      this.valid = IANAZone.isValidZone(name);
    }

    if ( Zone ) IANAZone.__proto__ = Zone;
    IANAZone.prototype = Object.create( Zone && Zone.prototype );
    IANAZone.prototype.constructor = IANAZone;

    var prototypeAccessors = { type: { configurable: true },name: { configurable: true },universal: { configurable: true },isValid: { configurable: true } };

    /** @override **/
    IANAZone.create = function create (name) {
      if (!ianaZoneCache[name]) {
        ianaZoneCache[name] = new IANAZone(name);
      }
      return ianaZoneCache[name];
    };
    /**
     * Reset local caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    IANAZone.resetCache = function resetCache () {
      ianaZoneCache = {};
      dtfCache = {};
    };
    /**
     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
     * @param {string} s - The string to check validity on
     * @example IANAZone.isValidSpecifier("America/New_York") //=> true
     * @example IANAZone.isValidSpecifier("Fantasia/Castle") //=> true
     * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
     * @return {boolean}
     */
    IANAZone.isValidSpecifier = function isValidSpecifier (s) {
      return !!(s && s.match(matchingRegex));
    };

    /**
     * Returns whether the provided string identifies a real zone
     * @param {string} zone - The string to check
     * @example IANAZone.isValidZone("America/New_York") //=> true
     * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
     * @example IANAZone.isValidZone("Sport~~blorp") //=> false
     * @return {boolean}
     */
    IANAZone.isValidZone = function isValidZone (zone) {
      try {
        new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
        return true;
      } catch (e) {
        return false;
      }
    };

    // Etc/GMT+8 -> -480
    /** @ignore */
    IANAZone.parseGMTOffset = function parseGMTOffset (specifier) {
      if (specifier) {
        var match = specifier.match(/^Etc\/GMT([+-]\d{1,2})$/i);
        if (match) {
          return -60 * parseInt(match[1]);
        }
      }
      return null;
    };

    prototypeAccessors.type.get = function () {
      return "iana";
    };

    /** @override **/
    prototypeAccessors.name.get = function () {
      return this.zoneName;
    };

    /** @override **/
    prototypeAccessors.universal.get = function () {
      return false;
    };

    /** @override **/
    IANAZone.prototype.offsetName = function offsetName (ts, ref) {
      var format = ref.format;
      var locale = ref.locale;

      return parseZoneInfo(ts, format, locale, this.name);
    };

    /** @override **/
    IANAZone.prototype.formatOffset = function formatOffset$1 (ts, format) {
      return formatOffset(this.offset(ts), format);
    };

    /** @override **/
    IANAZone.prototype.offset = function offset (ts) {
      var date = new Date(ts),
        dtf = makeDTF(this.name);
      var ref = dtf.formatToParts
          ? partsOffset(dtf, date)
          : hackyOffset(dtf, date);
      var year = ref[0];
      var month = ref[1];
      var day = ref[2];
      var hour = ref[3];
      var minute = ref[4];
      var second = ref[5];
      var asUTC = objToLocalTS({ year: year, month: month, day: day, hour: hour, minute: minute, second: second, millisecond: 0 });
      var asTS = date.valueOf();
      asTS -= asTS % 1000;
      return (asUTC - asTS) / (60 * 1000);
    };

    /** @override **/
    IANAZone.prototype.equals = function equals (otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    };

    /** @override **/
    prototypeAccessors.isValid.get = function () {
      return this.valid;
    };

    Object.defineProperties( IANAZone.prototype, prototypeAccessors );

    return IANAZone;
  }(Zone));

  var singleton$1 = null;

  /**
   * A zone with a fixed offset (i.e. no DST)
   * @implements {Zone}
   */
  var FixedOffsetZone = /*@__PURE__*/(function (Zone) {
    function FixedOffsetZone(offset) {
      Zone.call(this);
      /** @private **/
      this.fixed = offset;
    }

    if ( Zone ) FixedOffsetZone.__proto__ = Zone;
    FixedOffsetZone.prototype = Object.create( Zone && Zone.prototype );
    FixedOffsetZone.prototype.constructor = FixedOffsetZone;

    var prototypeAccessors = { type: { configurable: true },name: { configurable: true },universal: { configurable: true },isValid: { configurable: true } };
    var staticAccessors = { utcInstance: { configurable: true } };

    /** @override **/
    staticAccessors.utcInstance.get = function () {
      if (singleton$1 === null) {
        singleton$1 = new FixedOffsetZone(0);
      }
      return singleton$1;
    };

    /**
     * Get an instance with a specified offset
     * @param {number} offset - The offset in minutes
     * @return {FixedOffsetZone}
     */
    FixedOffsetZone.instance = function instance (offset) {
      return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
    };

    /**
     * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
     * @param {string} s - The offset string to parse
     * @example FixedOffsetZone.parseSpecifier("UTC+6")
     * @example FixedOffsetZone.parseSpecifier("UTC+06")
     * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
     * @return {FixedOffsetZone}
     */
    FixedOffsetZone.parseSpecifier = function parseSpecifier (s) {
      if (s) {
        var r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    };

    prototypeAccessors.type.get = function () {
      return "fixed";
    };

    /** @override **/
    prototypeAccessors.name.get = function () {
      return this.fixed === 0 ? "UTC" : ("UTC" + (formatOffset(this.fixed, "narrow")));
    };

    /** @override **/
    FixedOffsetZone.prototype.offsetName = function offsetName () {
      return this.name;
    };

    /** @override **/
    FixedOffsetZone.prototype.formatOffset = function formatOffset$1 (ts, format) {
      return formatOffset(this.fixed, format);
    };

    /** @override **/
    prototypeAccessors.universal.get = function () {
      return true;
    };

    /** @override **/
    FixedOffsetZone.prototype.offset = function offset () {
      return this.fixed;
    };

    /** @override **/
    FixedOffsetZone.prototype.equals = function equals (otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    };

    /** @override **/
    prototypeAccessors.isValid.get = function () {
      return true;
    };

    Object.defineProperties( FixedOffsetZone.prototype, prototypeAccessors );
    Object.defineProperties( FixedOffsetZone, staticAccessors );

    return FixedOffsetZone;
  }(Zone));

  /**
   * A zone that failed to parse. You should never need to instantiate this.
   * @implements {Zone}
   */
  var InvalidZone = /*@__PURE__*/(function (Zone) {
    function InvalidZone(zoneName) {
      Zone.call(this);
      /**  @private */
      this.zoneName = zoneName;
    }

    if ( Zone ) InvalidZone.__proto__ = Zone;
    InvalidZone.prototype = Object.create( Zone && Zone.prototype );
    InvalidZone.prototype.constructor = InvalidZone;

    var prototypeAccessors = { type: { configurable: true },name: { configurable: true },universal: { configurable: true },isValid: { configurable: true } };

    /** @override **/
    prototypeAccessors.type.get = function () {
      return "invalid";
    };

    /** @override **/
    prototypeAccessors.name.get = function () {
      return this.zoneName;
    };

    /** @override **/
    prototypeAccessors.universal.get = function () {
      return false;
    };

    /** @override **/
    InvalidZone.prototype.offsetName = function offsetName () {
      return null;
    };

    /** @override **/
    InvalidZone.prototype.formatOffset = function formatOffset () {
      return "";
    };

    /** @override **/
    InvalidZone.prototype.offset = function offset () {
      return NaN;
    };

    /** @override **/
    InvalidZone.prototype.equals = function equals () {
      return false;
    };

    /** @override **/
    prototypeAccessors.isValid.get = function () {
      return false;
    };

    Object.defineProperties( InvalidZone.prototype, prototypeAccessors );

    return InvalidZone;
  }(Zone));

  /**
   * @private
   */

  function normalizeZone(input, defaultZone) {
    var offset;
    if (isUndefined(input) || input === null) {
      return defaultZone;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString(input)) {
      var lowered = input.toLowerCase();
      if (lowered === "local") { return defaultZone; }
      else if (lowered === "utc" || lowered === "gmt") { return FixedOffsetZone.utcInstance; }
      else if ((offset = IANAZone.parseGMTOffset(input)) != null) {
        // handle Etc/GMT-4, which V8 chokes on
        return FixedOffsetZone.instance(offset);
      } else if (IANAZone.isValidSpecifier(lowered)) { return IANAZone.create(input); }
      else { return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input); }
    } else if (isNumber(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
      // This is dumb, but the instanceof check above doesn't seem to really work
      // so we're duck checking it
      return input;
    } else {
      return new InvalidZone(input);
    }
  }

  var now$2 = function () { return Date.now(); },
    defaultZone = null, // not setting this directly to LocalZone.instance bc loading order issues
    defaultLocale$2 = null,
    defaultNumberingSystem = null,
    defaultOutputCalendar = null,
    throwOnInvalid = false;

  /**
   * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
   */
  var Settings = function Settings () {};

  var staticAccessors = { now: { configurable: true },defaultZoneName: { configurable: true },defaultZone: { configurable: true },defaultLocale: { configurable: true },defaultNumberingSystem: { configurable: true },defaultOutputCalendar: { configurable: true },throwOnInvalid: { configurable: true } };

  staticAccessors.now.get = function () {
    return now$2;
  };

  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  staticAccessors.now.set = function (n) {
    now$2 = n;
  };

  /**
   * Get the default time zone to create DateTimes in.
   * @type {string}
   */
  staticAccessors.defaultZoneName.get = function () {
    return Settings.defaultZone.name;
  };

  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * @type {string}
   */
  staticAccessors.defaultZoneName.set = function (z) {
    if (!z) {
      defaultZone = null;
    } else {
      defaultZone = normalizeZone(z);
    }
  };

  /**
   * Get the default time zone object to create DateTimes in. Does not affect existing instances.
   * @type {Zone}
   */
  staticAccessors.defaultZone.get = function () {
    return defaultZone || LocalZone.instance;
  };

  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  staticAccessors.defaultLocale.get = function () {
    return defaultLocale$2;
  };

  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  staticAccessors.defaultLocale.set = function (locale) {
    defaultLocale$2 = locale;
  };

  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  staticAccessors.defaultNumberingSystem.get = function () {
    return defaultNumberingSystem;
  };

  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  staticAccessors.defaultNumberingSystem.set = function (numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  };

  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  staticAccessors.defaultOutputCalendar.get = function () {
    return defaultOutputCalendar;
  };

  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  staticAccessors.defaultOutputCalendar.set = function (outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  };

  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  staticAccessors.throwOnInvalid.get = function () {
    return throwOnInvalid;
  };

  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  staticAccessors.throwOnInvalid.set = function (t) {
    throwOnInvalid = t;
  };

  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  Settings.resetCaches = function resetCaches () {
    Locale.resetCache();
    IANAZone.resetCache();
  };

  Object.defineProperties( Settings, staticAccessors );

  function stringifyTokens(splits, tokenToString) {
    var s = "";
    for (var i = 0, list = splits; i < list.length; i += 1) {
      var token = list[i];

      if (token.literal) {
        s += token.val;
      } else {
        s += tokenToString(token.val);
      }
    }
    return s;
  }

  var tokenToObject = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };

  /**
   * @private
   */

  var Formatter = function Formatter(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  };

  Formatter.create = function create (locale, opts) {
      if ( opts === void 0 ) opts = {};

    return new Formatter(locale, opts);
  };

  Formatter.parseFormat = function parseFormat (fmt) {
    var current = null,
      currentFull = "",
      bracketed = false;
    var splits = [];
    for (var i = 0; i < fmt.length; i++) {
      var c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed, val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: false, val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }

    if (currentFull.length > 0) {
      splits.push({ literal: bracketed, val: currentFull });
    }

    return splits;
  };

  Formatter.prototype.formatWithSystemDefault = function formatWithSystemDefault (dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    var df = this.systemLoc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  };

  Formatter.prototype.formatDateTime = function formatDateTime (dt, opts) {
      if ( opts === void 0 ) opts = {};

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.format();
  };

  Formatter.prototype.formatDateTimeParts = function formatDateTimeParts (dt, opts) {
      if ( opts === void 0 ) opts = {};

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.formatToParts();
  };

  Formatter.prototype.resolvedOptions = function resolvedOptions (dt, opts) {
      if ( opts === void 0 ) opts = {};

    var df = this.loc.dtFormatter(dt, Object.assign({}, this.opts, opts));
    return df.resolvedOptions();
  };

  Formatter.prototype.num = function num (n, p) {
      if ( p === void 0 ) p = 0;

    // we get some perf out of doing this here, annoyingly
    if (this.opts.forceSimple) {
      return padStart(n, p);
    }

    var opts = Object.assign({}, this.opts);

    if (p > 0) {
      opts.padTo = p;
    }

    return this.loc.numberFormatter(opts).format(n);
  };

  Formatter.prototype.formatDateTimeFromString = function formatDateTimeFromString (dt, fmt) {
      var this$1 = this;

    var knownEnglish = this.loc.listingMode() === "en";
    var string = function (opts, extract) { return this$1.loc.extract(dt, opts, extract); },
      formatOffset = function (opts) {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }

        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      },
      meridiem = function () { return knownEnglish
          ? meridiemForDateTime(dt)
          : string({ hour: "numeric", hour12: true }, "dayperiod"); },
      month = function (length, standalone) { return knownEnglish
          ? monthForDateTime(dt, length)
          : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"); },
      weekday = function (length, standalone) { return knownEnglish
          ? weekdayForDateTime(dt, length)
          : string(
              standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
              "weekday"
            ); },
      maybeMacro = function (token) {
        var macro = tokenToObject[token];
        if (macro) {
          return this$1.formatWithSystemDefault(dt, macro);
        } else {
          return token;
        }
      },
      era = function (length) { return knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"); },
      tokenToString = function (token) {
        var outputCal = this$1.loc.outputCalendar;

        // Where possible: http://cldr.unicode.org/translation/date-time#TOC-Stand-Alone-vs.-Format-Styles
        switch (token) {
          // ms
          case "S":
            return this$1.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this$1.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this$1.num(dt.second);
          case "ss":
            return this$1.num(dt.second, 2);
          // minutes
          case "m":
            return this$1.num(dt.minute);
          case "mm":
            return this$1.num(dt.minute, 2);
          // hours
          case "h":
            return this$1.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this$1.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this$1.num(dt.hour);
          case "HH":
            return this$1.num(dt.hour, 2);
          // offset
          case "Z":
            // like +6
            return formatOffset({ format: "narrow", allowZ: this$1.opts.allowZ });
          case "ZZ":
            // like +06:00
            return formatOffset({ format: "short", allowZ: this$1.opts.allowZ });
          case "ZZZ":
            // like +0600
            return formatOffset({ format: "techie", allowZ: false });
          case "ZZZZ":
            // like EST
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this$1.loc.locale });
          case "ZZZZZ":
            // like Eastern Standard Time
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this$1.loc.locale });
          // zone
          case "z":
            // like America/New_York
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return outputCal ? string({ day: "numeric" }, "day") : this$1.num(dt.day);
          case "dd":
            return outputCal ? string({ day: "2-digit" }, "day") : this$1.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            // like 1
            return this$1.num(dt.weekday);
          case "ccc":
            // like 'Tues'
            return weekday("short", true);
          case "cccc":
            // like 'Tuesday'
            return weekday("long", true);
          case "ccccc":
            // like 'T'
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            // like 1
            return this$1.num(dt.weekday);
          case "EEE":
            // like 'Tues'
            return weekday("short", false);
          case "EEEE":
            // like 'Tuesday'
            return weekday("long", false);
          case "EEEEE":
            // like 'T'
            return weekday("narrow", false);
          // months - standalone
          case "L":
            // like 1
            return outputCal
              ? string({ month: "numeric", day: "numeric" }, "month")
              : this$1.num(dt.month);
          case "LL":
            // like 01, doesn't seem to work
            return outputCal
              ? string({ month: "2-digit", day: "numeric" }, "month")
              : this$1.num(dt.month, 2);
          case "LLL":
            // like Jan
            return month("short", true);
          case "LLLL":
            // like January
            return month("long", true);
          case "LLLLL":
            // like J
            return month("narrow", true);
          // months - format
          case "M":
            // like 1
            return outputCal ? string({ month: "numeric" }, "month") : this$1.num(dt.month);
          case "MM":
            // like 01
            return outputCal ? string({ month: "2-digit" }, "month") : this$1.num(dt.month, 2);
          case "MMM":
            // like Jan
            return month("short", false);
          case "MMMM":
            // like January
            return month("long", false);
          case "MMMMM":
            // like J
            return month("narrow", false);
          // years
          case "y":
            // like 2014
            return outputCal ? string({ year: "numeric" }, "year") : this$1.num(dt.year);
          case "yy":
            // like 14
            return outputCal
              ? string({ year: "2-digit" }, "year")
              : this$1.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            // like 0012
            return outputCal ? string({ year: "numeric" }, "year") : this$1.num(dt.year, 4);
          case "yyyyyy":
            // like 000012
            return outputCal ? string({ year: "numeric" }, "year") : this$1.num(dt.year, 6);
          // eras
          case "G":
            // like AD
            return era("short");
          case "GG":
            // like Anno Domini
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this$1.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this$1.num(dt.weekYear, 4);
          case "W":
            return this$1.num(dt.weekNumber);
          case "WW":
            return this$1.num(dt.weekNumber, 2);
          case "o":
            return this$1.num(dt.ordinal);
          case "ooo":
            return this$1.num(dt.ordinal, 3);
          case "q":
            // like 1
            return this$1.num(dt.quarter);
          case "qq":
            // like 01
            return this$1.num(dt.quarter, 2);
          case "X":
            return this$1.num(Math.floor(dt.ts / 1000));
          case "x":
            return this$1.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };

    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  };

  Formatter.prototype.formatDurationFromString = function formatDurationFromString (dur, fmt) {
      var this$1 = this;

    var tokenToField = function (token) {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = function (lildur) { return function (token) {
        var mapped = tokenToField(token);
        if (mapped) {
          return this$1.num(lildur.get(mapped), token.length);
        } else {
          return token;
        }
      }; },
      tokens = Formatter.parseFormat(fmt),
      realTokens = tokens.reduce(
        function (found, ref) {
            var literal = ref.literal;
            var val = ref.val;

            return (literal ? found : found.concat(val));
      },
        []
      ),
      collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function (t) { return t; }));
    return stringifyTokens(tokens, tokenToString(collapsed));
  };

  var intlDTCache = {};
  function getCachedDTF(locString, opts) {
    if ( opts === void 0 ) opts = {};

    var key = JSON.stringify([locString, opts]);
    var dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  }

  var intlNumCache = {};
  function getCachendINF(locString, opts) {
    if ( opts === void 0 ) opts = {};

    var key = JSON.stringify([locString, opts]);
    var inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  }

  var intlRelCache = {};
  function getCachendRTF(locString, opts) {
    if ( opts === void 0 ) opts = {};

    var key = JSON.stringify([locString, opts]);
    var inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  }

  var sysLocaleCache = null;
  function systemLocale() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else if (hasIntl()) {
      var computedSys = new Intl.DateTimeFormat().resolvedOptions().locale;
      // node sometimes defaults to "und". Override that because that is dumb
      sysLocaleCache = computedSys === "und" ? "en-US" : computedSys;
      return sysLocaleCache;
    } else {
      sysLocaleCache = "en-US";
      return sysLocaleCache;
    }
  }

  function parseLocaleString(localeStr) {
    // I really want to avoid writing a BCP 47 parser
    // see, e.g. https://github.com/wooorm/bcp-47
    // Instead, we'll do this:

    // a) if the string has no -u extensions, just leave it alone
    // b) if it does, use Intl to resolve everything
    // c) if Intl fails, try again without the -u

    var uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      var options;
      var smaller = localeStr.substring(0, uIndex);
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
      } catch (e) {
        options = getCachedDTF(smaller).resolvedOptions();
      }

      var numberingSystem = options.numberingSystem;
      var calendar = options.calendar;
      // return the smaller one so that we can append the calendar and numbering overrides to it
      return [smaller, numberingSystem, calendar];
    }
  }

  function intlConfigString(localeStr, numberingSystem, outputCalendar) {
    if (hasIntl()) {
      if (outputCalendar || numberingSystem) {
        localeStr += "-u";

        if (outputCalendar) {
          localeStr += "-ca-" + outputCalendar;
        }

        if (numberingSystem) {
          localeStr += "-nu-" + numberingSystem;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    } else {
      return [];
    }
  }

  function mapMonths(f) {
    var ms = [];
    for (var i = 1; i <= 12; i++) {
      var dt = DateTime.utc(2016, i, 1);
      ms.push(f(dt));
    }
    return ms;
  }

  function mapWeekdays(f) {
    var ms = [];
    for (var i = 1; i <= 7; i++) {
      var dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  }

  function listStuff(loc, length, defaultOK, englishFn, intlFn) {
    var mode = loc.listingMode(defaultOK);

    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  }

  function supportsFastNumbers(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return (
        loc.numberingSystem === "latn" ||
        !loc.locale ||
        loc.locale.startsWith("en") ||
        (hasIntl() && Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn")
      );
    }
  }

  /**
   * @private
   */

  var PolyNumberFormatter = function PolyNumberFormatter(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;

    if (!forceSimple && hasIntl()) {
      var intlOpts = { useGrouping: false };
      if (opts.padTo > 0) { intlOpts.minimumIntegerDigits = opts.padTo; }
      this.inf = getCachendINF(intl, intlOpts);
    }
  };

  PolyNumberFormatter.prototype.format = function format (i) {
    if (this.inf) {
      var fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      // to match the browser's numberformatter defaults
      var fixed$1 = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed$1, this.padTo);
    }
  };

  /**
   * @private
   */

  var PolyDateFormatter = function PolyDateFormatter(dt, intl, opts) {
    this.opts = opts;
    this.hasIntl = hasIntl();

    var z;
    if (dt.zone.universal && this.hasIntl) {
      // Chromium doesn't support fixed-offset zones like Etc/GMT+8 in its formatter,
      // See https://bugs.chromium.org/p/chromium/issues/detail?id=364374.
      // So we have to make do. Two cases:
      // 1. The format options tell us to show the zone. We can't do that, so the best
      // we can do is format the date in UTC.
      // 2. The format options don't tell us to show the zone. Then we can adjust them
      // the time and tell the formatter to show it to us in UTC, so that the time is right
      // and the bad zone doesn't show up.
      // We can clean all this up when Chrome fixes this.
      z = "UTC";
      if (opts.timeZoneName) {
        this.dt = dt;
      } else {
        this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
      }
    } else if (dt.zone.type === "local") {
      this.dt = dt;
    } else {
      this.dt = dt;
      z = dt.zone.name;
    }

    if (this.hasIntl) {
      var intlOpts = Object.assign({}, this.opts);
      if (z) {
        intlOpts.timeZone = z;
      }
      this.dtf = getCachedDTF(intl, intlOpts);
    }
  };

  PolyDateFormatter.prototype.format = function format () {
    if (this.hasIntl) {
      return this.dtf.format(this.dt.toJSDate());
    } else {
      var tokenFormat = formatString(this.opts),
        loc = Locale.create("en-US");
      return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);
    }
  };

  PolyDateFormatter.prototype.formatToParts = function formatToParts () {
    if (this.hasIntl && hasFormatToParts()) {
      return this.dtf.formatToParts(this.dt.toJSDate());
    } else {
      // This is kind of a cop out. We actually could do this for English. However, we couldn't do it for intl strings
      // and IMO it's too weird to have an uncanny valley like that
      return [];
    }
  };

  PolyDateFormatter.prototype.resolvedOptions = function resolvedOptions () {
    if (this.hasIntl) {
      return this.dtf.resolvedOptions();
    } else {
      return {
        locale: "en-US",
        numberingSystem: "latn",
        outputCalendar: "gregory"
      };
    }
  };

  /**
   * @private
   */
  var PolyRelFormatter = function PolyRelFormatter(intl, isEnglish, opts) {
    this.opts = Object.assign({ style: "long" }, opts);
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachendRTF(intl, opts);
    }
  };

  PolyRelFormatter.prototype.format = function format (count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  };

  PolyRelFormatter.prototype.formatToParts = function formatToParts (count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  };

  /**
   * @private
   */

  var Locale = function Locale(locale, numbering, outputCalendar, specifiedLocale) {
    var ref = parseLocaleString(locale);
    var parsedLocale = ref[0];
    var parsedNumberingSystem = ref[1];
    var parsedOutputCalendar = ref[2];

    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);

    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};

    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  };

  var prototypeAccessors$1 = { fastNumbers: { configurable: true } };

  Locale.fromOpts = function fromOpts (opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
  };

  Locale.create = function create (locale, numberingSystem, outputCalendar, defaultToEN) {
      if ( defaultToEN === void 0 ) defaultToEN = false;

    var specifiedLocale = locale || Settings.defaultLocale,
      // the system locale is useful for human readable strings but annoying for parsing/formatting known formats
      localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale()),
      numberingSystemR = numberingSystem || Settings.defaultNumberingSystem,
      outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
  };

  Locale.resetCache = function resetCache () {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
  };

  Locale.fromObject = function fromObject (ref) {
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale;
      var numberingSystem = ref.numberingSystem;
      var outputCalendar = ref.outputCalendar;

    return Locale.create(locale, numberingSystem, outputCalendar);
  };

  prototypeAccessors$1.fastNumbers.get = function () {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }

    return this.fastNumbersCached;
  };

  Locale.prototype.listingMode = function listingMode (defaultOK) {
      if ( defaultOK === void 0 ) defaultOK = true;

    var intl = hasIntl(),
      hasFTP = intl && hasFormatToParts(),
      isActuallyEn = this.isEnglish(),
      hasNoWeirdness =
        (this.numberingSystem === null || this.numberingSystem === "latn") &&
        (this.outputCalendar === null || this.outputCalendar === "gregory");

    if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {
      return "error";
    } else if (!hasFTP || (isActuallyEn && hasNoWeirdness)) {
      return "en";
    } else {
      return "intl";
    }
  };

  Locale.prototype.clone = function clone (alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        alts.defaultToEN || false
      );
    }
  };

  Locale.prototype.redefaultToEN = function redefaultToEN (alts) {
      if ( alts === void 0 ) alts = {};

    return this.clone(Object.assign({}, alts, { defaultToEN: true }));
  };

  Locale.prototype.redefaultToSystem = function redefaultToSystem (alts) {
      if ( alts === void 0 ) alts = {};

    return this.clone(Object.assign({}, alts, { defaultToEN: false }));
  };

  Locale.prototype.months = function months$1 (length, format, defaultOK) {
      var this$1 = this;
      if ( format === void 0 ) format = false;
      if ( defaultOK === void 0 ) defaultOK = true;

    return listStuff(this, length, defaultOK, months, function () {
      var intl = format ? { month: length, day: "numeric" } : { month: length },
        formatStr = format ? "format" : "standalone";
      if (!this$1.monthsCache[formatStr][length]) {
        this$1.monthsCache[formatStr][length] = mapMonths(function (dt) { return this$1.extract(dt, intl, "month"); });
      }
      return this$1.monthsCache[formatStr][length];
    });
  };

  Locale.prototype.weekdays = function weekdays$1 (length, format, defaultOK) {
      var this$1 = this;
      if ( format === void 0 ) format = false;
      if ( defaultOK === void 0 ) defaultOK = true;

    return listStuff(this, length, defaultOK, weekdays, function () {
      var intl = format
          ? { weekday: length, year: "numeric", month: "long", day: "numeric" }
          : { weekday: length },
        formatStr = format ? "format" : "standalone";
      if (!this$1.weekdaysCache[formatStr][length]) {
        this$1.weekdaysCache[formatStr][length] = mapWeekdays(function (dt) { return this$1.extract(dt, intl, "weekday"); }
        );
      }
      return this$1.weekdaysCache[formatStr][length];
    });
  };

  Locale.prototype.meridiems = function meridiems$1 (defaultOK) {
      var this$1 = this;
      if ( defaultOK === void 0 ) defaultOK = true;

    return listStuff(
      this,
      undefined,
      defaultOK,
      function () { return meridiems; },
      function () {
        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
        // for AM and PM. This is probably wrong, but it's makes parsing way easier.
        if (!this$1.meridiemCache) {
          var intl = { hour: "numeric", hour12: true };
          this$1.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            function (dt) { return this$1.extract(dt, intl, "dayperiod"); }
          );
        }

        return this$1.meridiemCache;
      }
    );
  };

  Locale.prototype.eras = function eras$1 (length, defaultOK) {
      var this$1 = this;
      if ( defaultOK === void 0 ) defaultOK = true;

    return listStuff(this, length, defaultOK, eras, function () {
      var intl = { era: length };

      // This is utter bullshit. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
      // to definitely enumerate them.
      if (!this$1.eraCache[length]) {
        this$1.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(function (dt) { return this$1.extract(dt, intl, "era"); }
        );
      }

      return this$1.eraCache[length];
    });
  };

  Locale.prototype.extract = function extract (dt, intlOpts, field) {
    var df = this.dtFormatter(dt, intlOpts),
      results = df.formatToParts(),
      matching = results.find(function (m) { return m.type.toLowerCase() === field; });

    return matching ? matching.value : null;
  };

  Locale.prototype.numberFormatter = function numberFormatter (opts) {
      if ( opts === void 0 ) opts = {};

    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
    // (in contrast, the rest of the condition is used heavily)
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  };

  Locale.prototype.dtFormatter = function dtFormatter (dt, intlOpts) {
      if ( intlOpts === void 0 ) intlOpts = {};

    return new PolyDateFormatter(dt, this.intl, intlOpts);
  };

  Locale.prototype.relFormatter = function relFormatter (opts) {
      if ( opts === void 0 ) opts = {};

    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  };

  Locale.prototype.isEnglish = function isEnglish () {
    return (
      this.locale === "en" ||
      this.locale.toLowerCase() === "en-us" ||
      (hasIntl() &&
        Intl.DateTimeFormat(this.intl)
          .resolvedOptions()
          .locale.startsWith("en-us"))
    );
  };

  Locale.prototype.equals = function equals (other) {
    return (
      this.locale === other.locale &&
      this.numberingSystem === other.numberingSystem &&
      this.outputCalendar === other.outputCalendar
    );
  };

  Object.defineProperties( Locale.prototype, prototypeAccessors$1 );

  /*
   * This file handles parsing for well-specified formats. Here's how it works:
   * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
   * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
   * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
   * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
   * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
   * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
   */

  function combineRegexes() {
    var regexes = [], len = arguments.length;
    while ( len-- ) regexes[ len ] = arguments[ len ];

    var full = regexes.reduce(function (f, r) { return f + r.source; }, "");
    return RegExp(("^" + full + "$"));
  }

  function combineExtractors() {
    var extractors = [], len = arguments.length;
    while ( len-- ) extractors[ len ] = arguments[ len ];

    return function (m) { return extractors
        .reduce(
          function (ref, ex) {
            var mergedVals = ref[0];
            var mergedZone = ref[1];
            var cursor = ref[2];

            var ref$1 = ex(m, cursor);
            var val = ref$1[0];
            var zone = ref$1[1];
            var next = ref$1[2];
            return [Object.assign(mergedVals, val), mergedZone || zone, next];
          },
          [{}, null, 1]
        )
        .slice(0, 2); };
  }

  function parse$1(s) {
    var patterns = [], len = arguments.length - 1;
    while ( len-- > 0 ) patterns[ len ] = arguments[ len + 1 ];

    if (s == null) {
      return [null, null];
    }

    for (var i = 0, list = patterns; i < list.length; i += 1) {
      var ref = list[i];
      var regex = ref[0];
      var extractor = ref[1];

      var m = regex.exec(s);
      if (m) {
        return extractor(m);
      }
    }
    return [null, null];
  }

  function simpleParse() {
    var keys = [], len = arguments.length;
    while ( len-- ) keys[ len ] = arguments[ len ];

    return function (match, cursor) {
      var ret = {};
      var i;

      for (i = 0; i < keys.length; i++) {
        ret[keys[i]] = parseInteger$1(match[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  }

  // ISO and SQL parsing
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
    isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,9}))?)?)?/,
    isoTimeRegex = RegExp(("" + (isoTimeBaseRegex.source) + (offsetRegex.source) + "?")),
    isoTimeExtensionRegex = RegExp(("(?:T" + (isoTimeRegex.source) + ")?")),
    isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,
    isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/,
    isoOrdinalRegex = /(\d{4})-?(\d{3})/,
    extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"),
    extractISOOrdinalData = simpleParse("year", "ordinal"),
    sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/, // dumbed-down version of the ISO one
    sqlTimeRegex = RegExp(
      ((isoTimeBaseRegex.source) + " ?(?:" + (offsetRegex.source) + "|(" + (ianaRegex.source) + "))?")
    ),
    sqlTimeExtensionRegex = RegExp(("(?: " + (sqlTimeRegex.source) + ")?"));

  function int(match, pos, fallback) {
    var m = match[pos];
    return isUndefined(m) ? fallback : parseInteger$1(m);
  }

  function extractISOYmd(match, cursor) {
    var item = {
      year: int(match, cursor),
      month: int(match, cursor + 1, 1),
      day: int(match, cursor + 2, 1)
    };

    return [item, null, cursor + 3];
  }

  function extractISOTime(match, cursor) {
    var item = {
      hour: int(match, cursor, 0),
      minute: int(match, cursor + 1, 0),
      second: int(match, cursor + 2, 0),
      millisecond: parseMillis(match[cursor + 3])
    };

    return [item, null, cursor + 4];
  }

  function extractISOOffset(match, cursor) {
    var local = !match[cursor] && !match[cursor + 1],
      fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
      zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  }

  function extractIANAZone(match, cursor) {
    var zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
    return [{}, zone, cursor + 1];
  }

  // ISO duration parsing

  var isoDuration = /^P(?:(?:(-?\d{1,9})Y)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})W)?(?:(-?\d{1,9})D)?(?:T(?:(-?\d{1,9})H)?(?:(-?\d{1,9})M)?(?:(-?\d{1,9})(?:[.,](-?\d{1,9}))?S)?)?)$/;

  function extractISODuration(match) {
    var yearStr = match[1];
    var monthStr = match[2];
    var weekStr = match[3];
    var dayStr = match[4];
    var hourStr = match[5];
    var minuteStr = match[6];
    var secondStr = match[7];
    var millisecondsStr = match[8];

    return [
      {
        years: parseInteger$1(yearStr),
        months: parseInteger$1(monthStr),
        weeks: parseInteger$1(weekStr),
        days: parseInteger$1(dayStr),
        hours: parseInteger$1(hourStr),
        minutes: parseInteger$1(minuteStr),
        seconds: parseInteger$1(secondStr),
        milliseconds: parseMillis(millisecondsStr)
      }
    ];
  }

  // These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
  // and not just that we're in -240 *right now*. But since I don't think these are used that often
  // I'm just going to ignore that
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };

  function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger$1(yearStr)) : parseInteger$1(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger$1(dayStr),
      hour: parseInteger$1(hourStr),
      minute: parseInteger$1(minuteStr)
    };

    if (secondStr) { result.second = parseInteger$1(secondStr); }
    if (weekdayStr) {
      result.weekday =
        weekdayStr.length > 3
          ? weekdaysLong.indexOf(weekdayStr) + 1
          : weekdaysShort.indexOf(weekdayStr) + 1;
    }

    return result;
  }

  // RFC 2822/5322
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

  function extractRFC2822(match) {
    var weekdayStr = match[1];
    var dayStr = match[2];
    var monthStr = match[3];
    var yearStr = match[4];
    var hourStr = match[5];
    var minuteStr = match[6];
    var secondStr = match[7];
    var obsOffset = match[8];
    var milOffset = match[9];
    var offHourStr = match[10];
    var offMinuteStr = match[11];
    var result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);

    var offset;
    if (obsOffset) {
      offset = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset = 0;
    } else {
      offset = signedOffset(offHourStr, offMinuteStr);
    }

    return [result, new FixedOffsetZone(offset)];
  }

  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s
      .replace(/\([^)]*\)|[\n\t]/g, " ")
      .replace(/(\s\s+)/g, " ")
      .trim();
  }

  // http date

  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
    rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
    ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

  function extractRFC1123Or850(match) {
    var weekdayStr = match[1];
    var dayStr = match[2];
    var monthStr = match[3];
    var yearStr = match[4];
    var hourStr = match[5];
    var minuteStr = match[6];
    var secondStr = match[7];
    var result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }

  function extractASCII(match) {
    var weekdayStr = match[1];
    var monthStr = match[2];
    var dayStr = match[3];
    var hourStr = match[4];
    var minuteStr = match[5];
    var secondStr = match[6];
    var yearStr = match[7];
    var result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }

  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);

  var extractISOYmdTimeAndOffset = combineExtractors(
    extractISOYmd,
    extractISOTime,
    extractISOOffset
  );
  var extractISOWeekTimeAndOffset = combineExtractors(
    extractISOWeekData,
    extractISOTime,
    extractISOOffset
  );
  var extractISOOrdinalDataAndTime = combineExtractors(extractISOOrdinalData, extractISOTime);
  var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);

  /**
   * @private
   */

  function parseISODate(s) {
    return parse$1(
      s,
      [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
      [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDataAndTime],
      [isoTimeCombinedRegex, extractISOTimeAndOffset]
    );
  }

  function parseRFC2822Date(s) {
    return parse$1(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
  }

  function parseHTTPDate(s) {
    return parse$1(
      s,
      [rfc1123, extractRFC1123Or850],
      [rfc850, extractRFC1123Or850],
      [ascii, extractASCII]
    );
  }

  function parseISODuration(s) {
    return parse$1(s, [isoDuration, extractISODuration]);
  }

  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);

  var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(
    extractISOYmd,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOTimeOffsetAndIANAZone = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );

  function parseSQL(s) {
    return parse$1(
      s,
      [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone],
      [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
    );
  }

  var Invalid = function Invalid(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  };

  Invalid.prototype.toMessage = function toMessage () {
    if (this.explanation) {
      return ((this.reason) + ": " + (this.explanation));
    } else {
      return this.reason;
    }
  };

  var INVALID = "Invalid Duration";

  // unit conversion constants
  var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1000
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1000
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1000 },
      minutes: { seconds: 60, milliseconds: 60 * 1000 },
      seconds: { milliseconds: 1000 }
    },
    casualMatrix = Object.assign(
      {
        years: {
          months: 12,
          weeks: 52,
          days: 365,
          hours: 365 * 24,
          minutes: 365 * 24 * 60,
          seconds: 365 * 24 * 60 * 60,
          milliseconds: 365 * 24 * 60 * 60 * 1000
        },
        quarters: {
          months: 3,
          weeks: 13,
          days: 91,
          hours: 91 * 24,
          minutes: 91 * 24 * 60,
          milliseconds: 91 * 24 * 60 * 60 * 1000
        },
        months: {
          weeks: 4,
          days: 30,
          hours: 30 * 24,
          minutes: 30 * 24 * 60,
          seconds: 30 * 24 * 60 * 60,
          milliseconds: 30 * 24 * 60 * 60 * 1000
        }
      },
      lowOrderMatrix
    ),
    daysInYearAccurate = 146097.0 / 400,
    daysInMonthAccurate = 146097.0 / 4800,
    accurateMatrix = Object.assign(
      {
        years: {
          months: 12,
          weeks: daysInYearAccurate / 7,
          days: daysInYearAccurate,
          hours: daysInYearAccurate * 24,
          minutes: daysInYearAccurate * 24 * 60,
          seconds: daysInYearAccurate * 24 * 60 * 60,
          milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
        },
        quarters: {
          months: 3,
          weeks: daysInYearAccurate / 28,
          days: daysInYearAccurate / 4,
          hours: (daysInYearAccurate * 24) / 4,
          minutes: (daysInYearAccurate * 24 * 60) / 4,
          seconds: (daysInYearAccurate * 24 * 60 * 60) / 4,
          milliseconds: (daysInYearAccurate * 24 * 60 * 60 * 1000) / 4
        },
        months: {
          weeks: daysInMonthAccurate / 7,
          days: daysInMonthAccurate,
          hours: daysInMonthAccurate * 24,
          minutes: daysInMonthAccurate * 24 * 60,
          seconds: daysInMonthAccurate * 24 * 60 * 60,
          milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
        }
      },
      lowOrderMatrix
    );

  // units ordered by size
  var orderedUnits = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds"
  ];

  var reverseUnits = orderedUnits.slice(0).reverse();

  // clone really means "create another instance just like this one, but with these changes"
  function clone(dur, alts, clear) {
    if ( clear === void 0 ) clear = false;

    // deep merge for vals
    var conf = {
      values: clear ? alts.values : Object.assign({}, dur.values, alts.values || {}),
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
    };
    return new Duration(conf);
  }

  function antiTrunc(n) {
    return n < 0 ? Math.floor(n) : Math.ceil(n);
  }

  // NB: mutates parameters
  function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
    var conv = matrix[toUnit][fromUnit],
      raw = fromMap[fromUnit] / conv,
      sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
      // ok, so this is wild, but see the matrix in the tests
      added =
        !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
    toMap[toUnit] += added;
    fromMap[fromUnit] -= added * conv;
  }

  // NB: mutates parameters
  function normalizeValues(matrix, vals) {
    reverseUnits.reduce(function (previous, current) {
      if (!isUndefined(vals[current])) {
        if (previous) {
          convert(matrix, vals, previous, vals, current);
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  }

  /**
   * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime.plus} to add a Duration object to a DateTime, producing another DateTime.
   *
   * Here is a brief overview of commonly used methods and getters in Duration:
   *
   * * **Creation** To create a Duration, use {@link Duration.fromMillis}, {@link Duration.fromObject}, or {@link Duration.fromISO}.
   * * **Unit values** See the {@link Duration.years}, {@link Duration.months}, {@link Duration.weeks}, {@link Duration.days}, {@link Duration.hours}, {@link Duration.minutes}, {@link Duration.seconds}, {@link Duration.milliseconds} accessors.
   * * **Configuration** See  {@link Duration.locale} and {@link Duration.numberingSystem} accessors.
   * * **Transformation** To create new Durations out of old ones use {@link Duration.plus}, {@link Duration.minus}, {@link Duration.normalize}, {@link Duration.set}, {@link Duration.reconfigure}, {@link Duration.shiftTo}, and {@link Duration.negate}.
   * * **Output** To convert the Duration into other representations, see {@link Duration.as}, {@link Duration.toISO}, {@link Duration.toFormat}, and {@link Duration.toJSON}
   *
   * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
   */
  var Duration = function Duration(config) {
    var accurate = config.conversionAccuracy === "longterm" || false;
    /**
     * @access private
     */
    this.values = config.values;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.matrix = accurate ? accurateMatrix : casualMatrix;
    /**
     * @access private
     */
    this.isLuxonDuration = true;
  };

  var prototypeAccessors$2 = { locale: { configurable: true },numberingSystem: { configurable: true },years: { configurable: true },quarters: { configurable: true },months: { configurable: true },weeks: { configurable: true },days: { configurable: true },hours: { configurable: true },minutes: { configurable: true },seconds: { configurable: true },milliseconds: { configurable: true },isValid: { configurable: true },invalidReason: { configurable: true },invalidExplanation: { configurable: true } };

  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  Duration.fromMillis = function fromMillis (count, opts) {
    return Duration.fromObject(Object.assign({ milliseconds: count }, opts));
  };

  /**
   * Create a Duration from a Javascript object with keys like 'years' and 'hours.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {string} [obj.locale='en-US'] - the locale to use
   * @param {string} obj.numberingSystem - the numbering system to use
   * @param {string} [obj.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  Duration.fromObject = function fromObject (obj) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        ("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj))
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit, [
        "locale",
        "numberingSystem",
        "conversionAccuracy",
        "zone" // a bit of debt; it's super inconvenient internally not to be able to blindly pass this
      ]),
      loc: Locale.fromObject(obj),
      conversionAccuracy: obj.conversionAccuracy
    });
  };

  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  Duration.fromISO = function fromISO (text, opts) {
    var ref = parseISODuration(text);
      var parsed = ref[0];
    if (parsed) {
      var obj = Object.assign(parsed, opts);
      return Duration.fromObject(obj);
    } else {
      return Duration.invalid("unparsable", ("the input \"" + text + "\" can't be parsed as ISO 8601"));
    }
  };

  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  Duration.invalid = function invalid (reason, explanation) {
      if ( explanation === void 0 ) explanation = null;

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid: invalid });
    }
  };

  /**
   * @private
   */
  Duration.normalizeUnit = function normalizeUnit (unit) {
    var normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];

    if (!normalized) { throw new InvalidUnitError(unit); }

    return normalized;
  };

  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  Duration.isDuration = function isDuration (o) {
    return (o && o.isLuxonDuration) || false;
  };

  /**
   * Getthe locale of a Duration, such 'en-GB'
   * @type {string}
   */
  prototypeAccessors$2.locale.get = function () {
    return this.isValid ? this.loc.locale : null;
  };

  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  prototypeAccessors$2.numberingSystem.get = function () {
    return this.isValid ? this.loc.numberingSystem : null;
  };

  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * The duration will be converted to the set of units in the format string using {@link Duration.shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  Duration.prototype.toFormat = function toFormat (fmt, opts) {
      if ( opts === void 0 ) opts = {};

    // reverse-compat since 1.2; we always round down now, never up, and we do it by default
    var fmtOpts = Object.assign({}, opts, {
      floor: opts.round !== false && opts.floor !== false
    });
    return this.isValid
      ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt)
      : INVALID;
  };

  /**
   * Returns a Javascript object with this Duration's values.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  Duration.prototype.toObject = function toObject (opts) {
      if ( opts === void 0 ) opts = {};

    if (!this.isValid) { return {}; }

    var base = Object.assign({}, this.values);

    if (opts.includeConfig) {
      base.conversionAccuracy = this.conversionAccuracy;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  };

  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  Duration.prototype.toISO = function toISO () {
    // we could use the formatter, but this is an easier way to get the minimum string
    if (!this.isValid) { return null; }

    var s = "P";
    if (this.years !== 0) { s += this.years + "Y"; }
    if (this.months !== 0 || this.quarters !== 0) { s += this.months + this.quarters * 3 + "M"; }
    if (this.weeks !== 0) { s += this.weeks + "W"; }
    if (this.days !== 0) { s += this.days + "D"; }
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      { s += "T"; }
    if (this.hours !== 0) { s += this.hours + "H"; }
    if (this.minutes !== 0) { s += this.minutes + "M"; }
    if (this.seconds !== 0 || this.milliseconds !== 0)
      { s += this.seconds + this.milliseconds / 1000 + "S"; }
    if (s === "P") { s += "T0S"; }
    return s;
  };

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  Duration.prototype.toJSON = function toJSON () {
    return this.toISO();
  };

  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  Duration.prototype.toString = function toString () {
    return this.toISO();
  };

  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  Duration.prototype.valueOf = function valueOf () {
    return this.as("milliseconds");
  };

  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  Duration.prototype.plus = function plus (duration) {
    if (!this.isValid) { return this; }

    var dur = friendlyDuration(duration),
      result = {};

    for (var i = 0, list = orderedUnits; i < list.length; i += 1) {
      var k = list[i];

        if (dur.values.hasOwnProperty(k) || this.values.hasOwnProperty(k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }

    return clone(this, { values: result }, true);
  };

  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  Duration.prototype.minus = function minus (duration) {
    if (!this.isValid) { return this; }

    var dur = friendlyDuration(duration);
    return this.plus(dur.negate());
  };

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).years //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).months //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).days //=> 3
   * @return {number}
   */
  Duration.prototype.get = function get (unit) {
    return this[Duration.normalizeUnit(unit)];
  };

  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  Duration.prototype.set = function set (values) {
    if (!this.isValid) { return this; }

    var mixed = Object.assign(this.values, normalizeObject(values, Duration.normalizeUnit, []));
    return clone(this, { values: mixed });
  };

  /**
   * "Set" the locale and/or numberingSystem.Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  Duration.prototype.reconfigure = function reconfigure (ref) {
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale;
      var numberingSystem = ref.numberingSystem;
      var conversionAccuracy = ref.conversionAccuracy;

    var loc = this.loc.clone({ locale: locale, numberingSystem: numberingSystem }),
      opts = { loc: loc };

    if (conversionAccuracy) {
      opts.conversionAccuracy = conversionAccuracy;
    }

    return clone(this, opts);
  };

  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  Duration.prototype.as = function as (unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  };

  /**
   * Reduce this Duration to its canonical representation in its current units.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  Duration.prototype.normalize = function normalize () {
    if (!this.isValid) { return this; }
    var vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return Duration.fromObject(vals);
  };

  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  Duration.prototype.shiftTo = function shiftTo () {
      var units = [], len = arguments.length;
      while ( len-- ) units[ len ] = arguments[ len ];

    if (!this.isValid) { return this; }

    if (units.length === 0) {
      return this;
    }

    units = units.map(function (u) { return Duration.normalizeUnit(u); });

    var built = {},
      accumulated = {},
      vals = this.toObject();
    var lastUnit;

    normalizeValues(this.matrix, vals);

    for (var i$1 = 0, list = orderedUnits; i$1 < list.length; i$1 += 1) {
      var k = list[i$1];

        if (units.indexOf(k) >= 0) {
        lastUnit = k;

        var own = 0;

        // anything we haven't boiled down yet should get boiled to this unit
        for (var ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }

        // plus anything that's already in this unit
        if (isNumber(vals[k])) {
          own += vals[k];
        }

        var i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = own - i; // we'd like to absorb these fractions in another unit

        // plus anything further down the chain that should be rolled up in to this
        for (var down in vals) {
          if (orderedUnits.indexOf(down) > orderedUnits.indexOf(k)) {
            convert(this.matrix, vals, down, built, k);
          }
        }
        // otherwise, keep it in the wings to boil it later
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }

    // anything leftover becomes the decimal for the last unit
    // lastUnit must be defined since units is not empty
    for (var key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] +=
          key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }

    return clone(this, { values: built }, true);
  };

  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  Duration.prototype.negate = function negate () {
    if (!this.isValid) { return this; }
    var negated = {};
    for (var i = 0, list = Object.keys(this.values); i < list.length; i += 1) {
      var k = list[i];

        negated[k] = -this.values[k];
    }
    return clone(this, { values: negated }, true);
  };

  /**
   * Get the years.
   * @type {number}
   */
  prototypeAccessors$2.years.get = function () {
    return this.isValid ? this.values.years || 0 : NaN;
  };

  /**
   * Get the quarters.
   * @type {number}
   */
  prototypeAccessors$2.quarters.get = function () {
    return this.isValid ? this.values.quarters || 0 : NaN;
  };

  /**
   * Get the months.
   * @type {number}
   */
  prototypeAccessors$2.months.get = function () {
    return this.isValid ? this.values.months || 0 : NaN;
  };

  /**
   * Get the weeks
   * @type {number}
   */
  prototypeAccessors$2.weeks.get = function () {
    return this.isValid ? this.values.weeks || 0 : NaN;
  };

  /**
   * Get the days.
   * @type {number}
   */
  prototypeAccessors$2.days.get = function () {
    return this.isValid ? this.values.days || 0 : NaN;
  };

  /**
   * Get the hours.
   * @type {number}
   */
  prototypeAccessors$2.hours.get = function () {
    return this.isValid ? this.values.hours || 0 : NaN;
  };

  /**
   * Get the minutes.
   * @type {number}
   */
  prototypeAccessors$2.minutes.get = function () {
    return this.isValid ? this.values.minutes || 0 : NaN;
  };

  /**
   * Get the seconds.
   * @return {number}
   */
  prototypeAccessors$2.seconds.get = function () {
    return this.isValid ? this.values.seconds || 0 : NaN;
  };

  /**
   * Get the milliseconds.
   * @return {number}
   */
  prototypeAccessors$2.milliseconds.get = function () {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  };

  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  prototypeAccessors$2.isValid.get = function () {
    return this.invalid === null;
  };

  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  prototypeAccessors$2.invalidReason.get = function () {
    return this.invalid ? this.invalid.reason : null;
  };

  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  prototypeAccessors$2.invalidExplanation.get = function () {
    return this.invalid ? this.invalid.explanation : null;
  };

  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  Duration.prototype.equals = function equals (other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    if (!this.loc.equals(other.loc)) {
      return false;
    }

    for (var i = 0, list = orderedUnits; i < list.length; i += 1) {
      var u = list[i];

        if (this.values[u] !== other.values[u]) {
        return false;
      }
    }
    return true;
  };

  Object.defineProperties( Duration.prototype, prototypeAccessors$2 );

  /**
   * @private
   */
  function friendlyDuration(durationish) {
    if (isNumber(durationish)) {
      return Duration.fromMillis(durationish);
    } else if (Duration.isDuration(durationish)) {
      return durationish;
    } else if (typeof durationish === "object") {
      return Duration.fromObject(durationish);
    } else {
      throw new InvalidArgumentError(
        ("Unknown duration argument " + durationish + " of type " + (typeof durationish))
      );
    }
  }

  var INVALID$1 = "Invalid Interval";

  // checks if the start is equal to or before the end
  function validateStartEnd(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid(
        "end before start",
        ("The end of an interval must be after its start, but you had start=" + (start.toISO()) + " and end=" + (end.toISO()))
      );
    } else {
      return null;
    }
  }

  /**
   * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
   *
   * Here is a brief overview of the most commonly used methods and getters in Interval:
   *
   * * **Creation** To create an Interval, use {@link fromDateTimes}, {@link after}, {@link before}, or {@link fromISO}.
   * * **Accessors** Use {@link start} and {@link end} to get the start and end.
   * * **Interrogation** To analyze the Interval, use {@link count}, {@link length}, {@link hasSame}, {@link contains}, {@link isAfter}, or {@link isBefore}.
   * * **Transformation** To create other Intervals out of this one, use {@link set}, {@link splitAt}, {@link splitBy}, {@link divideEqually}, {@link merge}, {@link xor}, {@link union}, {@link intersection}, or {@link difference}.
   * * **Comparison** To compare this Interval to another one, use {@link equals}, {@link overlaps}, {@link abutsStart}, {@link abutsEnd}, {@link engulfs}
   * * **Output*** To convert the Interval into other representations, see {@link toString}, {@link toISO}, {@link toFormat}, and {@link toDuration}.
   */
  var Interval = function Interval(config) {
    /**
     * @access private
     */
    this.s = config.start;
    /**
     * @access private
     */
    this.e = config.end;
    /**
     * @access private
     */
    this.invalid = config.invalid || null;
    /**
     * @access private
     */
    this.isLuxonInterval = true;
  };

  var prototypeAccessors$3 = { start: { configurable: true },end: { configurable: true },isValid: { configurable: true },invalidReason: { configurable: true },invalidExplanation: { configurable: true } };

  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  Interval.invalid = function invalid (reason, explanation) {
      if ( explanation === void 0 ) explanation = null;

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid: invalid });
    }
  };

  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  Interval.fromDateTimes = function fromDateTimes (start, end) {
    var builtStart = friendlyDateTime(start),
      builtEnd = friendlyDateTime(end);

    var validateError = validateStartEnd(builtStart, builtEnd);

    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  };

  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  Interval.after = function after (start, duration) {
    var dur = friendlyDuration(duration),
      dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  };

  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  Interval.before = function before (end, duration) {
    var dur = friendlyDuration(duration),
      dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  };

  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime.fromISO} and optionally {@link Duration.fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  Interval.fromISO = function fromISO (text, opts) {
    var ref = (text || "").split("/", 2);
      var s = ref[0];
      var e = ref[1];
    if (s && e) {
      var start = DateTime.fromISO(s, opts),
        end = DateTime.fromISO(e, opts);

      if (start.isValid && end.isValid) {
        return Interval.fromDateTimes(start, end);
      }

      if (start.isValid) {
        var dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (end.isValid) {
        var dur$1 = Duration.fromISO(s, opts);
        if (dur$1.isValid) {
          return Interval.before(end, dur$1);
        }
      }
    }
    return Interval.invalid("unparsable", ("the input \"" + text + "\" can't be parsed asISO 8601"));
  };

  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  Interval.isInterval = function isInterval (o) {
    return (o && o.isLuxonInterval) || false;
  };

  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  prototypeAccessors$3.start.get = function () {
    return this.isValid ? this.s : null;
  };

  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  prototypeAccessors$3.end.get = function () {
    return this.isValid ? this.e : null;
  };

  /**
   * Returns whether this Interval's end is at least its start, i.e. that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  prototypeAccessors$3.isValid.get = function () {
    return this.invalidReason === null;
  };

  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  prototypeAccessors$3.invalidReason.get = function () {
    return this.invalid ? this.invalid.reason : null;
  };

  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  prototypeAccessors$3.invalidExplanation.get = function () {
    return this.invalid ? this.invalid.explanation : null;
  };

  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  Interval.prototype.length = function length (unit) {
      if ( unit === void 0 ) unit = "milliseconds";

    return this.isValid ? this.toDuration(unit).get(unit) : NaN;
  };

  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @return {number}
   */
  Interval.prototype.count = function count (unit) {
      if ( unit === void 0 ) unit = "milliseconds";

    if (!this.isValid) { return NaN; }
    var start = this.start.startOf(unit),
      end = this.end.startOf(unit);
    return Math.floor(end.diff(start, unit).get(unit)) + 1;
  };

  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  Interval.prototype.hasSame = function hasSame (unit) {
    return this.isValid ? this.e.minus(1).hasSame(this.s, unit) : false;
  };

  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  Interval.prototype.isEmpty = function isEmpty () {
    return this.s.valueOf() === this.e.valueOf();
  };

  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  Interval.prototype.isAfter = function isAfter (dateTime) {
    if (!this.isValid) { return false; }
    return this.s > dateTime;
  };

  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  Interval.prototype.isBefore = function isBefore (dateTime) {
    if (!this.isValid) { return false; }
    return this.e <= dateTime;
  };

  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  Interval.prototype.contains = function contains (dateTime) {
    if (!this.isValid) { return false; }
    return this.s <= dateTime && this.e > dateTime;
  };

  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  Interval.prototype.set = function set (ref) {
      if ( ref === void 0 ) ref = {};
      var start = ref.start;
      var end = ref.end;

    if (!this.isValid) { return this; }
    return Interval.fromDateTimes(start || this.s, end || this.e);
  };

  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...[DateTime]} dateTimes - the unit of time to count.
   * @return {[Interval]}
   */
  Interval.prototype.splitAt = function splitAt () {
      var dateTimes = [], len = arguments.length;
      while ( len-- ) dateTimes[ len ] = arguments[ len ];

    if (!this.isValid) { return []; }
    var sorted = dateTimes.map(friendlyDateTime).sort(),
      results = [];
    var ref = this;
      var s = ref.s;
      var i = 0;

    while (s < this.e) {
      var added = sorted[i] || this.e,
        next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
      i += 1;
    }

    return results;
  };

  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {[Interval]}
   */
  Interval.prototype.splitBy = function splitBy (duration) {
    var dur = friendlyDuration(duration);

    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }

    var ref = this;
      var s = ref.s;
      var added,
      next;

    var results = [];
    while (s < this.e) {
      added = s.plus(dur);
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s, next));
      s = next;
    }

    return results;
  };

  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {[Interval]}
   */
  Interval.prototype.divideEqually = function divideEqually (numberOfParts) {
    if (!this.isValid) { return []; }
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  };

  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  Interval.prototype.overlaps = function overlaps (other) {
    return this.e > other.s && this.s < other.e;
  };

  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  Interval.prototype.abutsStart = function abutsStart (other) {
    if (!this.isValid) { return false; }
    return +this.e === +other.s;
  };

  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  Interval.prototype.abutsEnd = function abutsEnd (other) {
    if (!this.isValid) { return false; }
    return +other.e === +this.s;
  };

  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  Interval.prototype.engulfs = function engulfs (other) {
    if (!this.isValid) { return false; }
    return this.s <= other.s && this.e >= other.e;
  };

  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  Interval.prototype.equals = function equals (other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }

    return this.s.equals(other.s) && this.e.equals(other.e);
  };

  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, i.e., the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  Interval.prototype.intersection = function intersection (other) {
    if (!this.isValid) { return this; }
    var s = this.s > other.s ? this.s : other.s,
      e = this.e < other.e ? this.e : other.e;

    if (s > e) {
      return null;
    } else {
      return Interval.fromDateTimes(s, e);
    }
  };

  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  Interval.prototype.union = function union (other) {
    if (!this.isValid) { return this; }
    var s = this.s < other.s ? this.s : other.s,
      e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s, e);
  };

  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */
  Interval.merge = function merge (intervals) {
    var ref = intervals.sort(function (a, b) { return a.s - b.s; }).reduce(
      function (ref, item) {
          var sofar = ref[0];
          var current = ref[1];

        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
      var found = ref[0];
      var final = ref[1];
    if (final) {
      found.push(final);
    }
    return found;
  };

  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {[Interval]} intervals
   * @return {[Interval]}
   */
  Interval.xor = function xor (intervals) {
      var ref;

    var start = null,
      currentCount = 0;
    var results = [],
      ends = intervals.map(function (i) { return [{ time: i.s, type: "s" }, { time: i.e, type: "e" }]; }),
      flattened = (ref = Array.prototype).concat.apply(ref, ends),
      arr = flattened.sort(function (a, b) { return a.time - b.time; });

    for (var i$1 = 0, list = arr; i$1 < list.length; i$1 += 1) {
      var i = list[i$1];

        currentCount += i.type === "s" ? 1 : -1;

      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }

        start = null;
      }
    }

    return Interval.merge(results);
  };

  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {[Interval]}
   */
  Interval.prototype.difference = function difference () {
      var this$1 = this;
      var intervals = [], len = arguments.length;
      while ( len-- ) intervals[ len ] = arguments[ len ];

    return Interval.xor([this].concat(intervals))
      .map(function (i) { return this$1.intersection(i); })
      .filter(function (i) { return i && !i.isEmpty(); });
  };

  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  Interval.prototype.toString = function toString () {
    if (!this.isValid) { return INVALID$1; }
    return ("[" + (this.s.toISO()) + " – " + (this.e.toISO()) + ")");
  };

  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime.toISO}
   * @return {string}
   */
  Interval.prototype.toISO = function toISO (opts) {
    if (!this.isValid) { return INVALID$1; }
    return ((this.s.toISO(opts)) + "/" + (this.e.toISO(opts)));
  };

  /**
   * Returns a string representation of this Interval formatted according to the specified format string.
   * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime.toFormat} for details.
   * @param {Object} opts - options
   * @param {string} [opts.separator =' – '] - a separator to place between the start and end representations
   * @return {string}
   */
  Interval.prototype.toFormat = function toFormat (dateFormat, ref) {
      if ( ref === void 0 ) ref = {};
      var separator = ref.separator; if ( separator === void 0 ) separator = " – ";

    if (!this.isValid) { return INVALID$1; }
    return ("" + (this.s.toFormat(dateFormat)) + separator + (this.e.toFormat(dateFormat)));
  };

  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  Interval.prototype.toDuration = function toDuration (unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  };

  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  Interval.prototype.mapEndpoints = function mapEndpoints (mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  };

  Object.defineProperties( Interval.prototype, prototypeAccessors$3 );

  /**
   * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
   */
  var Info = function Info () {};

  Info.hasDST = function hasDST (zone) {
      if ( zone === void 0 ) zone = Settings.defaultZone;

    var proto = DateTime.local()
      .setZone(zone)
      .set({ month: 12 });

    return !zone.universal && proto.offset !== proto.set({ month: 6 }).offset;
  };

  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  Info.isValidIANAZone = function isValidIANAZone (zone) {
    return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
  };

  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   * with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   * instance with {@link Zone.isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   * in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  Info.normalizeZone = function normalizeZone$1 (input) {
    return normalizeZone(input, Settings.defaultZone);
  };

  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {[string]}
   */
  Info.months = function months (
    length,
    ref
  ) {
      if ( length === void 0 ) length = "long";
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale; if ( locale === void 0 ) locale = null;
      var numberingSystem = ref.numberingSystem; if ( numberingSystem === void 0 ) numberingSystem = null;
      var outputCalendar = ref.outputCalendar; if ( outputCalendar === void 0 ) outputCalendar = "gregory";

    return Locale.create(locale, numberingSystem, outputCalendar).months(length);
  };

  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {[string]}
   */
  Info.monthsFormat = function monthsFormat (
    length,
    ref
  ) {
      if ( length === void 0 ) length = "long";
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale; if ( locale === void 0 ) locale = null;
      var numberingSystem = ref.numberingSystem; if ( numberingSystem === void 0 ) numberingSystem = null;
      var outputCalendar = ref.outputCalendar; if ( outputCalendar === void 0 ) outputCalendar = "gregory";

    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);
  };

  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {[string]}
   */
  Info.weekdays = function weekdays (length, ref) {
      if ( length === void 0 ) length = "long";
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale; if ( locale === void 0 ) locale = null;
      var numberingSystem = ref.numberingSystem; if ( numberingSystem === void 0 ) numberingSystem = null;

    return Locale.create(locale, numberingSystem, null).weekdays(length);
  };

  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @return {[string]}
   */
  Info.weekdaysFormat = function weekdaysFormat (length, ref) {
      if ( length === void 0 ) length = "long";
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale; if ( locale === void 0 ) locale = null;
      var numberingSystem = ref.numberingSystem; if ( numberingSystem === void 0 ) numberingSystem = null;

    return Locale.create(locale, numberingSystem, null).weekdays(length, true);
  };

  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {[string]}
   */
  Info.meridiems = function meridiems (ref) {
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale; if ( locale === void 0 ) locale = null;

    return Locale.create(locale).meridiems();
  };

  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {[string]}
   */
  Info.eras = function eras (length, ref) {
      if ( length === void 0 ) length = "short";
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale; if ( locale === void 0 ) locale = null;

    return Locale.create(locale, null, "gregory").eras(length);
  };

  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `zones`: whether this environment supports IANA timezones
   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing
   * * `intl`: whether this environment supports general internationalization
   * * `relative`: whether this environment supports relative time formatting
   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }
   * @return {Object}
   */
  Info.features = function features () {
    var intl = false,
      intlTokens = false,
      zones = false,
      relative = hasRelative();

    if (hasIntl()) {
      intl = true;
      intlTokens = hasFormatToParts();

      try {
        zones =
          new Intl.DateTimeFormat("en", { timeZone: "America/New_York" }).resolvedOptions()
            .timeZone === "America/New_York";
      } catch (e) {
        zones = false;
      }
    }

    return { intl: intl, intlTokens: intlTokens, zones: zones, relative: relative };
  };

  function dayDiff(earlier, later) {
    var utcDayStart = function (dt) { return dt
          .toUTC(0, { keepLocalTime: true })
          .startOf("day")
          .valueOf(); },
      ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  }

  function highOrderDiffs(cursor, later, units) {
    var obj, obj$1;

    var differs = [
      ["years", function (a, b) { return b.year - a.year; }],
      ["months", function (a, b) { return b.month - a.month + (b.year - a.year) * 12; }],
      [
        "weeks",
        function (a, b) {
          var days = dayDiff(a, b);
          return (days - (days % 7)) / 7;
        }
      ],
      ["days", dayDiff]
    ];

    var results = {};
    var lowestOrder, highWater;

    for (var i = 0, list = differs; i < list.length; i += 1) {
      var ref = list[i];
      var unit = ref[0];
      var differ = ref[1];

      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;

        var delta = differ(cursor, later);
        highWater = cursor.plus(( obj = {}, obj[unit] = delta, obj ));

        if (highWater > later) {
          cursor = cursor.plus(( obj$1 = {}, obj$1[unit] = delta - 1, obj$1 ));
          delta -= 1;
        } else {
          cursor = highWater;
        }

        results[unit] = delta;
      }
    }

    return [cursor, results, highWater, lowestOrder];
  }

  function diff(earlier, later, units, opts) {
    var obj, ref$1;

    var ref = highOrderDiffs(earlier, later, units);
    var cursor = ref[0];
    var results = ref[1];
    var highWater = ref[2];
    var lowestOrder = ref[3];

    var remainingMillis = later - cursor;

    var lowerOrderUnits = units.filter(
      function (u) { return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0; }
    );

    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus(( obj = {}, obj[lowestOrder] = 1, obj ));
      }

      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }

    var duration = Duration.fromObject(Object.assign(results, opts));

    if (lowerOrderUnits.length > 0) {
      return (ref$1 = Duration.fromMillis(remainingMillis, opts))
        .shiftTo.apply(ref$1, lowerOrderUnits)
        .plus(duration);
    } else {
      return duration;
    }
  }

  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };

  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };

  // eslint-disable-next-line
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");

  function parseDigits(str) {
    var value = parseInt(str, 10);
    if (isNaN(value)) {
      value = "";
      for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);

        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value += hanidecChars.indexOf(str[i]);
        } else {
          for (var key in numberingSystemsUTF16) {
            var ref = numberingSystemsUTF16[key];
            var min = ref[0];
            var max = ref[1];
            if (code >= min && code <= max) {
              value += code - min;
            }
          }
        }
      }
      return parseInt(value, 10);
    } else {
      return value;
    }
  }

  function digitRegex(ref, append) {
    var numberingSystem = ref.numberingSystem;
    if ( append === void 0 ) append = "";

    return new RegExp(("" + (numberingSystems[numberingSystem || "latn"]) + append));
  }

  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

  function intUnit(regex, post) {
    if ( post === void 0 ) post = function (i) { return i; };

    return { regex: regex, deser: function (ref) {
      var s = ref[0];

      return post(parseDigits(s));
    } };
  }

  function fixListRegex(s) {
    // make dots optional and also make them literal
    return s.replace(/\./, "\\.?");
  }

  function stripInsensitivities(s) {
    return s.replace(/\./, "").toLowerCase();
  }

  function oneOf(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: function (ref) {
            var s = ref[0];

            return strings.findIndex(function (i) { return stripInsensitivities(s) === stripInsensitivities(i); }) + startIndex;
      }
      };
    }
  }

  function offset(regex, groups) {
    return { regex: regex, deser: function (ref) {
      var h = ref[1];
      var m = ref[2];

      return signedOffset(h, m);
    }, groups: groups };
  }

  function simple(regex) {
    return { regex: regex, deser: function (ref) {
      var s = ref[0];

      return s;
    } };
  }

  function escapeToken(value) {
    // eslint-disable-next-line no-useless-escape
    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }

  function unitForToken(token, loc) {
    var one = digitRegex(loc),
      two = digitRegex(loc, "{2}"),
      three = digitRegex(loc, "{3}"),
      four = digitRegex(loc, "{4}"),
      six = digitRegex(loc, "{6}"),
      oneOrTwo = digitRegex(loc, "{1,2}"),
      oneToThree = digitRegex(loc, "{1,3}"),
      oneToSix = digitRegex(loc, "{1,6}"),
      oneToNine = digitRegex(loc, "{1,9}"),
      twoToFour = digitRegex(loc, "{2,4}"),
      fourToSix = digitRegex(loc, "{4,6}"),
      literal = function (t) { return ({ regex: RegExp(escapeToken(t.val)), deser: function (ref) {
        var s = ref[0];

        return s;
        }, literal: true }); },
      unitate = function (t) {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          // era
          case "G":
            return oneOf(loc.eras("short", false), 0);
          case "GG":
            return oneOf(loc.eras("long", false), 0);
          // years
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          // months
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true, false), 1);
          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false, false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          // dates
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          // ordinals
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          // time
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          // meridiem
          case "a":
            return oneOf(loc.meridiems(), 0);
          // weekYear (k)
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          // weekNumber (W)
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          // weekdays
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          // offset/zone
          case "Z":
          case "ZZ":
            return offset(new RegExp(("([+-]" + (oneOrTwo.source) + ")(?::(" + (two.source) + "))?")), 2);
          case "ZZZ":
            return offset(new RegExp(("([+-]" + (oneOrTwo.source) + ")(" + (two.source) + ")?")), 2);
          // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
          // because we don't have any way to figure out what they are
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          default:
            return literal(t);
        }
      };

    var unit = unitate(token) || {
      invalidReason: MISSING_FTP
    };

    unit.token = token;

    return unit;
  }

  function buildRegex(units) {
    var re = units.map(function (u) { return u.regex; }).reduce(function (f, r) { return (f + "(" + (r.source) + ")"); }, "");
    return [("^" + re + "$"), units];
  }

  function match(input, regex, handlers) {
    var matches = input.match(regex);

    if (matches) {
      var all = {};
      var matchIndex = 1;
      for (var i in handlers) {
        if (handlers.hasOwnProperty(i)) {
          var h = handlers[i],
            groups = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  }

  function dateTimeFromMatches(matches) {
    var toField = function (token) {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        default:
          return null;
      }
    };

    var zone;
    if (!isUndefined(matches.Z)) {
      zone = new FixedOffsetZone(matches.Z);
    } else if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    } else {
      zone = null;
    }

    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }

    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }

    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }

    var vals = Object.keys(matches).reduce(function (r, k) {
      var f = toField(k);
      if (f) {
        r[f] = matches[k];
      }

      return r;
    }, {});

    return [vals, zone];
  }

  /**
   * @private
   */

  function explainFromTokens(locale, input, format) {
    var tokens = Formatter.parseFormat(format),
      units = tokens.map(function (t) { return unitForToken(t, locale); }),
      disqualifyingUnit = units.find(function (t) { return t.invalidReason; });

    if (disqualifyingUnit) {
      return { input: input, tokens: tokens, invalidReason: disqualifyingUnit.invalidReason };
    } else {
      var ref = buildRegex(units);
      var regexString = ref[0];
      var handlers = ref[1];
      var regex = RegExp(regexString, "i");
      var ref$1 = match(input, regex, handlers);
      var rawMatches = ref$1[0];
      var matches = ref$1[1];
      var ref$2 = matches ? dateTimeFromMatches(matches) : [null, null];
      var result = ref$2[0];
      var zone = ref$2[1];

      return { input: input, tokens: tokens, regex: regex, rawMatches: rawMatches, matches: matches, result: result, zone: zone };
    }
  }

  function parseFromTokens(locale, input, format) {
    var ref = explainFromTokens(locale, input, format);
    var result = ref.result;
    var zone = ref.zone;
    var invalidReason = ref.invalidReason;
    return [result, zone, invalidReason];
  }

  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
    leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

  function unitOutOfRange(unit, value) {
    return new Invalid(
      "unit out of range",
      ("you specified " + value + " (of type " + (typeof value) + ") as a " + unit + ", which is invalid")
    );
  }

  function dayOfWeek(year, month, day) {
    var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
    return js === 0 ? 7 : js;
  }

  function computeOrdinal(year, month, day) {
    return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  }

  function uncomputeOrdinal(year, ordinal) {
    var table = isLeapYear(year) ? leapLadder : nonLeapLadder,
      month0 = table.findIndex(function (i) { return i < ordinal; }),
      day = ordinal - table[month0];
    return { month: month0 + 1, day: day };
  }

  /**
   * @private
   */

  function gregorianToWeek(gregObj) {
    var year = gregObj.year;
    var month = gregObj.month;
    var day = gregObj.day;
    var ordinal = computeOrdinal(year, month, day),
      weekday = dayOfWeek(year, month, day);

    var weekNumber = Math.floor((ordinal - weekday + 10) / 7),
      weekYear;

    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear);
    } else if (weekNumber > weeksInWeekYear(year)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }

    return Object.assign({ weekYear: weekYear, weekNumber: weekNumber, weekday: weekday }, timeObject(gregObj));
  }

  function weekToGregorian(weekData) {
    var weekYear = weekData.weekYear;
    var weekNumber = weekData.weekNumber;
    var weekday = weekData.weekday;
    var weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
      yearInDays = daysInYear(weekYear);

    var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
      year;

    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }

    var ref = uncomputeOrdinal(year, ordinal);
    var month = ref.month;
    var day = ref.day;

    return Object.assign({ year: year, month: month, day: day }, timeObject(weekData));
  }

  function gregorianToOrdinal(gregData) {
    var year = gregData.year;
    var month = gregData.month;
    var day = gregData.day;
    var ordinal = computeOrdinal(year, month, day);

    return Object.assign({ year: year, ordinal: ordinal }, timeObject(gregData));
  }

  function ordinalToGregorian(ordinalData) {
    var year = ordinalData.year;
    var ordinal = ordinalData.ordinal;
    var ref = uncomputeOrdinal(year, ordinal);
    var month = ref.month;
    var day = ref.day;

    return Object.assign({ year: year, month: month, day: day }, timeObject(ordinalData));
  }

  function hasInvalidWeekData(obj) {
    var validYear = isNumber(obj.weekYear),
      validWeek = numberBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
      validWeekday = numberBetween(obj.weekday, 1, 7);

    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.week);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else { return false; }
  }

  function hasInvalidOrdinalData(obj) {
    var validYear = isNumber(obj.year),
      validOrdinal = numberBetween(obj.ordinal, 1, daysInYear(obj.year));

    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else { return false; }
  }

  function hasInvalidGregorianData(obj) {
    var validYear = isNumber(obj.year),
      validMonth = numberBetween(obj.month, 1, 12),
      validDay = numberBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else { return false; }
  }

  function hasInvalidTimeData(obj) {
    var hour = obj.hour;
    var minute = obj.minute;
    var second = obj.second;
    var millisecond = obj.millisecond;
    var validHour =
        numberBetween(hour, 0, 23) ||
        (hour === 24 && minute === 0 && second === 0 && millisecond === 0),
      validMinute = numberBetween(minute, 0, 59),
      validSecond = numberBetween(second, 0, 59),
      validMillisecond = numberBetween(millisecond, 0, 999);

    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else { return false; }
  }

  var INVALID$2 = "Invalid DateTime";
  var MAX_DATE = 8.64e15;

  function unsupportedZone(zone) {
    return new Invalid("unsupported zone", ("the zone \"" + (zone.name) + "\" is not supported"));
  }

  // we cache week data on the DT object and this intermediates the cache
  function possiblyCachedWeekData(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  }

  // clone really means, "make a new object with these modifications". all "setters" really use this
  // to create a new object while only changing some of the properties
  function clone$1(inst, alts) {
    var current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime(Object.assign({}, current, alts, { old: current }));
  }

  // find the right offset a given local time. The o input is our guess, which determines which
  // offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)
  function fixOffset(localTS, o, tz) {
    // Our UTC time is just a guess because our offset is just a guess
    var utcGuess = localTS - o * 60 * 1000;

    // Test whether the zone matches the offset for this ts
    var o2 = tz.offset(utcGuess);

    // If so, offset didn't change and we're done
    if (o === o2) {
      return [utcGuess, o];
    }

    // If not, change the ts by the difference in the offset
    utcGuess -= (o2 - o) * 60 * 1000;

    // If that gives us the local time we want, we're done
    var o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }

    // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
    return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
  }

  // convert an epoch timestamp into a calendar object with the given offset
  function tsToObj(ts, offset) {
    ts += offset * 60 * 1000;

    var d = new Date(ts);

    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth() + 1,
      day: d.getUTCDate(),
      hour: d.getUTCHours(),
      minute: d.getUTCMinutes(),
      second: d.getUTCSeconds(),
      millisecond: d.getUTCMilliseconds()
    };
  }

  // convert a calendar object to a epoch timestamp
  function objToTS(obj, offset, zone) {
    return fixOffset(objToLocalTS(obj), offset, zone);
  }

  // create a new DT instance by adding a duration, adjusting for DSTs
  function adjustTime(inst, dur) {
    var oPre = inst.o,
      year = inst.c.year + dur.years,
      month = inst.c.month + dur.months + dur.quarters * 3,
      c = Object.assign({}, inst.c, {
        year: year,
        month: month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + dur.days + dur.weeks * 7
      }),
      millisToAdd = Duration.fromObject({
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"),
      localTS = objToLocalTS(c);

    var ref = fixOffset(localTS, oPre, inst.zone);
    var ts = ref[0];
    var o = ref[1];

    if (millisToAdd !== 0) {
      ts += millisToAdd;
      // that could have changed the offset by going over a DST, but we want to keep the ts the same
      o = inst.zone.offset(ts);
    }

    return { ts: ts, o: o };
  }

  // helper useful in turning the results of parsing into real dates
  // by handling the zone options
  function parseDataToDateTime(parsed, parsedZone, opts, format, text) {
    var setZone = opts.setZone;
    var zone = opts.zone;
    if (parsed && Object.keys(parsed).length !== 0) {
      var interpretationZone = parsedZone || zone,
        inst = DateTime.fromObject(
          Object.assign(parsed, opts, {
            zone: interpretationZone,
            // setZone is a valid option in the calling methods, but not in fromObject
            setZone: undefined
          })
        );
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(
        new Invalid("unparsable", ("the input \"" + text + "\" can't be parsed as " + format))
      );
    }
  }

  // if you want to output a technical format (e.g. RFC 2822), this helper
  // helps handle the details
  function toTechFormat(dt, format) {
    return dt.isValid
      ? Formatter.create(Locale.create("en-US"), {
          allowZ: true,
          forceSimple: true
        }).formatDateTimeFromString(dt, format)
      : null;
  }

  // technical time formats (e.g. the time part of ISO 8601), take some options
  // and this commonizes their handling
  function toTechTimeFormat(
    dt,
    ref
  ) {
    var suppressSeconds = ref.suppressSeconds; if ( suppressSeconds === void 0 ) suppressSeconds = false;
    var suppressMilliseconds = ref.suppressMilliseconds; if ( suppressMilliseconds === void 0 ) suppressMilliseconds = false;
    var includeOffset = ref.includeOffset;
    var includeZone = ref.includeZone; if ( includeZone === void 0 ) includeZone = false;
    var spaceZone = ref.spaceZone; if ( spaceZone === void 0 ) spaceZone = false;

    var fmt = "HH:mm";

    if (!suppressSeconds || dt.second !== 0 || dt.millisecond !== 0) {
      fmt += ":ss";
      if (!suppressMilliseconds || dt.millisecond !== 0) {
        fmt += ".SSS";
      }
    }

    if ((includeZone || includeOffset) && spaceZone) {
      fmt += " ";
    }

    if (includeZone) {
      fmt += "z";
    } else if (includeOffset) {
      fmt += "ZZ";
    }

    return toTechFormat(dt, fmt);
  }

  // defaults for unspecified units in the supported calendars
  var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    },
    defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    },
    defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };

  // Units in the supported calendars, sorted by bigness
  var orderedUnits$1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
    orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ],
    orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

  // standardize case and plurality in units
  function normalizeUnit(unit) {
    var normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];

    if (!normalized) { throw new InvalidUnitError(unit); }

    return normalized;
  }

  // this is a dumbed down version of fromObject() that runs about 60% faster
  // but doesn't do any validation, makes a bunch of assumptions about what units
  // are present, and so on.
  function quickDT(obj, zone) {
    // assume we have the higher-order units
    for (var i = 0, list = orderedUnits$1; i < list.length; i += 1) {
      var u = list[i];

      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }

    var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }

    var tsNow = Settings.now(),
      offsetProvis = zone.offset(tsNow);
    var ref = objToTS(obj, offsetProvis, zone);
    var ts = ref[0];
    var o = ref[1];

    return new DateTime({
      ts: ts,
      zone: zone,
      o: o
    });
  }

  function diffRelative(start, end, opts) {
    var round = isUndefined(opts.round) ? true : opts.round,
      format = function (c, unit) {
        c = roundTo(c, round || opts.calendary ? 0 : 2, true);
        var formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      },
      differ = function (unit) {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end
              .startOf(unit)
              .diff(start.startOf(unit), unit)
              .get(unit);
          } else { return 0; }
        } else {
          return end.diff(start, unit).get(unit);
        }
      };

    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }

    for (var i = 0, list = opts.units; i < list.length; i += 1) {
      var unit = list[i];

      var count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(0, opts.units[opts.units.length - 1]);
  }

  /**
   * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
   *
   * A DateTime comprises of:
   * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
   * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
   * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
   *
   * Here is a brief overview of the most commonly used functionality it provides:
   *
   * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link local}, {@link utc}, and (most flexibly) {@link fromObject}. To create one from a standard string format, use {@link fromISO}, {@link fromHTTP}, and {@link fromRFC2822}. To create one from a custom string format, use {@link fromFormat}. To create one from a native JS date, use {@link fromJSDate}.
   * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link toObject}), use the {@link year}, {@link month},
   * {@link day}, {@link hour}, {@link minute}, {@link second}, {@link millisecond} accessors.
   * * **Week calendar**: For ISO week calendar attributes, see the {@link weekYear}, {@link weekNumber}, and {@link weekday} accessors.
   * * **Configuration** See the {@link locale} and {@link numberingSystem} accessors.
   * * **Transformation**: To transform the DateTime into other DateTimes, use {@link set}, {@link reconfigure}, {@link setZone}, {@link setLocale}, {@link plus}, {@link minus}, {@link endOf}, {@link startOf}, {@link toUTC}, and {@link toLocal}.
   * * **Output**: To convert the DateTime to other representations, use the {@link toRelative}, {@link toRelativeCalendar}, {@link toJSON}, {@link toISO}, {@link toHTTP}, {@link toObject}, {@link toRFC2822}, {@link toString}, {@link toLocaleString}, {@link toFormat}, {@link toMillis} and {@link toJSDate}.
   *
   * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
   */
  var DateTime = function DateTime(config) {
    var zone = config.zone || Settings.defaultZone,
      invalid =
        config.invalid ||
        (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) ||
        (!zone.isValid ? unsupportedZone(zone) : null);
    /**
     * @access private
     */
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;

    var c = null,
      o = null;
    if (!invalid) {
      var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      c = unchanged ? config.old.c : tsToObj(this.ts, zone.offset(this.ts));
      o = unchanged ? config.old.o : zone.offset(this.ts);
    }

    /**
     * @access private
     */
    this._zone = zone;
    /**
     * @access private
     */
    this.loc = config.loc || Locale.create();
    /**
     * @access private
     */
    this.invalid = invalid;
    /**
     * @access private
     */
    this.weekData = null;
    /**
     * @access private
     */
    this.c = c;
    /**
     * @access private
     */
    this.o = o;
    /**
     * @access private
     */
    this.isLuxonDateTime = true;
  };

  var prototypeAccessors$4 = { isValid: { configurable: true },invalidReason: { configurable: true },invalidExplanation: { configurable: true },locale: { configurable: true },numberingSystem: { configurable: true },outputCalendar: { configurable: true },zone: { configurable: true },zoneName: { configurable: true },year: { configurable: true },quarter: { configurable: true },month: { configurable: true },day: { configurable: true },hour: { configurable: true },minute: { configurable: true },second: { configurable: true },millisecond: { configurable: true },weekYear: { configurable: true },weekNumber: { configurable: true },weekday: { configurable: true },ordinal: { configurable: true },monthShort: { configurable: true },monthLong: { configurable: true },weekdayShort: { configurable: true },weekdayLong: { configurable: true },offset: { configurable: true },offsetNameShort: { configurable: true },offsetNameLong: { configurable: true },isOffsetFixed: { configurable: true },isInDST: { configurable: true },isInLeapYear: { configurable: true },daysInMonth: { configurable: true },daysInYear: { configurable: true },weeksInWeekYear: { configurable: true } };
  var staticAccessors$1 = { DATE_SHORT: { configurable: true },DATE_MED: { configurable: true },DATE_FULL: { configurable: true },DATE_HUGE: { configurable: true },TIME_SIMPLE: { configurable: true },TIME_WITH_SECONDS: { configurable: true },TIME_WITH_SHORT_OFFSET: { configurable: true },TIME_WITH_LONG_OFFSET: { configurable: true },TIME_24_SIMPLE: { configurable: true },TIME_24_WITH_SECONDS: { configurable: true },TIME_24_WITH_SHORT_OFFSET: { configurable: true },TIME_24_WITH_LONG_OFFSET: { configurable: true },DATETIME_SHORT: { configurable: true },DATETIME_SHORT_WITH_SECONDS: { configurable: true },DATETIME_MED: { configurable: true },DATETIME_MED_WITH_SECONDS: { configurable: true },DATETIME_MED_WITH_WEEKDAY: { configurable: true },DATETIME_FULL: { configurable: true },DATETIME_FULL_WITH_SECONDS: { configurable: true },DATETIME_HUGE: { configurable: true },DATETIME_HUGE_WITH_SECONDS: { configurable: true } };

  // CONSTRUCT

  /**
   * Create a local DateTime
   * @param {number} year - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, i.e. a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, i.e. a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, i.e. a number between 0 and 999
   * @example DateTime.local()                          //~> now
   * @example DateTime.local(2017)                      //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                   //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12)               //~> 2017-03-12T00:00:00
   * @example DateTime.local(2017, 3, 12, 5)            //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, 45)        //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)    //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  DateTime.local = function local (year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({ ts: Settings.now() });
    } else {
      return quickDT(
        {
          year: year,
          month: month,
          day: day,
          hour: hour,
          minute: minute,
          second: second,
          millisecond: millisecond
        },
        Settings.defaultZone
      );
    }
  };

  /**
   * Create a DateTime in UTC
   * @param {number} year - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, i.e. a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, i.e. a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, i.e. a number between 0 and 999
   * @example DateTime.utc()                          //~> now
   * @example DateTime.utc(2017)                      //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                   //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)               //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)            //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)        //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)    //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765) //~> 2017-03-12T05:45:10.765Z
   * @return {DateTime}
   */
  DateTime.utc = function utc (year, month, day, hour, minute, second, millisecond) {
    if (isUndefined(year)) {
      return new DateTime({
        ts: Settings.now(),
        zone: FixedOffsetZone.utcInstance
      });
    } else {
      return quickDT(
        {
          year: year,
          month: month,
          day: day,
          hour: hour,
          minute: minute,
          second: second,
          millisecond: millisecond
        },
        FixedOffsetZone.utcInstance
      );
    }
  };

  /**
   * Create a DateTime from a Javascript Date object. Uses the default zone.
   * @param {Date} date - a Javascript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  DateTime.fromJSDate = function fromJSDate (date, options) {
      if ( options === void 0 ) options = {};

    var ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }

    var zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    return new DateTime({
      ts: ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  };

  /**
   * Create a DateTime from a number of milliseconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  DateTime.fromMillis = function fromMillis (milliseconds, options) {
      if ( options === void 0 ) options = {};

    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError("fromMillis requires a numerical input");
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  };

  /**
   * Create a DateTime from a number of seconds since the epoch (i.e. since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  DateTime.fromSeconds = function fromSeconds (seconds, options) {
      if ( options === void 0 ) options = {};

    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1000,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  };

  /**
   * Create a DateTime from a Javascript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {string|Zone} [obj.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [obj.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} obj.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} obj.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6, zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @return {DateTime}
   */
  DateTime.fromObject = function fromObject (obj) {
    var zoneToUse = normalizeZone(obj.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }

    var tsNow = Settings.now(),
      offsetProvis = zoneToUse.offset(tsNow),
      normalized = normalizeObject(obj, normalizeUnit, [
        "zone",
        "locale",
        "outputCalendar",
        "numberingSystem"
      ]),
      containsOrdinal = !isUndefined(normalized.ordinal),
      containsGregorYear = !isUndefined(normalized.year),
      containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
      containsGregor = containsGregorYear || containsGregorMD,
      definiteWeekDef = normalized.weekYear || normalized.weekNumber,
      loc = Locale.fromObject(obj);

    // cases:
    // just a weekday -> this week's instance of that weekday, no worries
    // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
    // (gregorian month or day) + ordinal -> error
    // otherwise just use weeks or ordinals or gregorian, depending on what's specified

    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }

    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }

    var useWeekData = definiteWeekDef || (normalized.weekday && !containsGregor);

    // configure ourselves to deal with gregorian dates or week stuff
    var units,
      defaultValues,
      objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits$1;
      defaultValues = defaultUnitValues;
    }

    // set default values for missing stuff
    var foundFirst = false;
    for (var i = 0, list = units; i < list.length; i += 1) {
      var u = list[i];

        var v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }

    // make sure the values we have are in range
    var higherOrderInvalid = useWeekData
        ? hasInvalidWeekData(normalized)
        : containsOrdinal
          ? hasInvalidOrdinalData(normalized)
          : hasInvalidGregorianData(normalized),
      invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

    if (invalid) {
      return DateTime.invalid(invalid);
    }

    // compute the actual time
    var gregorian = useWeekData
        ? weekToGregorian(normalized)
        : containsOrdinal
          ? ordinalToGregorian(normalized)
          : normalized;
      var ref = objToTS(gregorian, offsetProvis, zoneToUse);
      var tsFinal = ref[0];
      var offsetFinal = ref[1];
      var inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc: loc
      });

    // gregorian data + weekday serves only to validate
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        ("you can't specify both a weekday of " + (normalized.weekday) + " and a date of " + (inst.toISO()))
      );
    }

    return inst;
  };

  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  DateTime.fromISO = function fromISO (text, opts) {
      if ( opts === void 0 ) opts = {};

    var ref = parseISODate(text);
      var vals = ref[0];
      var parsedZone = ref[1];
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  };

  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  DateTime.fromRFC2822 = function fromRFC2822 (text, opts) {
      if ( opts === void 0 ) opts = {};

    var ref = parseRFC2822Date(text);
      var vals = ref[0];
      var parsedZone = ref[1];
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  };

  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov6 08:49:37 1994')
   * @return {DateTime}
   */
  DateTime.fromHTTP = function fromHTTP (text, opts) {
      if ( opts === void 0 ) opts = {};

    var ref = parseHTTPDate(text);
      var vals = ref[0];
      var parsedZone = ref[1];
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  };

  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/parsing.html#table-of-tokens
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  DateTime.fromFormat = function fromFormat (text, fmt, opts) {
      if ( opts === void 0 ) opts = {};

    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }

    var locale = opts.locale; if ( locale === void 0 ) locale = null;
      var numberingSystem = opts.numberingSystem; if ( numberingSystem === void 0 ) numberingSystem = null;
      var localeToUse = Locale.fromOpts({
        locale: locale,
        numberingSystem: numberingSystem,
        defaultToEN: true
      });
      var ref = parseFromTokens(localeToUse, text, fmt);
      var vals = ref[0];
      var parsedZone = ref[1];
      var invalid = ref[2];
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, ("format " + fmt), text);
    }
  };

  /**
   * @deprecated use fromFormat instead
   */
  DateTime.fromString = function fromString (text, fmt, opts) {
      if ( opts === void 0 ) opts = {};

    return DateTime.fromFormat(text, fmt, opts);
  };

  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  DateTime.fromSQL = function fromSQL (text, opts) {
      if ( opts === void 0 ) opts = {};

    var ref = parseSQL(text);
      var vals = ref[0];
      var parsedZone = ref[1];
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  };

  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  DateTime.invalid = function invalid (reason, explanation) {
      if ( explanation === void 0 ) explanation = null;

    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }

    var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid: invalid });
    }
  };

  /**
   * Check if an object is a DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  DateTime.isDateTime = function isDateTime (o) {
    return (o && o.isLuxonDateTime) || false;
  };

  // INFO

  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  DateTime.prototype.get = function get (unit) {
    return this[unit];
  };

  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  prototypeAccessors$4.isValid.get = function () {
    return this.invalid === null;
  };

  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  prototypeAccessors$4.invalidReason.get = function () {
    return this.invalid ? this.invalid.reason : null;
  };

  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  prototypeAccessors$4.invalidExplanation.get = function () {
    return this.invalid ? this.invalid.explanation : null;
  };

  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  prototypeAccessors$4.locale.get = function () {
    return this.isValid ? this.loc.locale : null;
  };

  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  prototypeAccessors$4.numberingSystem.get = function () {
    return this.isValid ? this.loc.numberingSystem : null;
  };

  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  prototypeAccessors$4.outputCalendar.get = function () {
    return this.isValid ? this.loc.outputCalendar : null;
  };

  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  prototypeAccessors$4.zone.get = function () {
    return this._zone;
  };

  /**
   * Get the name of the time zone.
   * @type {string}
   */
  prototypeAccessors$4.zoneName.get = function () {
    return this.isValid ? this.zone.name : null;
  };

  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  prototypeAccessors$4.year.get = function () {
    return this.isValid ? this.c.year : NaN;
  };

  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  prototypeAccessors$4.quarter.get = function () {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  };

  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  prototypeAccessors$4.month.get = function () {
    return this.isValid ? this.c.month : NaN;
  };

  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  prototypeAccessors$4.day.get = function () {
    return this.isValid ? this.c.day : NaN;
  };

  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  prototypeAccessors$4.hour.get = function () {
    return this.isValid ? this.c.hour : NaN;
  };

  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  prototypeAccessors$4.minute.get = function () {
    return this.isValid ? this.c.minute : NaN;
  };

  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  prototypeAccessors$4.second.get = function () {
    return this.isValid ? this.c.second : NaN;
  };

  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  prototypeAccessors$4.millisecond.get = function () {
    return this.isValid ? this.c.millisecond : NaN;
  };

  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekYear //=> 2015
   * @type {number}
   */
  prototypeAccessors$4.weekYear.get = function () {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  };

  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  prototypeAccessors$4.weekNumber.get = function () {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  };

  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  prototypeAccessors$4.weekday.get = function () {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  };

  /**
   * Get the ordinal (i.e. the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  prototypeAccessors$4.ordinal.get = function () {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  };

  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  prototypeAccessors$4.monthShort.get = function () {
    return this.isValid ? Info.months("short", { locale: this.locale })[this.month - 1] : null;
  };

  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  prototypeAccessors$4.monthLong.get = function () {
    return this.isValid ? Info.months("long", { locale: this.locale })[this.month - 1] : null;
  };

  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  prototypeAccessors$4.weekdayShort.get = function () {
    return this.isValid ? Info.weekdays("short", { locale: this.locale })[this.weekday - 1] : null;
  };

  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  prototypeAccessors$4.weekdayLong.get = function () {
    return this.isValid ? Info.weekdays("long", { locale: this.locale })[this.weekday - 1] : null;
  };

  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.local().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  prototypeAccessors$4.offset.get = function () {
    return this.isValid ? this.zone.offset(this.ts) : NaN;
  };

  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  prototypeAccessors$4.offsetNameShort.get = function () {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  };

  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  prototypeAccessors$4.offsetNameLong.get = function () {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  };

  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  prototypeAccessors$4.isOffsetFixed.get = function () {
    return this.isValid ? this.zone.universal : null;
  };

  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  prototypeAccessors$4.isInDST.get = function () {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return (
        this.offset > this.set({ month: 1 }).offset || this.offset > this.set({ month: 5 }).offset
      );
    }
  };

  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  prototypeAccessors$4.isInLeapYear.get = function () {
    return isLeapYear(this.year);
  };

  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  prototypeAccessors$4.daysInMonth.get = function () {
    return daysInMonth(this.year, this.month);
  };

  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  prototypeAccessors$4.daysInYear.get = function () {
    return this.isValid ? daysInYear(this.year) : NaN;
  };

  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  prototypeAccessors$4.weeksInWeekYear.get = function () {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  };

  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  DateTime.prototype.resolvedLocaleOpts = function resolvedLocaleOpts (opts) {
      if ( opts === void 0 ) opts = {};

    var ref = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
      var locale = ref.locale;
      var numberingSystem = ref.numberingSystem;
      var calendar = ref.calendar;
    return { locale: locale, numberingSystem: numberingSystem, outputCalendar: calendar };
  };

  // TRANSFORM

  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  DateTime.prototype.toUTC = function toUTC (offset, opts) {
      if ( offset === void 0 ) offset = 0;
      if ( opts === void 0 ) opts = {};

    return this.setZone(FixedOffsetZone.instance(offset), opts);
  };

  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  DateTime.prototype.toLocal = function toLocal () {
    return this.setZone(Settings.defaultZone);
  };

  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link plus}. You may wish to use {@link toLocal} and {@link toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  DateTime.prototype.setZone = function setZone (zone, ref) {
      var assign;

      if ( ref === void 0 ) ref = {};
      var keepLocalTime = ref.keepLocalTime; if ( keepLocalTime === void 0 ) keepLocalTime = false;
      var keepCalendarTime = ref.keepCalendarTime; if ( keepCalendarTime === void 0 ) keepCalendarTime = false;
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      var newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        var offsetGuess = this.o - zone.offset(this.ts);
        var asObj = this.toObject();
        (assign = objToTS(asObj, offsetGuess, zone), newTS = assign[0]);
      }
      return clone$1(this, { ts: newTS, zone: zone });
    }
  };

  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  DateTime.prototype.reconfigure = function reconfigure (ref) {
      if ( ref === void 0 ) ref = {};
      var locale = ref.locale;
      var numberingSystem = ref.numberingSystem;
      var outputCalendar = ref.outputCalendar;

    var loc = this.loc.clone({ locale: locale, numberingSystem: numberingSystem, outputCalendar: outputCalendar });
    return clone$1(this, { loc: loc });
  };

  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  DateTime.prototype.setLocale = function setLocale (locale) {
    return this.reconfigure({ locale: locale });
  };

  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link reconfigure} and {@link setZone}.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  DateTime.prototype.set = function set (values) {
    if (!this.isValid) { return this; }

    var normalized = normalizeObject(values, normalizeUnit, []),
      settingWeekStuff =
        !isUndefined(normalized.weekYear) ||
        !isUndefined(normalized.weekNumber) ||
        !isUndefined(normalized.weekday);

    var mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(Object.assign(gregorianToWeek(this.c), normalized));
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian(Object.assign(gregorianToOrdinal(this.c), normalized));
    } else {
      mixed = Object.assign(this.toObject(), normalized);

      // if we didn't set the day but we ended up on an overflow date,
      // use the last day of the right month
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }

    var ref = objToTS(mixed, this.o, this.zone);
      var ts = ref[0];
      var o = ref[1];
    return clone$1(this, { ts: ts, o: o });
  };

  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.local().plus(123) //~> in 123 milliseconds
   * @example DateTime.local().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.local().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.local().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.local().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.local().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  DateTime.prototype.plus = function plus (duration) {
    if (!this.isValid) { return this; }
    var dur = friendlyDuration(duration);
    return clone$1(this, adjustTime(this, dur));
  };

  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
  */
  DateTime.prototype.minus = function minus (duration) {
    if (!this.isValid) { return this; }
    var dur = friendlyDuration(duration).negate();
    return clone$1(this, adjustTime(this, dur));
  };

  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  DateTime.prototype.startOf = function startOf (unit) {
    if (!this.isValid) { return this; }
    var o = {},
      normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      // falls through
      case "quarters":
      case "months":
        o.day = 1;
      // falls through
      case "weeks":
      case "days":
        o.hour = 0;
      // falls through
      case "hours":
        o.minute = 0;
      // falls through
      case "minutes":
        o.second = 0;
      // falls through
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
      // no default, invalid units throw in normalizeUnit()
    }

    if (normalizedUnit === "weeks") {
      o.weekday = 1;
    }

    if (normalizedUnit === "quarters") {
      var q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }

    return this.set(o);
  };

  /**
   * "Set" this DateTime to the end (i.e. the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'month', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  DateTime.prototype.endOf = function endOf (unit) {
      var obj;

    return this.isValid
      ? this.plus(( obj = {}, obj[unit] = 1, obj ))
          .startOf(unit)
          .minus(1)
      : this;
  };

  // OUTPUT

  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @see https://moment.github.io/luxon/docs/manual/formatting.html#table-of-tokens
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options
   * @example DateTime.local().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.local().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.local().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.local().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  DateTime.prototype.toFormat = function toFormat (fmt, opts) {
      if ( opts === void 0 ) opts = {};

    return this.isValid
      ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt)
      : INVALID$2;
  };

  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param opts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @example DateTime.local().toLocaleString(); //=> 4/20/2017
   * @example DateTime.local().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.local().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
   * @example DateTime.local().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.local().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.local().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.local().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.local().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.local().toLocaleString({ hour: '2-digit', minute: '2-digit', hour12: false }); //=> '11:32'
   * @return {string}
   */
  DateTime.prototype.toLocaleString = function toLocaleString (opts) {
      if ( opts === void 0 ) opts = DATE_SHORT;

    return this.isValid
      ? Formatter.create(this.loc.clone(opts), opts).formatDateTime(this)
      : INVALID$2;
  };

  /**
   * Returns an array of format "parts", i.e. individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.local().toLocaleString(); //=> [
   *                                  //=> { type: 'day', value: '25' },
   *                                  //=> { type: 'literal', value: '/' },
   *                                  //=> { type: 'month', value: '05' },
   *                                  //=> { type: 'literal', value: '/' },
   *                                  //=> { type: 'year', value: '1982' }
   *                                  //=> ]
   */
  DateTime.prototype.toLocaleParts = function toLocaleParts (opts) {
      if ( opts === void 0 ) opts = {};

    return this.isValid
      ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this)
      : [];
  };

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc(1982, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.local().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.local().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @return {string}
   */
  DateTime.prototype.toISO = function toISO (opts) {
      if ( opts === void 0 ) opts = {};

    if (!this.isValid) {
      return null;
    }

    return ((this.toISODate()) + "T" + (this.toISOTime(opts)));
  };

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @return {string}
   */
  DateTime.prototype.toISODate = function toISODate () {
    var format = "yyyy-MM-dd";
    if (this.year > 9999) {
      format = "+" + format;
    }

    return toTechFormat(this, format);
  };

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  DateTime.prototype.toISOWeekDate = function toISOWeekDate () {
    return toTechFormat(this, "kkkk-'W'WW-c");
  };

  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc().hour(7).minute(34).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().hour(7).minute(34).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @return {string}
   */
  DateTime.prototype.toISOTime = function toISOTime (ref) {
      if ( ref === void 0 ) ref = {};
      var suppressMilliseconds = ref.suppressMilliseconds; if ( suppressMilliseconds === void 0 ) suppressMilliseconds = false;
      var suppressSeconds = ref.suppressSeconds; if ( suppressSeconds === void 0 ) suppressSeconds = false;
      var includeOffset = ref.includeOffset; if ( includeOffset === void 0 ) includeOffset = true;

    return toTechTimeFormat(this, {
      suppressSeconds: suppressSeconds,
      suppressMilliseconds: suppressMilliseconds,
      includeOffset: includeOffset
    });
  };

  /**
   * Returns an RFC 2822-compatible string representation of this DateTime, always in UTC
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  DateTime.prototype.toRFC2822 = function toRFC2822 () {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ");
  };

  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  DateTime.prototype.toHTTP = function toHTTP () {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  };

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  DateTime.prototype.toSQLDate = function toSQLDate () {
    return toTechFormat(this, "yyyy-MM-dd");
  };

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.local().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.local().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.local().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  DateTime.prototype.toSQLTime = function toSQLTime (ref) {
      if ( ref === void 0 ) ref = {};
      var includeOffset = ref.includeOffset; if ( includeOffset === void 0 ) includeOffset = true;
      var includeZone = ref.includeZone; if ( includeZone === void 0 ) includeZone = false;

    return toTechTimeFormat(this, {
      includeOffset: includeOffset,
      includeZone: includeZone,
      spaceZone: true
    });
  };

  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  DateTime.prototype.toSQL = function toSQL (opts) {
      if ( opts === void 0 ) opts = {};

    if (!this.isValid) {
      return null;
    }

    return ((this.toSQLDate()) + " " + (this.toSQLTime(opts)));
  };

  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  DateTime.prototype.toString = function toString () {
    return this.isValid ? this.toISO() : INVALID$2;
  };

  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link toMillis}
   * @return {number}
   */
  DateTime.prototype.valueOf = function valueOf () {
    return this.toMillis();
  };

  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  DateTime.prototype.toMillis = function toMillis () {
    return this.isValid ? this.ts : NaN;
  };

  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  DateTime.prototype.toSeconds = function toSeconds () {
    return this.isValid ? this.ts / 1000 : NaN;
  };

  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  DateTime.prototype.toJSON = function toJSON () {
    return this.toISO();
  };

  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  DateTime.prototype.toBSON = function toBSON () {
    return this.toJSDate();
  };

  /**
   * Returns a Javascript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.local().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  DateTime.prototype.toObject = function toObject (opts) {
      if ( opts === void 0 ) opts = {};

    if (!this.isValid) { return {}; }

    var base = Object.assign({}, this.c);

    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  };

  /**
   * Returns a Javascript Date equivalent to this DateTime.
   * @return {Date}
   */
  DateTime.prototype.toJSDate = function toJSDate () {
    return new Date(this.isValid ? this.ts : NaN);
  };

  // COMPARE

  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *   i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  DateTime.prototype.diff = function diff$1 (otherDateTime, unit, opts) {
      if ( unit === void 0 ) unit = "milliseconds";
      if ( opts === void 0 ) opts = {};

    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid(
        this.invalid || otherDateTime.invalid,
        "created by diffing an invalid DateTime"
      );
    }

    var durOpts = Object.assign(
      { locale: this.locale, numberingSystem: this.numberingSystem },
      opts
    );

    var units = maybeArray(unit).map(Duration.normalizeUnit),
      otherIsLater = otherDateTime.valueOf() > this.valueOf(),
      earlier = otherIsLater ? this : otherDateTime,
      later = otherIsLater ? otherDateTime : this,
      diffed = diff(earlier, later, units, durOpts);

    return otherIsLater ? diffed.negate() : diffed;
  };

  /**
   * Return the difference between this DateTime and right now.
   * See {@link diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  DateTime.prototype.diffNow = function diffNow (unit, opts) {
      if ( unit === void 0 ) unit = "milliseconds";
      if ( opts === void 0 ) opts = {};

    return this.diff(DateTime.local(), unit, opts);
  };

  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  DateTime.prototype.until = function until (otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  };

  /**
   * Return whether this DateTime is in the same unit of time as another DateTime
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @example DateTime.local().hasSame(otherDT, 'day'); //~> true if both the same calendar day
   * @return {boolean}
   */
  DateTime.prototype.hasSame = function hasSame (otherDateTime, unit) {
    if (!this.isValid) { return false; }
    if (unit === "millisecond") {
      return this.valueOf() === otherDateTime.valueOf();
    } else {
      var inputMs = otherDateTime.valueOf();
      return this.startOf(unit) <= inputMs && inputMs <= this.endOf(unit);
    }
  };

  /**
   * Equality check
   * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === ~dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  DateTime.prototype.equals = function equals (other) {
    return (
      this.isValid &&
      other.isValid &&
      this.valueOf() === other.valueOf() &&
      this.zone.equals(other.zone) &&
      this.loc.equals(other.loc)
    );
  };

  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeDateFormat, **which it probably doesn't yet!** (As of this writing, only Chrome supports that). Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {boolean} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.local().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.local().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.local().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.local().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.local().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.local().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  DateTime.prototype.toRelative = function toRelative (options) {
      if ( options === void 0 ) options = {};

    if (!this.isValid) { return null; }
    var base = options.base || DateTime.fromObject({ zone: this.zone }),
      padding = options.padding ? (this < base ? -options.padding : options.padding) : 0;
    return diffRelative(
      base,
      this.plus(padding),
      Object.assign(options, {
        numeric: "always",
        units: ["years", "months", "days", "hours", "minutes", "seconds"]
      })
    );
  };

  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month"
   * platform supports Intl.RelativeDateFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.local()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.local().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.local().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.local().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  DateTime.prototype.toRelativeCalendar = function toRelativeCalendar (options) {
      if ( options === void 0 ) options = {};

    if (!this.isValid) { return null; }

    return diffRelative(
      options.base || DateTime.fromObject({ zone: this.zone }),
      this,
      Object.assign(options, {
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      })
    );
  };

  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  DateTime.min = function min () {
      var dateTimes = [], len = arguments.length;
      while ( len-- ) dateTimes[ len ] = arguments[ len ];

    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, function (i) { return i.valueOf(); }, Math.min);
  };

  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  DateTime.max = function max () {
      var dateTimes = [], len = arguments.length;
      while ( len-- ) dateTimes[ len ] = arguments[ len ];

    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, function (i) { return i.valueOf(); }, Math.max);
  };

  // MISC

  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  DateTime.fromFormatExplain = function fromFormatExplain (text, fmt, options) {
      if ( options === void 0 ) options = {};

    var locale = options.locale; if ( locale === void 0 ) locale = null;
      var numberingSystem = options.numberingSystem; if ( numberingSystem === void 0 ) numberingSystem = null;
      var localeToUse = Locale.fromOpts({
        locale: locale,
        numberingSystem: numberingSystem,
        defaultToEN: true
      });
    return explainFromTokens(localeToUse, text, fmt);
  };

  /**
   * @deprecated use fromFormatExplain instead
   */
  DateTime.fromStringExplain = function fromStringExplain (text, fmt, options) {
      if ( options === void 0 ) options = {};

    return DateTime.fromFormatExplain(text, fmt, options);
  };

  // FORMAT PRESETS

  /**
   * {@link toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  staticAccessors$1.DATE_SHORT.get = function () {
    return DATE_SHORT;
  };

  /**
   * {@link toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  staticAccessors$1.DATE_MED.get = function () {
    return DATE_MED;
  };

  /**
   * {@link toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  staticAccessors$1.DATE_FULL.get = function () {
    return DATE_FULL;
  };

  /**
   * {@link toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  staticAccessors$1.DATE_HUGE.get = function () {
    return DATE_HUGE;
  };

  /**
   * {@link toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.TIME_SIMPLE.get = function () {
    return TIME_SIMPLE;
  };

  /**
   * {@link toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.TIME_WITH_SECONDS.get = function () {
    return TIME_WITH_SECONDS;
  };

  /**
   * {@link toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.TIME_WITH_SHORT_OFFSET.get = function () {
    return TIME_WITH_SHORT_OFFSET;
  };

  /**
   * {@link toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.TIME_WITH_LONG_OFFSET.get = function () {
    return TIME_WITH_LONG_OFFSET;
  };

  /**
   * {@link toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  staticAccessors$1.TIME_24_SIMPLE.get = function () {
    return TIME_24_SIMPLE;
  };

  /**
   * {@link toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  staticAccessors$1.TIME_24_WITH_SECONDS.get = function () {
    return TIME_24_WITH_SECONDS;
  };

  /**
   * {@link toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  staticAccessors$1.TIME_24_WITH_SHORT_OFFSET.get = function () {
    return TIME_24_WITH_SHORT_OFFSET;
  };

  /**
   * {@link toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  staticAccessors$1.TIME_24_WITH_LONG_OFFSET.get = function () {
    return TIME_24_WITH_LONG_OFFSET;
  };

  /**
   * {@link toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_SHORT.get = function () {
    return DATETIME_SHORT;
  };

  /**
   * {@link toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_SHORT_WITH_SECONDS.get = function () {
    return DATETIME_SHORT_WITH_SECONDS;
  };

  /**
   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_MED.get = function () {
    return DATETIME_MED;
  };

  /**
   * {@link toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_MED_WITH_SECONDS.get = function () {
    return DATETIME_MED_WITH_SECONDS;
  };

  /**
   * {@link toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_MED_WITH_WEEKDAY.get = function () {
    return DATETIME_MED_WITH_WEEKDAY;
  };

  /**
   * {@link toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_FULL.get = function () {
    return DATETIME_FULL;
  };

  /**
   * {@link toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_FULL_WITH_SECONDS.get = function () {
    return DATETIME_FULL_WITH_SECONDS;
  };

  /**
   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_HUGE.get = function () {
    return DATETIME_HUGE;
  };

  /**
   * {@link toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  staticAccessors$1.DATETIME_HUGE_WITH_SECONDS.get = function () {
    return DATETIME_HUGE_WITH_SECONDS;
  };

  Object.defineProperties( DateTime.prototype, prototypeAccessors$4 );
  Object.defineProperties( DateTime, staticAccessors$1 );

  /**
   * @private
   */
  function friendlyDateTime(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(
        ("Unknown datetime argument: " + dateTimeish + ", of type " + (typeof dateTimeish))
      );
    }
  }

  var DateTime$1 = /*@__PURE__*/(function (Input) {
    function DateTime$1(options) {
      if ( options === void 0 ) options = {};

      Input.call(this, options);

      this._format = null;
      this.setFormat(options.format);

      this.attributes({
        type: 'datetime-local'
      });
    }

    if ( Input ) DateTime$1.__proto__ = Input;
    DateTime$1.prototype = Object.create( Input && Input.prototype );
    DateTime$1.prototype.constructor = DateTime$1;

    DateTime$1.prototype.getOptions = function getOptions () {
      return Object.assign(Input.prototype.getOptions.call(this), {
        format: this._format
      });
    };

    DateTime$1.prototype.getFormat = function getFormat () {
      return this._format;
    };

    DateTime$1.prototype.setFormat = function setFormat (value) {
      if ( value === void 0 ) value = 'yyyy-MM-ddTHH:mm';

      this._format = value;
      return this;
    };

    DateTime$1.prototype.format = function format (value) {
      return this.setFormat(value);
    };

    DateTime$1.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).trim());
    };

    DateTime$1.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      var format = this.resolveValue(box, data, this._format);
      var date = DateTime.fromFormat(value, format);

      if (date.isValid === false) {
        return this.setError(error, name, value, 'type');
      }

      return null;
    };

    return DateTime$1;
  }(Input));

  var Date$1 = /*@__PURE__*/(function (DateTime) {
    function Date(options) {
      DateTime.call(this, options);

      this
        .attributes({
          type: 'date'
        })
        .format('yyyy-MM-dd');
    }

    if ( DateTime ) Date.__proto__ = DateTime;
    Date.prototype = Object.create( DateTime && DateTime.prototype );
    Date.prototype.constructor = Date;

    return Date;
  }(DateTime$1));

  var regexp$1 = /^[a-z0-9\-()]+$/i;

  var Email = /*@__PURE__*/(function (Input) {
    function Email(options) {
      Input.call(this, options);

      this.attributes({
        type: 'email'
      });
    }

    if ( Input ) Email.__proto__ = Input;
    Email.prototype = Object.create( Input && Input.prototype );
    Email.prototype.constructor = Email;

    Email.prototype.checkDomain = function checkDomain (domain) {
      return domain.split('.').every(function (part) {
        return regexp$1.test(part) === true &&
          part[0] !== '-' &&
          part[part.length - 1] !== '-';
      });
    };

    Email.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).trim().toLowerCase());
    };

    Email.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      if (value.match(/\s/) !== null) {
        return this.setError(error, name, value, 'space');
      }

      var ref = value
        .trim()
        .split('@');
      var local = ref[0]; if ( local === void 0 ) local = '';
      var domain = ref[1]; if ( domain === void 0 ) domain = '';

      if (local.length === 0) {
        return this.setError(error, name, value, 'local');
      }

      if (domain.length === 0 || this.checkDomain(domain) === false) {
        return this.setError(error, name, value, 'domain');
      }

      return null;
    };

    return Email;
  }(Input));

  var File$1 = /*@__PURE__*/(function (Input) {
    function File(options) {
      Input.call(this, options);

      this.attributes({
        type: 'file'
      });
    }

    if ( Input ) File.__proto__ = Input;
    File.prototype = Object.create( Input && Input.prototype );
    File.prototype.constructor = File;

    File.prototype.isAcceptable = function isAcceptable (value, accept) {
      var assign;

      if (typeof accept === 'undefined') {
        return true;
      }

      var list = accept.split(',');
      var ref = value.type.split('/');
      var fileType = ref[0];
      var fileSubType = ref[1];

      var type = null;
      var subtype = null;

      for (var i = 0; i < list.length; i += 1) {
        (assign = list[i].split('/'), type = assign[0], subtype = assign[1]);

        if (type !== '*' && fileType !== type) {
          return false;
        }

        if (subtype !== '*' && fileSubType !== subtype) {
          return false;
        }
      }

      return true;
    };

    File.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      return this.validateAccept(box, data, error, name, value);
    };

    File.prototype.validateAccept = function validateAccept (box, data, error, name, value) {
      var accept = this.resolveAttribute(box, data, 'accept');

      if (this.isAcceptable(value, accept) === false) {
        return this.setError(error, name, value, 'accept', { accept: accept });
      }

      return this.validateMaxsize(box, data, error, name, value);
    };

    File.prototype.validateMaxsize = function validateMaxsize (box, data, error, name, value) {
      var maxsize = this.resolveAttribute(box, data, 'maxsize');

      if (this.isBelowMax(value.size, maxsize) === false) {
        return this.setError(error, name, value, 'maxsize', { maxsize: maxsize });
      }

      return null;
    };

    return File;
  }(Input));

  var iban = createCommonjsModule(function (module, exports) {
  (function (root, factory) {
      if ( typeof exports.nodeName !== 'string') {
          // CommonJS
          factory(exports);
      } else {
          // Browser globals
          factory(root.IBAN = {});
      }
  }(commonjsGlobal, function(exports){

      // Array.prototype.map polyfill
      // code from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map
      if (!Array.prototype.map){
          Array.prototype.map = function(fun /*, thisArg */){

              if (this === void 0 || this === null)
                  { throw new TypeError(); }

              var t = Object(this);
              var len = t.length >>> 0;
              if (typeof fun !== "function")
                  { throw new TypeError(); }

              var res = new Array(len);
              var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
              for (var i = 0; i < len; i++)
              {
                  // NOTE: Absolute correctness would demand Object.defineProperty
                  //       be used.  But this method is fairly new, and failure is
                  //       possible only if Object.prototype or Array.prototype
                  //       has a property |i| (very unlikely), so use a less-correct
                  //       but more portable alternative.
                  if (i in t)
                      { res[i] = fun.call(thisArg, t[i], i, t); }
              }

              return res;
          };
      }

      var A = 'A'.charCodeAt(0),
          Z = 'Z'.charCodeAt(0);

      /**
       * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
       * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
       *
       * @param {string} iban the IBAN
       * @returns {string} the prepared IBAN
       */
      function iso13616Prepare(iban) {
          iban = iban.toUpperCase();
          iban = iban.substr(4) + iban.substr(0,4);

          return iban.split('').map(function(n){
              var code = n.charCodeAt(0);
              if (code >= A && code <= Z){
                  // A = 10, B = 11, ... Z = 35
                  return code - A + 10;
              } else {
                  return n;
              }
          }).join('');
      }

      /**
       * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
       *
       * @param iban
       * @returns {number}
       */
      function iso7064Mod97_10(iban) {
          var remainder = iban,
              block;

          while (remainder.length > 2){
              block = remainder.slice(0, 9);
              remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
          }

          return parseInt(remainder, 10) % 97;
      }

      /**
       * Parse the BBAN structure used to configure each IBAN Specification and returns a matching regular expression.
       * A structure is composed of blocks of 3 characters (one letter and 2 digits). Each block represents
       * a logical group in the typical representation of the BBAN. For each group, the letter indicates which characters
       * are allowed in this group and the following 2-digits number tells the length of the group.
       *
       * @param {string} structure the structure to parse
       * @returns {RegExp}
       */
      function parseStructure(structure){
          // split in blocks of 3 chars
          var regex = structure.match(/(.{3})/g).map(function(block){

              // parse each structure block (1-char + 2-digits)
              var format,
                  pattern = block.slice(0, 1),
                  repeats = parseInt(block.slice(1), 10);

              switch (pattern){
                  case "A": format = "0-9A-Za-z"; break;
                  case "B": format = "0-9A-Z"; break;
                  case "C": format = "A-Za-z"; break;
                  case "F": format = "0-9"; break;
                  case "L": format = "a-z"; break;
                  case "U": format = "A-Z"; break;
                  case "W": format = "0-9a-z"; break;
              }

              return '([' + format + ']{' + repeats + '})';
          });

          return new RegExp('^' + regex.join('') + '$');
      }

      /**
       *
       * @param iban
       * @returns {string}
       */
      function electronicFormat(iban){
          return iban.replace(NON_ALPHANUM, '').toUpperCase();
      }


      /**
       * Create a new Specification for a valid IBAN number.
       *
       * @param countryCode the code of the country
       * @param length the length of the IBAN
       * @param structure the structure of the underlying BBAN (for validation and formatting)
       * @param example an example valid IBAN
       * @constructor
       */
      function Specification(countryCode, length, structure, example){

          this.countryCode = countryCode;
          this.length = length;
          this.structure = structure;
          this.example = example;
      }

      /**
       * Lazy-loaded regex (parse the structure and construct the regular expression the first time we need it for validation)
       */
      Specification.prototype._regex = function(){
          return this._cachedRegex || (this._cachedRegex = parseStructure(this.structure))
      };

      /**
       * Check if the passed iban is valid according to this specification.
       *
       * @param {String} iban the iban to validate
       * @returns {boolean} true if valid, false otherwise
       */
      Specification.prototype.isValid = function(iban){
          return this.length == iban.length
              && this.countryCode === iban.slice(0,2)
              && this._regex().test(iban.slice(4))
              && iso7064Mod97_10(iso13616Prepare(iban)) == 1;
      };

      /**
       * Convert the passed IBAN to a country-specific BBAN.
       *
       * @param iban the IBAN to convert
       * @param separator the separator to use between BBAN blocks
       * @returns {string} the BBAN
       */
      Specification.prototype.toBBAN = function(iban, separator) {
          return this._regex().exec(iban.slice(4)).slice(1).join(separator);
      };

      /**
       * Convert the passed BBAN to an IBAN for this country specification.
       * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
       * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
       *
       * @param bban the BBAN to convert to IBAN
       * @returns {string} the IBAN
       */
      Specification.prototype.fromBBAN = function(bban) {
          if (!this.isValidBBAN(bban)){
              throw new Error('Invalid BBAN');
          }

          var remainder = iso7064Mod97_10(iso13616Prepare(this.countryCode + '00' + bban)),
              checkDigit = ('0' + (98 - remainder)).slice(-2);

          return this.countryCode + checkDigit + bban;
      };

      /**
       * Check of the passed BBAN is valid.
       * This function only checks the format of the BBAN (length and matching the letetr/number specs) but does not
       * verify the check digit.
       *
       * @param bban the BBAN to validate
       * @returns {boolean} true if the passed bban is a valid BBAN according to this specification, false otherwise
       */
      Specification.prototype.isValidBBAN = function(bban) {
          return this.length - 4 == bban.length
              && this._regex().test(bban);
      };

      var countries = {};

      function addSpecification(IBAN){
          countries[IBAN.countryCode] = IBAN;
      }

      addSpecification(new Specification("AD", 24, "F04F04A12",          "AD1200012030200359100100"));
      addSpecification(new Specification("AE", 23, "F03F16",             "AE070331234567890123456"));
      addSpecification(new Specification("AL", 28, "F08A16",             "AL47212110090000000235698741"));
      addSpecification(new Specification("AT", 20, "F05F11",             "AT611904300234573201"));
      addSpecification(new Specification("AZ", 28, "U04A20",             "AZ21NABZ00000000137010001944"));
      addSpecification(new Specification("BA", 20, "F03F03F08F02",       "BA391290079401028494"));
      addSpecification(new Specification("BE", 16, "F03F07F02",          "BE68539007547034"));
      addSpecification(new Specification("BG", 22, "U04F04F02A08",       "BG80BNBG96611020345678"));
      addSpecification(new Specification("BH", 22, "U04A14",             "BH67BMAG00001299123456"));
      addSpecification(new Specification("BR", 29, "F08F05F10U01A01",    "BR9700360305000010009795493P1"));
      addSpecification(new Specification("BY", 28, "A04F04A16",          "BY13NBRB3600900000002Z00AB00"));
      addSpecification(new Specification("CH", 21, "F05A12",             "CH9300762011623852957"));
      addSpecification(new Specification("CR", 22, "F04F14",             "CR72012300000171549015"));
      addSpecification(new Specification("CY", 28, "F03F05A16",          "CY17002001280000001200527600"));
      addSpecification(new Specification("CZ", 24, "F04F06F10",          "CZ6508000000192000145399"));
      addSpecification(new Specification("DE", 22, "F08F10",             "DE89370400440532013000"));
      addSpecification(new Specification("DK", 18, "F04F09F01",          "DK5000400440116243"));
      addSpecification(new Specification("DO", 28, "U04F20",             "DO28BAGR00000001212453611324"));
      addSpecification(new Specification("EE", 20, "F02F02F11F01",       "EE382200221020145685"));
      addSpecification(new Specification("ES", 24, "F04F04F01F01F10",    "ES9121000418450200051332"));
      addSpecification(new Specification("FI", 18, "F06F07F01",          "FI2112345600000785"));
      addSpecification(new Specification("FO", 18, "F04F09F01",          "FO6264600001631634"));
      addSpecification(new Specification("FR", 27, "F05F05A11F02",       "FR1420041010050500013M02606"));
      addSpecification(new Specification("GB", 22, "U04F06F08",          "GB29NWBK60161331926819"));
      addSpecification(new Specification("GE", 22, "U02F16",             "GE29NB0000000101904917"));
      addSpecification(new Specification("GI", 23, "U04A15",             "GI75NWBK000000007099453"));
      addSpecification(new Specification("GL", 18, "F04F09F01",          "GL8964710001000206"));
      addSpecification(new Specification("GR", 27, "F03F04A16",          "GR1601101250000000012300695"));
      addSpecification(new Specification("GT", 28, "A04A20",             "GT82TRAJ01020000001210029690"));
      addSpecification(new Specification("HR", 21, "F07F10",             "HR1210010051863000160"));
      addSpecification(new Specification("HU", 28, "F03F04F01F15F01",    "HU42117730161111101800000000"));
      addSpecification(new Specification("IE", 22, "U04F06F08",          "IE29AIBK93115212345678"));
      addSpecification(new Specification("IL", 23, "F03F03F13",          "IL620108000000099999999"));
      addSpecification(new Specification("IS", 26, "F04F02F06F10",       "IS140159260076545510730339"));
      addSpecification(new Specification("IT", 27, "U01F05F05A12",       "IT60X0542811101000000123456"));
      addSpecification(new Specification("IQ", 23, "U04F03A12",          "IQ98NBIQ850123456789012"));
      addSpecification(new Specification("JO", 30, "A04F22",             "JO15AAAA1234567890123456789012"));
      addSpecification(new Specification("KW", 30, "U04A22",             "KW81CBKU0000000000001234560101"));
      addSpecification(new Specification("KZ", 20, "F03A13",             "KZ86125KZT5004100100"));
      addSpecification(new Specification("LB", 28, "F04A20",             "LB62099900000001001901229114"));
      addSpecification(new Specification("LC", 32, "U04F24",             "LC07HEMM000100010012001200013015"));
      addSpecification(new Specification("LI", 21, "F05A12",             "LI21088100002324013AA"));
      addSpecification(new Specification("LT", 20, "F05F11",             "LT121000011101001000"));
      addSpecification(new Specification("LU", 20, "F03A13",             "LU280019400644750000"));
      addSpecification(new Specification("LV", 21, "U04A13",             "LV80BANK0000435195001"));
      addSpecification(new Specification("MC", 27, "F05F05A11F02",       "MC5811222000010123456789030"));
      addSpecification(new Specification("MD", 24, "U02A18",             "MD24AG000225100013104168"));
      addSpecification(new Specification("ME", 22, "F03F13F02",          "ME25505000012345678951"));
      addSpecification(new Specification("MK", 19, "F03A10F02",          "MK07250120000058984"));
      addSpecification(new Specification("MR", 27, "F05F05F11F02",       "MR1300020001010000123456753"));
      addSpecification(new Specification("MT", 31, "U04F05A18",          "MT84MALT011000012345MTLCAST001S"));
      addSpecification(new Specification("MU", 30, "U04F02F02F12F03U03", "MU17BOMM0101101030300200000MUR"));
      addSpecification(new Specification("NL", 18, "U04F10",             "NL91ABNA0417164300"));
      addSpecification(new Specification("NO", 15, "F04F06F01",          "NO9386011117947"));
      addSpecification(new Specification("PK", 24, "U04A16",             "PK36SCBL0000001123456702"));
      addSpecification(new Specification("PL", 28, "F08F16",             "PL61109010140000071219812874"));
      addSpecification(new Specification("PS", 29, "U04A21",             "PS92PALS000000000400123456702"));
      addSpecification(new Specification("PT", 25, "F04F04F11F02",       "PT50000201231234567890154"));
      addSpecification(new Specification("QA", 29, "U04A21",             "QA30AAAA123456789012345678901"));
      addSpecification(new Specification("RO", 24, "U04A16",             "RO49AAAA1B31007593840000"));
      addSpecification(new Specification("RS", 22, "F03F13F02",          "RS35260005601001611379"));
      addSpecification(new Specification("SA", 24, "F02A18",             "SA0380000000608010167519"));
      addSpecification(new Specification("SC", 31, "U04F04F16U03",       "SC18SSCB11010000000000001497USD"));
      addSpecification(new Specification("SE", 24, "F03F16F01",          "SE4550000000058398257466"));
      addSpecification(new Specification("SI", 19, "F05F08F02",          "SI56263300012039086"));
      addSpecification(new Specification("SK", 24, "F04F06F10",          "SK3112000000198742637541"));
      addSpecification(new Specification("SM", 27, "U01F05F05A12",       "SM86U0322509800000000270100"));
      addSpecification(new Specification("ST", 25, "F08F11F02",          "ST68000100010051845310112"));
      addSpecification(new Specification("SV", 28, "U04F20",             "SV62CENR00000000000000700025"));
      addSpecification(new Specification("TL", 23, "F03F14F02",          "TL380080012345678910157"));
      addSpecification(new Specification("TN", 24, "F02F03F13F02",       "TN5910006035183598478831"));
      addSpecification(new Specification("TR", 26, "F05F01A16",          "TR330006100519786457841326"));
      addSpecification(new Specification("UA", 29, "F25",                "UA511234567890123456789012345"));
      addSpecification(new Specification("VA", 22, "F18",                "VA59001123000012345678"));
      addSpecification(new Specification("VG", 24, "U04F16",             "VG96VPVG0000012345678901"));
      addSpecification(new Specification("XK", 20, "F04F10F02",          "XK051212012345678906"));


      // The following countries are not included in the official IBAN registry but use the IBAN specification

      // Angola
      addSpecification(new Specification("AO", 25, "F21",                "AO69123456789012345678901"));
      // Burkina
      addSpecification(new Specification("BF", 27, "F23",                "BF2312345678901234567890123"));
      // Burundi
      addSpecification(new Specification("BI", 16, "F12",                "BI41123456789012"));
      // Benin
      addSpecification(new Specification("BJ", 28, "F24",                "BJ39123456789012345678901234"));
      // Ivory
      addSpecification(new Specification("CI", 28, "U02F22",             "CI70CI1234567890123456789012"));
      // Cameron
      addSpecification(new Specification("CM", 27, "F23",                "CM9012345678901234567890123"));
      // Cape Verde
      addSpecification(new Specification("CV", 25, "F21",                "CV30123456789012345678901"));
      // Algeria
      addSpecification(new Specification("DZ", 24, "F20",                "DZ8612345678901234567890"));
      // Iran
      addSpecification(new Specification("IR", 26, "F22",                "IR861234568790123456789012"));
      // Madagascar
      addSpecification(new Specification("MG", 27, "F23",                "MG1812345678901234567890123"));
      // Mali
      addSpecification(new Specification("ML", 28, "U01F23",             "ML15A12345678901234567890123"));
      // Mozambique
      addSpecification(new Specification("MZ", 25, "F21",                "MZ25123456789012345678901"));
      // Senegal
      addSpecification(new Specification("SN", 28, "U01F23",             "SN52A12345678901234567890123"));

      var NON_ALPHANUM = /[^a-zA-Z0-9]/g,
          EVERY_FOUR_CHARS =/(.{4})(?!$)/g;

      /**
       * Utility function to check if a variable is a String.
       *
       * @param v
       * @returns {boolean} true if the passed variable is a String, false otherwise.
       */
      function isString(v){
          return (typeof v == 'string' || v instanceof String);
      }

      /**
       * Check if an IBAN is valid.
       *
       * @param {String} iban the IBAN to validate.
       * @returns {boolean} true if the passed IBAN is valid, false otherwise
       */
      exports.isValid = function(iban){
          if (!isString(iban)){
              return false;
          }
          iban = electronicFormat(iban);
          var countryStructure = countries[iban.slice(0,2)];
          return !!countryStructure && countryStructure.isValid(iban);
      };

      /**
       * Convert an IBAN to a BBAN.
       *
       * @param iban
       * @param {String} [separator] the separator to use between the blocks of the BBAN, defaults to ' '
       * @returns {string|*}
       */
      exports.toBBAN = function(iban, separator){
          if (typeof separator == 'undefined'){
              separator = ' ';
          }
          iban = electronicFormat(iban);
          var countryStructure = countries[iban.slice(0,2)];
          if (!countryStructure) {
              throw new Error('No country with code ' + iban.slice(0,2));
          }
          return countryStructure.toBBAN(iban, separator);
      };

      /**
       * Convert the passed BBAN to an IBAN for this country specification.
       * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
       * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
       *
       * @param countryCode the country of the BBAN
       * @param bban the BBAN to convert to IBAN
       * @returns {string} the IBAN
       */
      exports.fromBBAN = function(countryCode, bban){
          var countryStructure = countries[countryCode];
          if (!countryStructure) {
              throw new Error('No country with code ' + countryCode);
          }
          return countryStructure.fromBBAN(electronicFormat(bban));
      };

      /**
       * Check the validity of the passed BBAN.
       *
       * @param countryCode the country of the BBAN
       * @param bban the BBAN to check the validity of
       */
      exports.isValidBBAN = function(countryCode, bban){
          if (!isString(bban)){
              return false;
          }
          var countryStructure = countries[countryCode];
          return countryStructure && countryStructure.isValidBBAN(electronicFormat(bban));
      };

      /**
       *
       * @param iban
       * @param separator
       * @returns {string}
       */
      exports.printFormat = function(iban, separator){
          if (typeof separator == 'undefined'){
              separator = ' ';
          }
          return electronicFormat(iban).replace(EVERY_FOUR_CHARS, "$1" + separator);
      };

      exports.electronicFormat = electronicFormat;
      /**
       * An object containing all the known IBAN specifications.
       */
      exports.countries = countries;

  }));
  });

  var Iban = /*@__PURE__*/(function (Input) {
    function Iban(options) {
      Input.call(this, options);

      this.attributes({
        type: 'iban'
      });
    }

    if ( Input ) Iban.__proto__ = Input;
    Iban.prototype = Object.create( Input && Input.prototype );
    Iban.prototype.constructor = Iban;

    Iban.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).replace(/\s+/g, ''));
    };

    Iban.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      var country = value
        .toUpperCase()
        .slice(0, 2);

      var specification = iban.countries[country];

      if (typeof specification === 'undefined') {
        return this.setError(error, name, value, 'type');
      }

      value = value.slice(0, specification.length);

      if (iban.isValid(value) === false) {
        return this.setError(error, name, value, 'type');
      }

      this.setValue(data, name, iban.electronicFormat(value));

      return null;
    };

    return Iban;
  }(Input));

  var Month = /*@__PURE__*/(function (DateTime) {
    function Month(options) {
      DateTime.call(this, options);

      this
        .attributes({
          type: 'month'
        })
        .format('yyyy-MM');
    }

    if ( DateTime ) Month.__proto__ = DateTime;
    Month.prototype = Object.create( DateTime && DateTime.prototype );
    Month.prototype.constructor = Month;

    return Month;
  }(DateTime$1));

  var Number$1 = /*@__PURE__*/(function (Input) {
    function Number(options) {
      Input.call(this, options);

      this.attributes({
        type: 'number'
      });
    }

    if ( Input ) Number.__proto__ = Input;
    Number.prototype = Object.create( Input && Input.prototype );
    Number.prototype.constructor = Number;

    Number.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      // https://stackoverflow.com/a/1830844
      var isNumber = !isNaN(value - parseFloat(value));

      if (isNumber === false) {
        return this.setError(error, name, value, 'type');
      }

      this.setValue(data, name, parseFloat(value));

      return null;
    };

    return Number;
  }(Input));

  var Password = /*@__PURE__*/(function (Input) {
    function Password(options) {
      Input.call(this, options);

      this.attributes({
        type: 'password'
      });
    }

    if ( Input ) Password.__proto__ = Input;
    Password.prototype = Object.create( Input && Input.prototype );
    Password.prototype.constructor = Password;

    Password.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value));
    };

    return Password;
  }(Input));

  var Range = /*@__PURE__*/(function (Number) {
    function Range(options) {
      Number.call(this, options);

      this.attributes({
        type: 'range'
      });
    }

    if ( Number ) Range.__proto__ = Number;
    Range.prototype = Object.create( Number && Number.prototype );
    Range.prototype.constructor = Range;

    return Range;
  }(Number$1));

  var Radio = /*@__PURE__*/(function (Input) {
    function Radio(options) {
      Input.call(this, options);

      this.attributes({
        type: 'radio'
      });
    }

    if ( Input ) Radio.__proto__ = Input;
    Radio.prototype = Object.create( Input && Input.prototype );
    Radio.prototype.constructor = Radio;

    return Radio;
  }(Input));

  var Select = /*@__PURE__*/(function (Input) {
    function Select(options) {
      Input.call(this, options);
      this.name('select');
    }

    if ( Input ) Select.__proto__ = Input;
    Select.prototype = Object.create( Input && Input.prototype );
    Select.prototype.constructor = Select;

    Select.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      var values = [];

      for (var i = 0; i < this._args.length; i += 1) {
        values[values.length] = this._args[i]
          .resolveAttribute(box, data, 'value');
      }

      for (var i$1 = 0; i$1 < values.length; i$1 += 1) {
        if (values[i$1] === value) {
          return null;
        }
      }

      return this.setError(error, name, value, 'type', { values: values });
    };

    return Select;
  }(Input));

  // This file is a workaround for a bug in web browsers' "native"
  // ES6 importing system which is uncapable of importing "*.json" files.
  // https://github.com/catamphetamine/libphonenumber-js/issues/239
  var metadata = {"version":"1.7.20","country_calling_codes":{"1":["US","AG","AI","AS","BB","BM","BS","CA","DM","DO","GD","GU","JM","KN","KY","LC","MP","MS","PR","SX","TC","TT","VC","VG","VI"],"7":["RU","KZ"],"20":["EG"],"27":["ZA"],"30":["GR"],"31":["NL"],"32":["BE"],"33":["FR"],"34":["ES"],"36":["HU"],"39":["IT","VA"],"40":["RO"],"41":["CH"],"43":["AT"],"44":["GB","GG","IM","JE"],"45":["DK"],"46":["SE"],"47":["NO","SJ"],"48":["PL"],"49":["DE"],"51":["PE"],"52":["MX"],"53":["CU"],"54":["AR"],"55":["BR"],"56":["CL"],"57":["CO"],"58":["VE"],"60":["MY"],"61":["AU","CC","CX"],"62":["ID"],"63":["PH"],"64":["NZ"],"65":["SG"],"66":["TH"],"81":["JP"],"82":["KR"],"84":["VN"],"86":["CN"],"90":["TR"],"91":["IN"],"92":["PK"],"93":["AF"],"94":["LK"],"95":["MM"],"98":["IR"],"211":["SS"],"212":["MA","EH"],"213":["DZ"],"216":["TN"],"218":["LY"],"220":["GM"],"221":["SN"],"222":["MR"],"223":["ML"],"224":["GN"],"225":["CI"],"226":["BF"],"227":["NE"],"228":["TG"],"229":["BJ"],"230":["MU"],"231":["LR"],"232":["SL"],"233":["GH"],"234":["NG"],"235":["TD"],"236":["CF"],"237":["CM"],"238":["CV"],"239":["ST"],"240":["GQ"],"241":["GA"],"242":["CG"],"243":["CD"],"244":["AO"],"245":["GW"],"246":["IO"],"247":["AC"],"248":["SC"],"249":["SD"],"250":["RW"],"251":["ET"],"252":["SO"],"253":["DJ"],"254":["KE"],"255":["TZ"],"256":["UG"],"257":["BI"],"258":["MZ"],"260":["ZM"],"261":["MG"],"262":["RE","YT"],"263":["ZW"],"264":["NA"],"265":["MW"],"266":["LS"],"267":["BW"],"268":["SZ"],"269":["KM"],"290":["SH","TA"],"291":["ER"],"297":["AW"],"298":["FO"],"299":["GL"],"350":["GI"],"351":["PT"],"352":["LU"],"353":["IE"],"354":["IS"],"355":["AL"],"356":["MT"],"357":["CY"],"358":["FI","AX"],"359":["BG"],"370":["LT"],"371":["LV"],"372":["EE"],"373":["MD"],"374":["AM"],"375":["BY"],"376":["AD"],"377":["MC"],"378":["SM"],"380":["UA"],"381":["RS"],"382":["ME"],"383":["XK"],"385":["HR"],"386":["SI"],"387":["BA"],"389":["MK"],"420":["CZ"],"421":["SK"],"423":["LI"],"500":["FK"],"501":["BZ"],"502":["GT"],"503":["SV"],"504":["HN"],"505":["NI"],"506":["CR"],"507":["PA"],"508":["PM"],"509":["HT"],"590":["GP","BL","MF"],"591":["BO"],"592":["GY"],"593":["EC"],"594":["GF"],"595":["PY"],"596":["MQ"],"597":["SR"],"598":["UY"],"599":["CW","BQ"],"670":["TL"],"672":["NF"],"673":["BN"],"674":["NR"],"675":["PG"],"676":["TO"],"677":["SB"],"678":["VU"],"679":["FJ"],"680":["PW"],"681":["WF"],"682":["CK"],"683":["NU"],"685":["WS"],"686":["KI"],"687":["NC"],"688":["TV"],"689":["PF"],"690":["TK"],"691":["FM"],"692":["MH"],"800":["001"],"808":["001"],"850":["KP"],"852":["HK"],"853":["MO"],"855":["KH"],"856":["LA"],"870":["001"],"878":["001"],"880":["BD"],"881":["001"],"882":["001"],"883":["001"],"886":["TW"],"888":["001"],"960":["MV"],"961":["LB"],"962":["JO"],"963":["SY"],"964":["IQ"],"965":["KW"],"966":["SA"],"967":["YE"],"968":["OM"],"970":["PS"],"971":["AE"],"972":["IL"],"973":["BH"],"974":["QA"],"975":["BT"],"976":["MN"],"977":["NP"],"979":["001"],"992":["TJ"],"993":["TM"],"994":["AZ"],"995":["GE"],"996":["KG"],"998":["UZ"]},"countries":{"AC":["247","00","(?:[01589]\\d|[46])\\d{4}",[5,6]],"AD":["376","00","(?:1|6\\d)\\d{7}|[136-9]\\d{5}",[6,8,9],[["(\\d{3})(\\d{3})","$1 $2",["[136-9]"]],["(\\d{4})(\\d{4})","$1 $2",["1"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]]],"AE":["971","00","(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}",[5,6,7,8,9,10,11,12],[["(\\d{3})(\\d{2,9})","$1 $2",["60|8"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[236]|[479][2-8]"],"0$1"],["(\\d{3})(\\d)(\\d{5})","$1 $2 $3",["[479]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"]],"0"],"AF":["93","00","[2-7]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[2-7]"],"0$1"]],"0"],"AG":["1","011","(?:268|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([457]\\d{6})$","268$1",0,"268"],"AI":["1","011","(?:264|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2457]\\d{6})$","264$1",0,"264"],"AL":["355","00","(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}",[6,7,8,9],[["(\\d{3})(\\d{3,4})","$1 $2",["80|9"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["4[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2358][2-5]|4"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["[23578]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["6"],"0$1"]],"0"],"AM":["374","00","(?:[1-489]\\d|55|60|77)\\d{6}",[8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[89]0"],"0 $1"],["(\\d{2})(\\d{6})","$1 $2",["1|47"],"(0$1)"],["(\\d{3})(\\d{5})","$1 $2",["[23]"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[4-9]"],"0$1"]],"0"],"AO":["244","00","[29]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[29]"]]]],"AR":["54","00","11\\d{8}|(?:[2368]|9\\d)\\d{9}",[10,11],[["(\\d{4})(\\d{2})(\\d{4})","$1 $2-$3",["2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])","2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5(?:[24-6]|3[2-5]))|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["1"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2-$3",["[23]"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[68]"],"0$1"],["(\\d)(\\d{4})(\\d{2})(\\d{4})","$2 15-$3-$4",["9(?:2[2-469]|3[3-578])","9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))","9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]","9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5(?:[24-6]|3[2-5]))|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"],"0$1",0,"$1 $2 $3-$4"],["(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 15-$3-$4",["91"],"0$1",0,"$1 $2 $3-$4"],["(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 15-$3-$4",["9"],"0$1",0,"$1 $2 $3-$4"]],"0",0,"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?","9$1"],"AS":["1","011","(?:[58]\\d\\d|684|900)\\d{7}",[10],0,"1",0,"1|([267]\\d{6})$","684$1",0,"684"],"AT":["43","00","1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}",[4,5,6,7,8,9,10,11,12,13],[["(\\d)(\\d{3,12})","$1 $2",["1(?:11|[2-9])"],"0$1"],["(\\d{3})(\\d{2})","$1 $2",["517"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["5[079]"],"0$1"],["(\\d{3})(\\d{3,10})","$1 $2",["(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]"],"0$1"],["(\\d{4})(\\d{3,9})","$1 $2",["[2-467]|5[2-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["5"],"0$1"],["(\\d{2})(\\d{4})(\\d{4,7})","$1 $2 $3",["5"],"0$1"]],"0"],"AU":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d{7,8}|8[0-24-9]\\d{7})|(?:[2-478]\\d\\d|550)\\d{6}|1\\d{4,7}",[5,6,7,8,9,10],[["(\\d{2})(\\d{3,4})","$1 $2",["16"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,4})","$1 $2 $3",["16"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["14|[45]"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["[2378]"],"(0$1)"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:30|[89])"]]],"0",0,"0|(183[12])",0,0,0,[["(?:[237]\\d{5}|8(?:51(?:0(?:0[03-9]|[1247]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-6])|1(?:1[69]|[23]\\d|4[0-4]))|(?:[6-8]\\d{3}|9(?:[02-9]\\d\\d|1(?:[0-57-9]\\d|6[0135-9])))\\d))\\d{3}",[9]],["4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[017-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,["16\\d{3,7}",[5,6,7,8,9]],["(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",[9]],["13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",[6,8,10]]],"0011"],"AW":["297","00","(?:[25-79]\\d\\d|800)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[25-9]"]]]],"AX":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|(?:[147]\\d|3[0-46-9]|50)\\d{4,8}",[5,6,7,8,9,10],0,"0",0,0,0,0,"18",0,"00"],"AZ":["994","00","(?:365\\d{3}|900200)\\d{3}|(?:[12457]\\d|60|88)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["9"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[12]|365","[12]|365","[12]|365(?:[0-46-9]|5[0-35-9])"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[3-8]"],"0$1"]],"0"],"BA":["387","00","6\\d{8}|(?:[35689]\\d|49|70)\\d{6}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["6[1-356]|[7-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2-$3",["[3-5]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["6"],"0$1"]],"0"],"BB":["1","011","(?:246|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","246$1",0,"246"],"BD":["880","00","[13469]\\d{9}|8[0-79]\\d{7,8}|[2-7]\\d{8}|[2-9]\\d{7}|[3-689]\\d{6}|[57-9]\\d{5}",[6,7,8,9,10],[["(\\d{2})(\\d{4,6})","$1-$2",["31[5-7]|[459]1"],"0$1"],["(\\d{3})(\\d{3,7})","$1-$2",["3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:28|4[14]|5)|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"],"0$1"],["(\\d{4})(\\d{3,6})","$1-$2",["[13-9]"],"0$1"],["(\\d)(\\d{7,8})","$1-$2",["2"],"0$1"]],"0"],"BE":["32","00","4\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:80|9)0"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[239]|4[23]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[15-8]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["4"],"0$1"]],"0"],"BF":["226","00","[025-7]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[025-7]"]]]],"BG":["359","00","[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}",[6,7,8,9],[["(\\d)(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["43[1-6]|70[1-9]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["(?:70|8)0"],"0$1"],["(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["43[1-7]|7"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[48]|9[08]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"]],"0"],"BH":["973","00","[136-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[13679]|8[047]"]]]],"BI":["257","00","(?:[267]\\d|31)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2367]"]]]],"BJ":["229","00","[2689]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2689]"]]]],"BL":["590","00","(?:590|69\\d)\\d{6}",[9],0,"0",0,0,0,0,0,[["590(?:2[7-9]|5[12]|87)\\d{4}"],["69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}"]]],"BM":["1","011","(?:441|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-8]\\d{6})$","441$1",0,"441"],"BN":["673","00","[2-578]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-578]"]]]],"BO":["591","00(?:1\\d)?","(?:[2-467]\\d{3}|80017)\\d{4}",[8,9],[["(\\d)(\\d{7})","$1 $2",["[23]|4[46]"]],["(\\d{8})","$1",["[67]"]],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["8"]]],"0",0,"0(1\\d)?"],"BQ":["599","00","(?:[34]1|7\\d)\\d{5}",[7],0,0,0,0,0,0,"[347]"],"BR":["55","00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)","(?:[1-46-9]\\d\\d|5(?:[0-46-9]\\d|5[0-24679]))\\d{8}|[1-9]\\d{9}|[3589]\\d{8}|[34]\\d{7}",[8,9,10,11],[["(\\d{4})(\\d{4})","$1-$2",["300|4(?:0[02]|37)","4(?:02|37)0|[34]00"]],["(\\d{3})(\\d{2,3})(\\d{4})","$1 $2 $3",["(?:[358]|90)0"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2-$3",["(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"],"($1)"],["(\\d{2})(\\d{5})(\\d{4})","$1 $2-$3",["[16][1-9]|[2-57-9]"],"($1)"]],"0",0,"0(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?","$2"],"BS":["1","011","(?:242|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([3-8]\\d{6})$","242$1",0,"242"],"BT":["975","00","[17]\\d{7}|[2-8]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[2-68]|7[246]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[67]|7"]]]],"BW":["267","00","90\\d{5}|(?:[2-6]|7\\d)\\d{6}",[7,8],[["(\\d{2})(\\d{5})","$1 $2",["90"]],["(\\d{3})(\\d{4})","$1 $2",["[2-6]"]],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["7"]]]],"BY":["375","810","(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}",[6,7,8,9,10,11],[["(\\d{3})(\\d{3})","$1 $2",["800"],"8 $1"],["(\\d{3})(\\d{2})(\\d{2,4})","$1 $2 $3",["800"],"8 $1"],["(\\d{4})(\\d{2})(\\d{3})","$1 $2-$3",["1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])","1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"],"8 0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["1(?:[56]|7[467])|2[1-3]"],"8 0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-4]"],"8 0$1"],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["[89]"],"8 $1"]],"8",0,"0|80?",0,0,0,0,"8~10"],"BZ":["501","00","(?:0800\\d|[2-8])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1-$2",["[2-8]"]],["(\\d)(\\d{3})(\\d{4})(\\d{3})","$1-$2-$3-$4",["0"]]]],"CA":["1","011","(?:[2-8]\\d|90)\\d{8}",[10],0,"1",0,0,0,0,0,[["(?:2(?:04|[23]6|[48]9|50)|3(?:06|43|65)|4(?:03|1[68]|3[178]|50)|5(?:06|1[49]|48|79|8[17])|6(?:04|13|39|47)|7(?:0[59]|78|8[02])|8(?:[06]7|19|25|73)|90[25])[2-9]\\d{6}"],[""],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"],["900[2-9]\\d{6}"],["(?:5(?:00|2[12]|33|44|66|77|88)|622)[2-9]\\d{6}"],0,0,0,["600[2-9]\\d{6}"]]],"CC":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d|8[0-24-9])\\d{7}|(?:[148]\\d\\d|550)\\d{6}|1\\d{5,7}",[6,7,8,9,10],0,"0",0,"0|([59]\\d{7})$","8$1",0,0,[["8(?:51(?:0(?:02|31|60)|118)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}",[9]],["4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[017-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",[9]],["13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",[6,8,10]]],"0011"],"CD":["243","00","[189]\\d{8}|[1-68]\\d{6}",[7,9],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[1-6]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]"],"0$1"]],"0"],"CF":["236","00","(?:[27]\\d{3}|8776)\\d{4}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[278]"]]]],"CG":["242","00","222\\d{6}|(?:0\\d|80)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["801"]],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["8"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[02]"]]]],"CH":["41","00","8\\d{11}|[2-9]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8[047]|90"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-79]|81"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["8"],"0$1"]],"0"],"CI":["225","00","[02-8]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[02-8]"]]]],"CK":["682","00","[2-8]\\d{4}",[5],[["(\\d{2})(\\d{3})","$1 $2",["[2-8]"]]]],"CL":["56","(?:0|1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))0","12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}",[9,10,11],[["(\\d{5})(\\d{4})","$1 $2",["21"],"($1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["44"]],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2[23]"],"($1)"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["9[2-9]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"],"($1)"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["60|8"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{3})(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3 $4",["60"]]]],"CM":["237","00","(?:[26]\\d\\d|88)\\d{6}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["88"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[26]"]]]],"CN":["86","00|1(?:[12]\\d|79|9[0235-7])\\d\\d00","1[1279]\\d{8,9}|2\\d{9}(?:\\d{2})?|[12]\\d{6,7}|86\\d{6}|(?:1[03-68]\\d|6)\\d{7,9}|(?:[3-579]\\d|8[0-57-9])\\d{6,9}",[7,8,9,10,11,12],[["(\\d{2})(\\d{5,6})","$1 $2",["(?:10|2[0-57-9])[19]","(?:10|2[0-57-9])(?:10|9[56])","(?:10|2[0-57-9])(?:100|9[56])"],"0$1"],["(\\d{3})(\\d{5,6})","$1 $2",["3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]","(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]","85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])","85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["(?:4|80)0"]],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["10|2(?:[02-57-9]|1[1-9])","10|2(?:[02-57-9]|1[1-9])","10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"],"0$1",1],["(\\d{3})(\\d{7,8})","$1 $2",["9"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["80"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[3-578]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["1[3-9]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3 $4",["[12]"],"0$1",1]],"0",0,"0|(1(?:[12]\\d|79|9[0235-7])\\d\\d)",0,0,0,0,"00"],"CO":["57","00(?:4(?:[14]4|56)|[579])","(?:1\\d|3)\\d{9}|[124-8]\\d{7}",[8,10,11],[["(\\d)(\\d{7})","$1 $2",["1[2-79]|[25-8]|(?:18|4)[2-9]"],"($1)"],["(\\d{3})(\\d{7})","$1 $2",["3"]],["(\\d)(\\d{3})(\\d{7})","$1-$2-$3",["1(?:80|9)","1(?:800|9)"],"0$1",0,"$1 $2 $3"]],"0",0,"0([3579]|4(?:[14]4|56))?"],"CR":["506","00","(?:8\\d|90)\\d{8}|[24-8]\\d{7}",[8,10],[["(\\d{4})(\\d{4})","$1 $2",["[24-7]|8[3-9]"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["[89]"]]],0,0,"(19(?:0[0-2468]|1[09]|20|66|77|99))"],"CU":["53","119","[27]\\d{6,7}|[34]\\d{5,7}|5\\d{7}",[6,7,8],[["(\\d{2})(\\d{4,6})","$1 $2",["2[1-4]|[34]"],"(0$1)"],["(\\d)(\\d{6,7})","$1 $2",["7"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["5"],"0$1"]],"0"],"CV":["238","0","[2-59]\\d{6}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[2-59]"]]]],"CW":["599","00","(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[3467]"]],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["9[4-8]"]]],0,0,0,0,0,"[69]"],"CX":["61","001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011","1(?:[0-79]\\d|8[0-24-9])\\d{7}|(?:[148]\\d\\d|550)\\d{6}|1\\d{5,7}",[6,7,8,9,10],0,"0",0,"0|([59]\\d{7})$","8$1",0,0,[["8(?:51(?:0(?:01|30|59)|117)|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}",[9]],["4(?:[0-3]\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[017-9])\\d{6}",[9]],["180(?:0\\d{3}|2)\\d{3}",[7,10]],["190[0-26]\\d{6}",[10]],0,0,0,0,["(?:14(?:5(?:1[0458]|[23][458])|71\\d)|550\\d\\d)\\d{4}",[9]],["13(?:00\\d{3}|45[0-4])\\d{3}|13\\d{4}",[6,8,10]]],"0011"],"CY":["357","00","(?:[279]\\d|[58]0)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[257-9]"]]]],"CZ":["420","00","(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]|9[015-7]"]],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]]],"DE":["49","00","[2579]\\d{5,14}|49(?:[05]\\d{10}|[46][1-8]\\d{4,9})|49(?:[0-25]\\d|3[1-689]|7[1-7])\\d{4,8}|49(?:[0-2579]\\d|[34][1-9]|6[0-8])\\d{3}|49\\d{3,4}|(?:1|[368]\\d|4[0-8])\\d{3,13}",[4,5,6,7,8,9,10,11,12,13,14,15],[["(\\d{2})(\\d{3,13})","$1 $2",["3[02]|40|[68]9"],"0$1"],["(\\d{3})(\\d{3,12})","$1 $2",["2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1","2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"],"0$1"],["(\\d{4})(\\d{2,11})","$1 $2",["[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]","[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["138"],"0$1"],["(\\d{5})(\\d{2,10})","$1 $2",["3"],"0$1"],["(\\d{3})(\\d{5,11})","$1 $2",["181"],"0$1"],["(\\d{3})(\\d)(\\d{4,10})","$1 $2 $3",["1(?:3|80)|9"],"0$1"],["(\\d{3})(\\d{7,8})","$1 $2",["1[67]"],"0$1"],["(\\d{3})(\\d{7,12})","$1 $2",["8"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["185","1850","18500"],"0$1"],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["18[68]"],"0$1"],["(\\d{5})(\\d{6})","$1 $2",["15[0568]"],"0$1"],["(\\d{4})(\\d{7})","$1 $2",["15[1279]"],"0$1"],["(\\d{3})(\\d{8})","$1 $2",["18"],"0$1"],["(\\d{3})(\\d{2})(\\d{7,8})","$1 $2 $3",["1(?:6[023]|7)"],"0$1"],["(\\d{4})(\\d{2})(\\d{7})","$1 $2 $3",["15[279]"],"0$1"],["(\\d{3})(\\d{2})(\\d{8})","$1 $2 $3",["15"],"0$1"]],"0"],"DJ":["253","00","(?:2\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[27]"]]]],"DK":["45","00","[2-9]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-9]"]]]],"DM":["1","011","(?:[58]\\d\\d|767|900)\\d{7}",[10],0,"1",0,"1|([2-7]\\d{6})$","767$1",0,"767"],"DO":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,0,0,0,"8[024]9"],"DZ":["213","00","(?:[1-4]|[5-79]\\d|80)\\d{7}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["9"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-8]"],"0$1"]],"0"],"EC":["593","00","1800\\d{6,7}|(?:[2-7]|9\\d)\\d{7}",[8,9,10,11],[["(\\d)(\\d{3})(\\d{4})","$1 $2-$3",["[2-7]"],"(0$1)",0,"$1-$2-$3"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{3})(\\d{3,4})","$1 $2 $3",["1"]]],"0"],"EE":["372","00","8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d\\d|900)\\d{4}",[7,8,10],[["(\\d{3})(\\d{4})","$1 $2",["[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]","[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]"]],["(\\d{4})(\\d{3,4})","$1 $2",["[45]|8(?:00|[1-4])","[45]|8(?:00[1-9]|[1-4])"]],["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["80"]]]],"EG":["20","00","[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}",[8,9,10],[["(\\d)(\\d{7,8})","$1 $2",["[23]"],"0$1"],["(\\d{2})(\\d{6,7})","$1 $2",["1[35]|[4-6]|8[2468]|9[235-7]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[189]"],"0$1"]],"0"],"EH":["212","00","[5-8]\\d{8}",[9],0,"0",0,0,0,0,"528[89]"],"ER":["291","00","[178]\\d{6}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[178]"],"0$1"]],"0"],"ES":["34","00","(?:51|[6-9]\\d)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[89]00"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-9]"]]]],"ET":["251","00","(?:11|[2-59]\\d)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-59]"],"0$1"]],"0"],"FI":["358","00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))","(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}|[1-35689]\\d{4}",[5,6,7,8,9,10],[["(\\d)(\\d{4,9})","$1 $2",["[2568][1-8]|3(?:0[1-9]|[1-9])|9"],"0$1"],["(\\d{3})(\\d{3,7})","$1 $2",["(?:[12]0|7)0|[368]"],"0$1"],["(\\d{2})(\\d{4,8})","$1 $2",["[12457]"],"0$1"]],"0",0,0,0,0,"1[03-79]|[2-9]",0,"00"],"FJ":["679","0(?:0|52)","45\\d{5}|(?:0800\\d|[235-9])\\d{6}",[7,11],[["(\\d{3})(\\d{4})","$1 $2",["[235-9]|45"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]]],0,0,0,0,0,0,0,"00"],"FK":["500","00","[2-7]\\d{4}",[5]],"FM":["691","00","[39]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[39]"]]]],"FO":["298","00","(?:[2-8]\\d|90)\\d{4}",[6],[["(\\d{6})","$1",["[2-9]"]]],0,0,"(10(?:01|[12]0|88))"],"FR":["33","00","[1-9]\\d{8}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"],"0 $1"],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["[1-79]"],"0$1"]],"0"],"GA":["241","00","(?:0\\d|[2-7])\\d{6}",[7,8],[["(\\d)(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-7]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]]]],"GB":["44","00","[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}",[7,9,10],[["(\\d{3})(\\d{4})","$1 $2",["800","8001","80011","800111","8001111"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["845","8454","84546","845464"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["800"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["1(?:38|5[23]|69|76|94)","1(?:(?:38|69)7|5(?:24|39)|768|946)","1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["1(?:[2-69][02-9]|[78])"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[25]|7(?:0|6[024-9])","[25]|7(?:0|6(?:[04-9]|2[356]))"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[1389]"],"0$1"]],"0",0,0,0,0,0,[["(?:1(?:1(?:3[0-58]|4[0-5]|5[0-26-9]|6[0-4]|[78][0-49])|2(?:0[024-9]|1[0-7]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)|3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))|2(?:0[01378]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d)\\d{6}|1(?:(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d|7(?:(?:26(?:6[13-9]|7[0-7])|442\\d|50(?:2[0-3]|[3-68]2|76))\\d|6888[2-46-8]))\\d\\d",[9,10]],["7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:0[0-2]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}",[10]],["56\\d{8}",[10]]],0," x"],"GD":["1","011","(?:473|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","473$1",0,"473"],"GE":["995","00","(?:[3-57]\\d\\d|800)\\d{6}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["32"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[57]"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[348]"],"0$1"]],"0"],"GF":["594","00","[56]94\\d{6}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[56]"],"0$1"]],"0"],"GG":["44","00","(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?",[7,9,10],0,"0",0,"0|([25-9]\\d{5})$","1481$1",0,0,[["1481[25-9]\\d{5}",[10]],["7(?:(?:781|839)\\d|911[17])\\d{5}",[10]],["80[08]\\d{7}|800\\d{6}|8001111"],["(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d",[7,10]],["70\\d{8}",[10]],0,["(?:3[0347]|55)\\d{8}",[10]],["76(?:0[0-2]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}",[10]],["56\\d{8}",[10]]]],"GH":["233","00","(?:[235]\\d{3}|800)\\d{5}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[235]"],"0$1"]],"0"],"GI":["350","00","(?:[25]\\d\\d|629)\\d{5}",[8],[["(\\d{3})(\\d{5})","$1 $2",["2"]]]],"GL":["299","00","(?:19|[2-689]\\d)\\d{4}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["19|[2-689]"]]]],"GM":["220","00","[2-9]\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"GN":["224","00","(?:30|6\\d\\d|722)\\d{6}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["3"]],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[67]"]]]],"GP":["590","00","(?:590|69\\d)\\d{6}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[56]"],"0$1"]],"0",0,0,0,0,0,[["590(?:0[1-68]|1[0-2]|2[0-68]|3[1289]|4[0-24-9]|5[3-579]|6[0189]|7[08]|8[0-689]|9\\d)\\d{4}"],["69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}"]]],"GQ":["240","00","222\\d{6}|(?:3\\d|55|[89]0)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235]"]],["(\\d{3})(\\d{6})","$1 $2",["[89]"]]]],"GR":["30","00","(?:[268]\\d|[79]0)\\d{8}",[10],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["21|7"]],["(\\d{4})(\\d{6})","$1 $2",["2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2689]"]]]],"GT":["502","00","(?:1\\d{3}|[2-7])\\d{7}",[8,11],[["(\\d{4})(\\d{4})","$1 $2",["[2-7]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"GU":["1","011","(?:[58]\\d\\d|671|900)\\d{7}",[10],0,"1",0,"1|([3-9]\\d{6})$","671$1",0,"671"],"GW":["245","00","[49]\\d{8}|4\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["40"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[49]"]]]],"GY":["592","001","(?:862\\d|9008)\\d{3}|(?:[2-46]\\d|77)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-46-9]"]]]],"HK":["852","00(?:30|5[09]|[126-9]?)","8[0-46-9]\\d{6,7}|9\\d{4}(?:\\d(?:\\d(?:\\d{4})?)?)?|(?:[235-79]\\d|46)\\d{6}",[5,6,7,8,9,11],[["(\\d{3})(\\d{2,5})","$1 $2",["900","9003"]],["(\\d{4})(\\d{4})","$1 $2",["[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]],["(\\d{3})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["9"]]],0,0,0,0,0,0,0,"00"],"HN":["504","00","[237-9]\\d{7}",[8],[["(\\d{4})(\\d{4})","$1-$2",["[237-9]"]]]],"HR":["385","00","(?:[24-69]\\d|3[0-79])\\d{7}|80\\d{5,7}|[1-79]\\d{7}|6\\d{5,6}",[6,7,8,9],[["(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["6[01]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{4})(\\d{3})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[67]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-5]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"]],"0"],"HT":["509","00","[2-489]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[2-489]"]]]],"HU":["36","00","[2357]\\d{8}|[1-9]\\d{7}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"($1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"($1)"]],"06"],"ID":["62","00[189]","(?:(?:007803|8\\d{4})\\d|[1-36])\\d{6}|[1-9]\\d{8,10}|[2-9]\\d{7}",[7,8,9,10,11,12,13],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["15"]],["(\\d{2})(\\d{5,9})","$1 $2",["2[124]|[36]1"],"(0$1)"],["(\\d{3})(\\d{5,7})","$1 $2",["800"],"0$1"],["(\\d{3})(\\d{5,8})","$1 $2",["[2-79]"],"(0$1)"],["(\\d{3})(\\d{3,4})(\\d{3})","$1-$2-$3",["8[1-35-9]"],"0$1"],["(\\d{3})(\\d{6,8})","$1 $2",["1"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["804"],"0$1"],["(\\d{3})(\\d)(\\d{3})(\\d{3})","$1 $2 $3 $4",["80"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1-$2-$3",["8"],"0$1"]],"0"],"IE":["353","00","(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["2[24-9]|47|58|6[237-9]|9[35-9]"],"(0$1)"],["(\\d{3})(\\d{5})","$1 $2",["[45]0"],"(0$1)"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["1"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2569]|4[1-69]|7[14]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["70"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["81"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[78]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]],["(\\d{2})(\\d)(\\d{3})(\\d{4})","$1 $2 $3 $4",["8"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["4"],"(0$1)"]],"0"],"IL":["972","0(?:0|1[2-9])","1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}",[7,8,9,10,11,12],[["(\\d{4})(\\d{3})","$1-$2",["125"]],["(\\d{4})(\\d{2})(\\d{2})","$1-$2-$3",["121"]],["(\\d)(\\d{3})(\\d{4})","$1-$2-$3",["[2-489]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1-$2-$3",["12"]],["(\\d{4})(\\d{6})","$1-$2",["159"]],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3-$4",["1[7-9]"]],["(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})","$1-$2 $3-$4",["15"]]],"0"],"IM":["44","00","1624\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"0|([5-8]\\d{5})$","1624$1",0,"74576|(?:16|7[56])24"],"IN":["91","00","(?:00800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}",[8,9,10,11,12,13],[["(\\d{8})","$1",["5(?:0|2[23]|3[03]|[67]1|88)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)","5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"],0,1],["(\\d{4})(\\d{4,5})","$1 $2",["180","1800"],0,1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["140"],0,1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["11|2[02]|33|4[04]|79[1-7]|80[2-46]","11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])","11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"],"0$1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:[2-4]1|5[17]|6[13]|7[14]|80)|7(?:12|(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|(?:55|61)2|7(?:31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]","1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|[2-4]1|5[17]|6[13]|7[14]|80)|7(?:12|(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:1(?:29|60|8[06])|261|552|788[01])[2-7]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])"],"0$1",1],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|[4-8])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807","1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|[4-8])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]","1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|[4-8])|7(?:1(?:[013-8]|9[6-9])|3179)|807(?:1|9[1-3])|(?:1552|7(?:28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"],"0$1",1],["(\\d{5})(\\d{5})","$1 $2",["[6-9]"],"0$1",1],["(\\d{4})(\\d{2,4})(\\d{4})","$1 $2 $3",["1(?:6|8[06])","1(?:6|8[06]0)"],0,1],["(\\d{4})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["18"],0,1]],"0"],"IO":["246","00","3\\d{6}",[7],[["(\\d{3})(\\d{4})","$1 $2",["3"]]]],"IQ":["964","00","(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-6]"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0"],"IR":["98","00","[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}",[4,5,6,7,10],[["(\\d{4,5})","$1",["96"],"0$1"],["(\\d{2})(\\d{4,5})","$1 $2",["(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["[1-8]"],"0$1"]],"0"],"IS":["354","00|1(?:0(?:01|[12]0)|100)","(?:38\\d|[4-9])\\d{6}",[7,9],[["(\\d{3})(\\d{4})","$1 $2",["[4-9]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["3"]]],0,0,0,0,0,0,0,"00"],"IT":["39","00","0\\d{6,10}|55\\d{8}|[08]\\d{5}|(?:3[0-8]|8)\\d{7,9}|(?:1\\d|39)\\d{7,8}",[6,7,8,9,10,11],[["(\\d{2})(\\d{4,6})","$1 $2",["0[26]"]],["(\\d{3})(\\d{3,6})","$1 $2",["0[13-57-9][0159]|8(?:03|4[17]|9[245])","0[13-57-9][0159]|8(?:03|4[17]|9(?:2|[45][0-4]))"]],["(\\d{4})(\\d{2,6})","$1 $2",["0(?:[13-579][2-46-8]|8[236-8])"]],["(\\d{4})(\\d{4})","$1 $2",["894"]],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[26]|5"]],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["1[4679]|[38]"]],["(\\d{3})(\\d{3,4})(\\d{4})","$1 $2 $3",["0[13-57-9][0159]"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["3"]],["(\\d{2})(\\d{4})(\\d{5})","$1 $2 $3",["0[26]"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["0"]]],0,0,0,0,0,0,[["0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}"],["33\\d{9}|3[1-9]\\d{8}|3[2-9]\\d{7}",[9,10,11]],["80(?:0\\d{3}|3)\\d{3}",[6,9]],["(?:0878\\d\\d|89(?:2|4[5-9]\\d))\\d{3}|89[45][0-4]\\d\\d|(?:1(?:44|6[346])|89(?:5[5-9]|9))\\d{6}",[6,8,9,10]],["1(?:78\\d|99)\\d{6}",[9,10]],0,0,0,["55\\d{8}",[10]],["84(?:[08]\\d{3}|[17])\\d{3}",[6,9]]]],"JE":["44","00","1534\\d{6}|(?:[3578]\\d|90)\\d{8}",[10],0,"0",0,"0|([0-24-8]\\d{5})$","1534$1",0,0,[["1534[0-24-8]\\d{5}"],["7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97[7-9]))\\d{5}"],["80(?:07(?:35|81)|8901)\\d{4}"],["(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"],["701511\\d{4}"],0,["(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"],["76(?:0[0-2]|2[356]|4[0134]|5[49]|6[0-369]|77|81|9[39])\\d{6}"],["56\\d{8}"]]],"JM":["1","011","(?:[58]\\d\\d|658|900)\\d{7}",[10],0,"1",0,0,0,0,"658|876"],"JO":["962","00","900\\d{5}|(?:(?:[268]|7\\d)\\d|32|53)\\d{6}",[8,9],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2356]|87"],"(0$1)"],["(\\d{3})(\\d{5,6})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["70"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0"],"JP":["81","010","00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}",[8,9,10,11,12,13,14,15,16,17],[["(\\d{3})(\\d{3})(\\d{3})","$1-$2-$3",["(?:12|57|99)0"],"0$1"],["(\\d{4})(\\d)(\\d{4})","$1-$2-$3",["1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51|63)|9(?:49|80|9[16])","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[78]|96)|477|51[24]|636)|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]","1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[78]|96[2457-9])|477|51[24]|636[2-57-9])|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2-$3",["[36]|4(?:2[09]|7[01])","[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[279]|49|6[0-24-689]|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9])|5(?:2|3[045]|4[0-369]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|49|6(?:[0-24]|5[0-3589]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:49|55|83)[29]|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:47[59]|59[89]|8(?:6[68]|9))[019]","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]","1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|7[015-9]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17|3[015-9]))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9(?:[019]|4[1-3]|6(?:[0-47-9]|5[01346-9])))|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:223|8699)[014-9]|(?:48|829(?:2|66)|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"],"0$1"],["(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3",["[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3[3-8]|5[2-9])","[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3(?:[3-6][2-9]|7|8[2-5])|5[2-9])"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1-$2-$3",["800"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[2579]|80"],"0$1"]],"0"],"KE":["254","000","(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}",[7,8,9,10],[["(\\d{2})(\\d{5,7})","$1 $2",["[24-6]"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[17]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0"],"KG":["996","00","(?:[235-7]\\d|99)\\d{7}|800\\d{6,7}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["3(?:1[346]|[24-79])"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[235-79]"],"0$1"],["(\\d{3})(\\d{3})(\\d)(\\d{2,3})","$1 $2 $3 $4",["8"],"0$1"]],"0"],"KH":["855","00[14-9]","1\\d{9}|[1-9]\\d{7,8}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"KI":["686","00","(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}",[5,8],0,"0"],"KM":["269","00","[3478]\\d{6}",[7],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[3478]"]]]],"KN":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-7]\\d{6})$","869$1",0,"869"],"KP":["850","00|99","85\\d{6}|(?:19\\d|2)\\d{7}",[8,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"]],"0"],"KR":["82","00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))","00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}",[5,6,8,9,10,11,12,13,14],[["(\\d{2})(\\d{3,4})","$1-$2",["(?:3[1-3]|[46][1-4]|5[1-5])1"],"0$1"],["(\\d{4})(\\d{4})","$1-$2",["1"]],["(\\d)(\\d{3,4})(\\d{4})","$1-$2-$3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1-$2-$3",["60|8"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1-$2-$3",["[1346]|5[1-5]"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2-$3",["[57]"],"0$1"],["(\\d{2})(\\d{5})(\\d{4})","$1-$2-$3",["5"],"0$1"]],"0",0,"0(8(?:[1-46-8]|5\\d\\d))?"],"KW":["965","00","(?:18|[2569]\\d\\d)\\d{5}",[7,8],[["(\\d{4})(\\d{3,4})","$1 $2",["[169]|2(?:[235]|4[1-35-9])|52"]],["(\\d{3})(\\d{5})","$1 $2",["[25]"]]]],"KY":["1","011","(?:345|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","345$1",0,"345"],"KZ":["7","810","33622\\d{5}|(?:7\\d|80)\\d{8}",[10],0,"8",0,0,0,0,"33|7",0,"8~10"],"LA":["856","00","(?:2\\d|3)\\d{8}|(?:[235-8]\\d|41)\\d{6}",[8,9,10],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2[13]|3[14]|[4-8]"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["3"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3 $4",["2"],"0$1"]],"0"],"LB":["961","00","[7-9]\\d{7}|[13-9]\\d{6}",[7,8],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"]]],"0"],"LC":["1","011","(?:[58]\\d\\d|758|900)\\d{7}",[10],0,"1",0,"1|([2-7]\\d{6})$","758$1",0,"758"],"LI":["423","00","90\\d{5}|(?:[2378]|6\\d\\d)\\d{6}",[7,9],[["(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3",["[237-9]"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["69"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]]],"0",0,"0|(10(?:01|20|66))"],"LK":["94","00","(?:[1-7]\\d|[89]1)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[1-689]"],"0$1"]],"0"],"LR":["231","00","(?:2|33|5\\d|77|88)\\d{7}|[45]\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[45]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3578]"],"0$1"]],"0"],"LS":["266","00","(?:[256]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2568]"]]]],"LT":["370","00","(?:[3469]\\d|52|[78]0)\\d{6}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["52[0-79]"],"(8-$1)",1],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[7-9]"],"8 $1",1],["(\\d{2})(\\d{6})","$1 $2",["37|4(?:[15]|6[1-8])"],"(8-$1)",1],["(\\d{3})(\\d{5})","$1 $2",["[3-6]"],"(8-$1)",1]],"8",0,"[08]"],"LU":["352","00","35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}",[4,5,6,7,8,9,10,11],[["(\\d{2})(\\d{3})","$1 $2",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["20[2-689]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4",["2(?:[0367]|4[3-8])"]],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["80[01]|90[015]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3 $4",["20"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})","$1 $2 $3 $4 $5",["2(?:[0367]|4[3-8])"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})","$1 $2 $3 $4",["[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"]]],0,0,"(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)"],"LV":["371","00","(?:[268]\\d|90)\\d{6}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[269]|8[01]"]]]],"LY":["218","00","(?:[2569]\\d|71)\\d{7}",[9],[["(\\d{2})(\\d{7})","$1-$2",["[25-79]"],"0$1"]],"0"],"MA":["212","00","[5-8]\\d{8}",[9],[["(\\d{5})(\\d{4})","$1-$2",["5(?:29|38)","5(?:29|38)[89]"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5[45]"],"0$1"],["(\\d{4})(\\d{5})","$1-$2",["5(?:2[2-489]|3[5-9]|9)|892"],"0$1"],["(\\d{2})(\\d{7})","$1-$2",["8"],"0$1"],["(\\d{3})(\\d{6})","$1-$2",["[5-7]"],"0$1"]],"0",0,0,0,0,0,[["5(?:2(?:[015-79]\\d|2[02-9]|3[2-57]|4[2-8]|8[235-7])|3(?:[0-48]\\d|[57][2-9]|6[2-8]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"],["(?:6(?:[0-79]\\d|8[0-247-9])|7(?:0[06-8]|6[1267]|7[0-27]))\\d{6}"],["80\\d{7}"],["89\\d{7}"],0,0,0,0,["5924[01]\\d{4}"]]],"MC":["377","00","870\\d{5}|(?:[349]|6\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["4"],"0$1"],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[39]"]],["(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4 $5",["6"],"0$1"]],"0"],"MD":["373","00","(?:[235-7]\\d|[89]0)\\d{6}",[8],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["22|3"],"0$1"],["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[25-7]"],"0$1"]],"0"],"ME":["382","00","(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[2-9]"],"0$1"]],"0"],"MF":["590","00","(?:590|69\\d)\\d{6}",[9],0,"0",0,0,0,0,0,[["590(?:0[079]|[14]3|[27][79]|30|5[0-268]|87)\\d{4}"],["69(?:0\\d\\d|1(?:2[29]|3[0-5]))\\d{4}"]]],"MG":["261","00","[23]\\d{8}",[9],[["(\\d{2})(\\d{2})(\\d{3})(\\d{2})","$1 $2 $3 $4",["[23]"],"0$1"]],"0",0,"0|([24-9]\\d{6})$","20$1"],"MH":["692","011","329\\d{4}|(?:[256]\\d|45)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1-$2",["[2-6]"]]],"1"],"MK":["389","00","[2-578]\\d{7}",[8],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[347]"],"0$1"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["[58]"],"0$1"]],"0"],"ML":["223","00","(?:[246-9]\\d|50)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24-9]"]]]],"MM":["95","00","1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}",[6,7,8,9,10],[["(\\d)(\\d{2})(\\d{3})","$1 $2 $3",["16|2"],"0$1"],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["[45]|6(?:0[23]|[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-6]"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[4-7]|8[1-35]"],"0$1"],["(\\d)(\\d{3})(\\d{4,6})","$1 $2 $3",["9(?:2[0-4]|[35-9]|4[137-9])"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["92"],"0$1"],["(\\d)(\\d{5})(\\d{4})","$1 $2 $3",["9"],"0$1"]],"0"],"MN":["976","001","[12]\\d{7,9}|[57-9]\\d{7}",[8,9,10],[["(\\d{2})(\\d{2})(\\d{4})","$1 $2 $3",["[12]1"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[57-9]"]],["(\\d{3})(\\d{5,6})","$1 $2",["[12]2[1-3]"],"0$1"],["(\\d{4})(\\d{5,6})","$1 $2",["[12](?:27|3[2-8]|4[2-68]|5[1-4689])","[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"],"0$1"],["(\\d{5})(\\d{4,5})","$1 $2",["[12]"],"0$1"]],"0"],"MO":["853","00","(?:28|[68]\\d)\\d{6}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[268]"]]]],"MP":["1","011","[58]\\d{9}|(?:67|90)0\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","670$1",0,"670"],"MQ":["596","00","(?:596|69\\d)\\d{6}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[56]"],"0$1"]],"0"],"MR":["222","00","(?:[2-4]\\d\\d|800)\\d{5}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2-48]"]]]],"MS":["1","011","66449\\d{5}|(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|(4\\d{6})$","664$1",0,"664"],"MT":["356","00","3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[2357-9]"]]]],"MU":["230","0(?:0|[24-7]0|3[03])","(?:[2-468]|5\\d)\\d{6}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[2-46]|8[013]"]],["(\\d{4})(\\d{4})","$1 $2",["5"]]],0,0,0,0,0,0,0,"020"],"MV":["960","0(?:0|19)","(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}",[7,10],[["(\\d{3})(\\d{4})","$1-$2",["[3467]|9[14-9]"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"]]],0,0,0,0,0,0,0,"00"],"MW":["265","00","1\\d{6}(?:\\d{2})?|(?:[23]1|77|88|99)\\d{7}",[7,9],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["1[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["3"],"0$1"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[17-9]"],"0$1"]],"0"],"MX":["52","0[09]","(?:1\\d|[2-9])\\d{9}",[10,11],[["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["33|5[56]|81"],"01 $1",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[2-9]"],"01 $1",1],["(\\d)(\\d{2})(\\d{4})(\\d{4})","$2 $3 $4",["1(?:33|5[56]|81)"],"044 $1",0,"$1 $2 $3 $4"],["(\\d)(\\d{3})(\\d{3})(\\d{4})","$2 $3 $4",["1"],"044 $1",0,"$1 $2 $3 $4"]],"01",0,"0[12]|04[45]([2-9]\\d{9})$","1$1",0,0,0,"00"],"MY":["60","00","1\\d{8,9}|(?:3\\d|[4-9])\\d{7}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["[4-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1-$2 $3",["1(?:[0249]|[367][2-9]|8[1-9])|8"],"0$1"],["(\\d)(\\d{4})(\\d{4})","$1-$2 $3",["3"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{4})","$1-$2-$3-$4",["1[36-8]"]],["(\\d{3})(\\d{3})(\\d{4})","$1-$2 $3",["15"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1-$2 $3",["1"],"0$1"]],"0"],"MZ":["258","00","(?:2|8\\d)\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["2|8[2-7]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["8"]]]],"NA":["264","00","[68]\\d{7,8}",[8,9],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["88"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["87"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["8"],"0$1"]],"0"],"NC":["687","00","[2-57-9]\\d{5}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1.$2.$3",["[2-57-9]"]]]],"NE":["227","00","[0289]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["08"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[089]|2[01]"]]]],"NF":["672","00","[13]\\d{5}",[6],[["(\\d{2})(\\d{4})","$1 $2",["1"]],["(\\d)(\\d{5})","$1 $2",["3"]]],0,0,"([0-258]\\d{4})$","3$1"],"NG":["234","009","(?:[124-7]|9\\d{3})\\d{6}|[1-9]\\d{7}|[78]\\d{9,13}",[7,8,10,11,12,13,14],[["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["78"],"0$1"],["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[12]|9(?:0[3-9]|[1-9])"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["[3-7]|8[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[7-9]"],"0$1"],["(\\d{3})(\\d{4})(\\d{4,5})","$1 $2 $3",["[78]"],"0$1"],["(\\d{3})(\\d{5})(\\d{5,6})","$1 $2 $3",["[78]"],"0$1"]],"0"],"NI":["505","00","(?:1800|[25-8]\\d{3})\\d{4}",[8],[["(\\d{4})(\\d{4})","$1 $2",["[125-8]"]]]],"NL":["31","00","(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|[89]\\d{6,9}|1\\d{4,5}",[5,6,7,8,9,10],[["(\\d{3})(\\d{4,7})","$1 $2",["[89]0"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["66"],"0$1"],["(\\d)(\\d{8})","$1 $2",["6"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-57-9]"],"0$1"]],"0"],"NO":["47","00","(?:0|[2-9]\\d{3})\\d{4}",[5,8],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[489]"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[235-7]"]]],0,0,0,0,0,"[02-689]|7[0-8]"],"NP":["977","00","9\\d{9}|[1-9]\\d{7}",[8,10],[["(\\d)(\\d{7})","$1-$2",["1[2-6]"],"0$1"],["(\\d{2})(\\d{6})","$1-$2",["[1-8]|9(?:[1-579]|6[2-6])"],"0$1"],["(\\d{3})(\\d{7})","$1-$2",["9"]]],"0"],"NR":["674","00","(?:444|55\\d|888)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[458]"]]]],"NU":["683","00","(?:[47]|888\\d)\\d{3}",[4,7],[["(\\d{3})(\\d{4})","$1 $2",["8"]]]],"NZ":["64","0(?:0|161)","[28]\\d{7,9}|[346]\\d{7}|(?:508|[79]\\d)\\d{6,7}",[8,9,10],[["(\\d{3})(\\d{2})(\\d{3})","$1 $2 $3",["[89]0"],"0$1"],["(\\d)(\\d{3})(\\d{4})","$1-$2 $3",["24|[346]|7[2-57-9]|9[2-9]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:10|74)|[59]|80"],"0$1"],["(\\d{2})(\\d{3,4})(\\d{4})","$1 $2 $3",["2[028]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,5})","$1 $2 $3",["2(?:[169]|7[0-35-9])|7|86"],"0$1"]],"0",0,0,0,0,0,0,"00"],"OM":["968","00","(?:[279]\\d{3}|500)\\d{4}|8007\\d{4,5}",[7,8,9],[["(\\d{3})(\\d{4,6})","$1 $2",["[58]"]],["(\\d{2})(\\d{6})","$1 $2",["2"]],["(\\d{4})(\\d{4})","$1 $2",["[79]"]]]],"PA":["507","00","(?:[1-57-9]|6\\d)\\d{6}",[7,8],[["(\\d{3})(\\d{4})","$1-$2",["[1-57-9]"]],["(\\d{4})(\\d{4})","$1-$2",["6"]]]],"PE":["51","19(?:1[124]|77|90)00","(?:[14-8]|9\\d)\\d{7}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["80"],"(0$1)"],["(\\d)(\\d{7})","$1 $2",["1"],"(0$1)"],["(\\d{2})(\\d{6})","$1 $2",["[4-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"]]],"0",0,0,0,0,0,0,0," Anexo "],"PF":["689","00","[48]\\d{7}|4\\d{5}",[6,8],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["44"]],["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[48]"]]]],"PG":["675","00|140[1-3]","(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["18|[2-69]|85"]],["(\\d{4})(\\d{4})","$1 $2",["[78]"]]],0,0,0,0,0,0,0,"00"],"PH":["63","00","(?:1800|8)\\d{7,9}|2\\d{5}(?:\\d{2})?|(?:[3-7]|9\\d)\\d{8}",[6,8,9,10,11,12,13],[["(\\d)(\\d{5})","$1 $2",["2"],"(0$1)"],["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"(0$1)"],["(\\d{4})(\\d{4,6})","$1 $2",["3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2","3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"],"(0$1)"],["(\\d{5})(\\d{4})","$1 $2",["346|4(?:27|9[35])|883","3469|4(?:279|9(?:30|56))|8834"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[3-7]|8[2-8]"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]],["(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})","$1 $2 $3 $4",["1"]]],"0"],"PK":["92","00","122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[025-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}",[8,9,10,11,12],[["(\\d{3})(\\d{3})(\\d{2})","$1 $2 $3",["[89]0"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["1"]],["(\\d{2})(\\d{7,8})","$1 $2",["(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"],"(0$1)"],["(\\d{3})(\\d{6,7})","$1 $2",["2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])","9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"],"(0$1)"],["(\\d{5})(\\d{5})","$1 $2",["58"],"(0$1)"],["(\\d{3})(\\d{7})","$1 $2",["3"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"],"(0$1)"],["(\\d{3})(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3 $4",["[24-9]"],"(0$1)"]],"0"],"PL":["48","00","[1-57-9]\\d{6}(?:\\d{2})?|6\\d{5,8}",[6,7,8,9],[["(\\d{5})","$1",["19"]],["(\\d{3})(\\d{3})","$1 $2",["11|64"]],["(\\d{2})(\\d{2})(\\d{3})","$1 $2 $3",["(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1","(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"]],["(\\d{3})(\\d{2})(\\d{2,3})","$1 $2 $3",["64"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["39|45|5[0137]|6[0469]|7[02389]|8[08]"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["1[2-8]|[2-8]|9[145]"]]]],"PM":["508","00","[45]\\d{5}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[45]"],"0$1"]],"0"],"PR":["1","011","(?:[589]\\d\\d|787)\\d{7}",[10],0,"1",0,0,0,0,"787|939"],"PS":["970","00","[2489]2\\d{6}|(?:1\\d|5)\\d{8}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["[2489]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["5"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"PT":["351","00","(?:[26-9]\\d|30)\\d{7}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["2[12]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[236-9]"]]]],"PW":["680","01[12]","(?:[25-8]\\d\\d|345|488|900)\\d{4}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[2-9]"]]]],"PY":["595","00","59\\d{4,6}|(?:[2-46-9]\\d|5[0-8])\\d{4,7}",[6,7,8,9],[["(\\d{3})(\\d{3,6})","$1 $2",["[2-9]0"],"0$1"],["(\\d{2})(\\d{5})","$1 $2",["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"],"(0$1)"],["(\\d{3})(\\d{4,5})","$1 $2",["2[279]|3[13-5]|4[359]|5|6[347]|7[46-8]|85"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["87"]],["(\\d{3})(\\d{6})","$1 $2",["9"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[2-8]"],"0$1"]],"0"],"QA":["974","00","800\\d{4}|(?:2|[3-7]\\d)\\d{6}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["2[126]|8"]],["(\\d{4})(\\d{4})","$1 $2",["[3-7]"]]]],"RE":["262","00","(?:26|[68]\\d)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[268]"],"0$1"]],"0",0,0,0,0,"262|69|8"],"RO":["40","00","(?:[237]\\d|[89]0)\\d{7}|[23]\\d{5}",[6,9],[["(\\d{3})(\\d{3})","$1 $2",["2[3-6]","2[3-6]\\d9"],"0$1"],["(\\d{2})(\\d{4})","$1 $2",["219|31"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[23]1"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[237-9]"],"0$1"]],"0",0,0,0,0,0,0,0," int "],"RS":["381","00","38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}",[6,7,8,9,10,11,12],[["(\\d{3})(\\d{3,9})","$1 $2",["(?:2[389]|39)0|[7-9]"],"0$1"],["(\\d{2})(\\d{5,10})","$1 $2",["[1-36]"],"0$1"]],"0"],"RU":["7","810","[347-9]\\d{9}",[10],[["(\\d{4})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-8]|2[1-9])","7(?:1(?:[0-6]2|7|8[27])|2(?:1[23]|[2-9]2))","7(?:1(?:[0-6]2|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"],"8 ($1)",1],["(\\d{5})(\\d)(\\d{2})(\\d{2})","$1 $2 $3 $4",["7(?:1[0-68]|2[1-9])","7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))","7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"8 ($1)",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2-$3-$4",["[3489]"],"8 ($1)",1]],"8",0,0,0,0,"3[04-689]|[489]",0,"8~10"],"RW":["250","00","(?:06|[27]\\d\\d|[89]00)\\d{6}",[8,9],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["0"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["2"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[7-9]"],"0$1"]],"0"],"SA":["966","00","92\\d{7}|(?:[15]|8\\d)\\d{8}",[9,10],[["(\\d{4})(\\d{5})","$1 $2",["9"]],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["1"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["5"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["81"],"0$1"],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]]],"0"],"SB":["677","0[01]","(?:[1-6]|[7-9]\\d\\d)\\d{4}",[5,7],[["(\\d{2})(\\d{5})","$1 $2",["7|8[4-9]|9(?:[1-8]|9[0-8])"]]]],"SC":["248","010|0[0-2]","8000\\d{3}|(?:[249]\\d|64)\\d{5}",[7],[["(\\d)(\\d{3})(\\d{3})","$1 $2 $3",["[246]"]]],0,0,0,0,0,0,0,"00"],"SD":["249","00","[19]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[19]"],"0$1"]],"0"],"SE":["46","00","(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}",[6,7,8,9,10],[["(\\d{2})(\\d{2,3})(\\d{2})","$1-$2 $3",["20"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{4})","$1-$2",["9(?:00|39|44)"],"0$1",0,"$1 $2"],["(\\d{2})(\\d{3})(\\d{2})","$1-$2 $3",["[12][136]|3[356]|4[0246]|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3"],["(\\d)(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2,3})(\\d{2})","$1-$2 $3",["1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3"],["(\\d{3})(\\d{2,3})(\\d{3})","$1-$2 $3",["9(?:00|39|44)"],"0$1",0,"$1 $2 $3"],["(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["1[013689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"],"0$1",0,"$1 $2 $3 $4"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4",["7"],"0$1",0,"$1 $2 $3 $4"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1-$2 $3 $4",["8"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1-$2 $3 $4",["[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{2})(\\d{3})","$1-$2 $3 $4",["9"],"0$1",0,"$1 $2 $3 $4"],["(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1-$2 $3 $4 $5",["[26]"],"0$1",0,"$1 $2 $3 $4 $5"]],"0"],"SG":["65","0[0-3]\\d","(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}",[8,10,11],[["(\\d{4})(\\d{4})","$1 $2",["[369]|8[1-8]"]],["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["8"]],["(\\d{4})(\\d{4})(\\d{3})","$1 $2 $3",["7"]],["(\\d{4})(\\d{3})(\\d{4})","$1 $2 $3",["1"]]]],"SH":["290","00","(?:[256]\\d|8)\\d{3}",[4,5],0,0,0,0,0,0,"[256]"],"SI":["386","00|10(?:22|66|88|99)","[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}",[5,6,7,8],[["(\\d{2})(\\d{3,6})","$1 $2",["8[09]|9"],"0$1"],["(\\d{3})(\\d{5})","$1 $2",["59|8"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[37][01]|4[0139]|51|6"],"0$1"],["(\\d)(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[1-57]"],"(0$1)"]],"0",0,0,0,0,0,0,"00"],"SJ":["47","00","0\\d{4}|(?:[4589]\\d|79)\\d{6}",[5,8],0,0,0,0,0,0,"79"],"SK":["421","00","[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}",[6,7,9],[["(\\d)(\\d{2})(\\d{3,4})","$1 $2 $3",["21"],"0$1"],["(\\d{2})(\\d{2})(\\d{2,3})","$1 $2 $3",["[3-5][1-8]1","[3-5][1-8]1[67]"],"0$1"],["(\\d)(\\d{3})(\\d{3})(\\d{2})","$1/$2 $3 $4",["2"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[689]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1/$2 $3 $4",["[3-5]"],"0$1"]],"0"],"SL":["232","00","(?:[2-578]\\d|66|99)\\d{6}",[8],[["(\\d{2})(\\d{6})","$1 $2",["[2-9]"],"(0$1)"]],"0"],"SM":["378","00","(?:0549|[5-7]\\d)\\d{6}",[8,10],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[5-7]"]],["(\\d{4})(\\d{6})","$1 $2",["0"]]],0,0,"([89]\\d{5})$","0549$1"],"SN":["221","00","(?:[378]\\d{4}|93330)\\d{4}",[9],[["(\\d{3})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["8"]],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[379]"]]]],"SO":["252","00","[346-9]\\d{8}|[12679]\\d{7}|(?:[1-4]\\d|59)\\d{5}|[1348]\\d{5}",[6,7,8,9],[["(\\d{2})(\\d{4})","$1 $2",["8[125]"]],["(\\d{6})","$1",["[134]"]],["(\\d)(\\d{6})","$1 $2",["1|2[0-79]|3[0-46-8]|4[0-7]|59"]],["(\\d)(\\d{7})","$1 $2",["24|[67]"]],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[348]|64|79[0-8]|90"]],["(\\d{2})(\\d{5,7})","$1 $2",["1|28|6[1-35-9]|799|9[2-9]"]]],"0"],"SR":["597","00","(?:[2-5]|68|[78]\\d)\\d{5}",[6,7],[["(\\d{2})(\\d{2})(\\d{2})","$1-$2-$3",["56"]],["(\\d{3})(\\d{3})","$1-$2",["[2-5]"]],["(\\d{3})(\\d{4})","$1-$2",["[6-8]"]]]],"SS":["211","00","[19]\\d{8}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[19]"],"0$1"]],"0"],"ST":["239","00","(?:22|9\\d)\\d{5}",[7],[["(\\d{3})(\\d{4})","$1 $2",["[29]"]]]],"SV":["503","00","[267]\\d{7}|[89]00\\d{4}(?:\\d{4})?",[7,8,11],[["(\\d{3})(\\d{4})","$1 $2",["[89]"]],["(\\d{4})(\\d{4})","$1 $2",["[267]"]],["(\\d{3})(\\d{4})(\\d{4})","$1 $2 $3",["[89]"]]]],"SX":["1","011","7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|(5\\d{6})$","721$1",0,"721"],"SY":["963","00","[1-39]\\d{8}|[1-5]\\d{7}",[8,9],[["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-5]"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1",1]],"0"],"SZ":["268","00","0800\\d{4}|(?:[237]\\d|900)\\d{6}",[8,9],[["(\\d{4})(\\d{4})","$1 $2",["[0237]"]],["(\\d{5})(\\d{4})","$1 $2",["9"]]]],"TA":["290","00","8\\d{3}",[4],0,0,0,0,0,0,"8"],"TC":["1","011","(?:[58]\\d\\d|649|900)\\d{7}",[10],0,"1",0,"1|([2-479]\\d{6})$","649$1",0,"649"],"TD":["235","00|16","(?:22|[69]\\d|77)\\d{6}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[2679]"]]],0,0,0,0,0,0,0,"00"],"TG":["228","00","[279]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[279]"]]]],"TH":["66","00[1-9]","1\\d{8,9}|(?:[2-57]|[689]\\d)\\d{7}",[8,9,10],[["(\\d)(\\d{3})(\\d{4})","$1 $2 $3",["2"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["14|[3-9]"],"0$1"],["(\\d{4})(\\d{3})(\\d{3})","$1 $2 $3",["1"]]],"0"],"TJ":["992","810","(?:[3-59]\\d|77|88)\\d{7}",[9],[["(\\d{6})(\\d)(\\d{2})","$1 $2 $3",["331","3317"],0,1],["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[34]7|91[78]"],0,1],["(\\d{4})(\\d)(\\d{4})","$1 $2 $3",["3"],0,1],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[457-9]"],0,1]],"8",0,0,0,0,0,0,"8~10"],"TK":["690","00","[2-47]\\d{3,6}",[4,5,6,7]],"TL":["670","00","7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["[2-489]|70"]],["(\\d{4})(\\d{4})","$1 $2",["7"]]]],"TM":["993","810","[1-6]\\d{7}",[8],[["(\\d{2})(\\d{2})(\\d{2})(\\d{2})","$1 $2-$3-$4",["12"],"(8 $1)"],["(\\d{3})(\\d)(\\d{2})(\\d{2})","$1 $2-$3-$4",["[1-5]"],"(8 $1)"],["(\\d{2})(\\d{6})","$1 $2",["6"],"8 $1"]],"8",0,0,0,0,0,0,"8~10"],"TN":["216","00","[2-57-9]\\d{7}",[8],[["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-57-9]"]]]],"TO":["676","00","[78]\\d{6}|[2-478]\\d{4}|(?:080|[56])0\\d{3}",[5,7],[["(\\d{2})(\\d{3})","$1-$2",["[2-6]|7[014]|8[05]"]],["(\\d{4})(\\d{3})","$1 $2",["0"]],["(\\d{3})(\\d{4})","$1 $2",["7[578]|8"]]]],"TR":["90","00","(?:[2-58]\\d\\d|900)\\d{7}|4\\d{6}",[7,10],[["(\\d{3})(\\d{3})(\\d{4})","$1 $2 $3",["512|8[0589]|90"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["5(?:[0-59]|61)","5(?:[0-59]|616)","5(?:[0-59]|6161)"],"0$1",1],["(\\d{3})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[24][1-8]|3[1-9]"],"(0$1)",1]],"0"],"TT":["1","011","(?:[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-46-8]\\d{6})$","868$1",0,"868"],"TV":["688","00","(?:2|7\\d\\d|90)\\d{4}",[5,6,7]],"TW":["886","0(?:0[25-79]|19)","(?:[24589]|7\\d)\\d{8}|[2-8]\\d{7}|2\\d{6}",[7,8,9,10],[["(\\d{2})(\\d)(\\d{4})","$1 $2 $3",["202"],"0$1"],["(\\d)(\\d{3,4})(\\d{4})","$1 $2 $3",["[25][2-8]|[346]|7[1-9]|8[237-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[258]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["7"],"0$1"]],"0",0,0,0,0,0,0,0,"#"],"TZ":["255","00[056]","(?:[26-8]\\d|41|90)\\d{7}",[9],[["(\\d{3})(\\d{2})(\\d{4})","$1 $2 $3",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[24]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[67]"],"0$1"]],"0"],"UA":["380","00","[89]\\d{9}|[3-9]\\d{8}",[9,10],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]","6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["4[45][0-5]|5(?:0|6[37])|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]","4[45][0-5]|5(?:0|6(?:3[14-7]|7))|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]"],"0$1"],["(\\d{4})(\\d{5})","$1 $2",["[3-6]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["[89]"],"0$1"]],"0",0,0,0,0,0,0,"0~0"],"UG":["256","00[057]","800\\d{6}|(?:[29]0|[347]\\d)\\d{7}",[9],[["(\\d{4})(\\d{5})","$1 $2",["202","2024"],"0$1"],["(\\d{3})(\\d{6})","$1 $2",["[27-9]|4(?:6[45]|[7-9])"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[34]"],"0$1"]],"0"],"US":["1","011","[2-9]\\d{9}",[10],[["(\\d{3})(\\d{3})(\\d{4})","($1) $2-$3",["[2-9]"],0,1,"$1-$2-$3"]],"1",0,0,0,0,0,[["(?:2(?:0[1-35-9]|1[02-9]|2[03-589]|3[149]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-57-9]|1[02-9]|2[0135]|3[0-24679]|4[67]|5[12]|6[014]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[0235]|58|6[39]|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[19]|6[1-47]|7[013-5]|8[056])|6(?:0[1-35-9]|1[024-9]|2[03689]|[34][016]|5[017]|6[0-279]|78|8[0-2])|7(?:0[1-46-8]|1[2-9]|2[04-7]|3[1247]|4[037]|5[47]|6[02359]|7[02-59]|8[156])|8(?:0[1-68]|1[02-8]|2[08]|3[0-28]|4[3578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[0179]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}"],[""],["8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"],["900[2-9]\\d{6}"],["5(?:00|2[12]|33|44|66|77|88)[2-9]\\d{6}"],0,["710[2-9]\\d{6}"]]],"UY":["598","0(?:0|1[3-9]\\d)","(?:[249]\\d\\d|80)\\d{5}|9\\d{6}",[7,8],[["(\\d{3})(\\d{4})","$1 $2",["8|90"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["9"],"0$1"],["(\\d{4})(\\d{4})","$1 $2",["[24]"]]],"0",0,0,0,0,0,0,"00"," int. "],"UZ":["998","810","[679]\\d{8}",[9],[["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[679]"],"8 $1"]],"8",0,0,0,0,0,0,"8~10"],"VA":["39","00","0\\d{6,10}|55\\d{8}|[08]\\d{5}|(?:3[0-8]|8)\\d{7,9}|(?:1\\d|39)\\d{7,8}",[6,7,8,9,10,11],0,0,0,0,0,0,"06698"],"VC":["1","011","(?:[58]\\d\\d|784|900)\\d{7}",[10],0,"1",0,"1|([2-7]\\d{6})$","784$1",0,"784"],"VE":["58","00","[89]00\\d{7}|(?:[24]\\d|50)\\d{8}",[10],[["(\\d{3})(\\d{7})","$1-$2",["[24589]"],"0$1"]],"0"],"VG":["1","011","(?:284|[58]\\d\\d|900)\\d{7}",[10],0,"1",0,"1|([2-578]\\d{6})$","284$1",0,"284"],"VI":["1","011","[58]\\d{9}|(?:34|90)0\\d{7}",[10],0,"1",0,"1|([2-9]\\d{6})$","340$1",0,"340"],"VN":["84","00","[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}",[7,8,9,10],[["(\\d{2})(\\d{5})","$1 $2",["80"],"0$1",1],["(\\d{4})(\\d{4,6})","$1 $2",["1"],0,1],["(\\d{2})(\\d{3})(\\d{2})(\\d{2})","$1 $2 $3 $4",["[69]"],"0$1",1],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[3578]"],"0$1",1],["(\\d{2})(\\d{4})(\\d{4})","$1 $2 $3",["2[48]"],"0$1",1],["(\\d{3})(\\d{4})(\\d{3})","$1 $2 $3",["2"],"0$1",1]],"0"],"VU":["678","00","(?:[23]\\d|[48]8)\\d{3}|(?:[57]\\d|90)\\d{5}",[5,7],[["(\\d{3})(\\d{4})","$1 $2",["[579]"]]]],"WF":["681","00","(?:[45]0|68|72|8\\d)\\d{4}",[6],[["(\\d{2})(\\d{2})(\\d{2})","$1 $2 $3",["[4-8]"]]]],"WS":["685","0","[2-6]\\d{4}|8\\d{5}(?:\\d{4})?|[78]\\d{6}",[5,6,7,10],[["(\\d{5})","$1",["[2-6]"]],["(\\d{3})(\\d{3,7})","$1 $2",["8"]],["(\\d{2})(\\d{5})","$1 $2",["7"]]]],"XK":["383","00","[23]\\d{7,8}|(?:4\\d\\d|[89]00)\\d{5}",[8,9],[["(\\d{3})(\\d{5})","$1 $2",["[89]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3})","$1 $2 $3",["[2-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[23]"],"0$1"]],"0"],"YE":["967","00","(?:1|7\\d)\\d{7}|[1-7]\\d{6}",[7,8,9],[["(\\d)(\\d{3})(\\d{3,4})","$1 $2 $3",["[1-6]|7[24-68]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["7"],"0$1"]],"0"],"YT":["262","00","80\\d{7}|(?:26|63)9\\d{6}",[9],0,"0",0,0,0,0,"269|63"],"ZA":["27","00","[1-9]\\d{8}|8\\d{4,7}",[5,6,7,8,9],[["(\\d{2})(\\d{3,4})","$1 $2",["8[1-4]"],"0$1"],["(\\d{2})(\\d{3})(\\d{2,3})","$1 $2 $3",["8[1-4]"],"0$1"],["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["860"],"0$1"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["[1-9]"],"0$1"]],"0"],"ZM":["260","00","800\\d{6}|(?:21|76|9\\d)\\d{7}",[9],[["(\\d{3})(\\d{3})(\\d{3})","$1 $2 $3",["[28]"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["[79]"],"0$1"]],"0"],"ZW":["263","00","2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}",[5,6,7,8,9,10],[["(\\d{3})(\\d{3,5})","$1 $2",["2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"],"0$1"],["(\\d)(\\d{3})(\\d{2,4})","$1 $2 $3",["[49]"],"0$1"],["(\\d{3})(\\d{4})","$1 $2",["80"],"0$1"],["(\\d{2})(\\d{7})","$1 $2",["24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2","2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"],"(0$1)"],["(\\d{2})(\\d{3})(\\d{4})","$1 $2 $3",["7"],"0$1"],["(\\d{3})(\\d{3})(\\d{3,4})","$1 $2 $3",["2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)","2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"],"0$1"],["(\\d{4})(\\d{6})","$1 $2",["8"],"0$1"],["(\\d{2})(\\d{3,5})","$1 $2",["1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"],"0$1"],["(\\d{2})(\\d{3})(\\d{3,4})","$1 $2 $3",["29[013-9]|39|54"],"0$1"],["(\\d{4})(\\d{3,5})","$1 $2",["(?:25|54)8","258|5483"],"0$1"]],"0"],"001":["979",0,"\\d{9}",[9],[["(\\d)(\\d{4})(\\d{4})","$1 $2 $3"]]]}};

  // The minimum length of the national significant number.
  var MIN_LENGTH_FOR_NSN = 2;

  // The ITU says the maximum length should be 15,
  // but one can find longer numbers in Germany.
  var MAX_LENGTH_FOR_NSN = 17;

  // The maximum length of the country calling code.
  var MAX_LENGTH_COUNTRY_CODE = 3;

  // Digits accepted in phone numbers
  // (ascii, fullwidth, arabic-indic, and eastern arabic digits).
  var VALID_DIGITS = '0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9';

  // `DASHES` will be right after the opening square bracket of the "character class"
  var DASHES = '-\u2010-\u2015\u2212\u30FC\uFF0D';
  var SLASHES = '\uFF0F/';
  var DOTS = '\uFF0E.';
  var WHITESPACE = ' \xA0\xAD\u200B\u2060\u3000';
  var BRACKETS = '()\uFF08\uFF09\uFF3B\uFF3D\\[\\]';
  // export const OPENING_BRACKETS = '(\uFF08\uFF3B\\\['
  var TILDES = '~\u2053\u223C\uFF5E';

  // Regular expression of acceptable punctuation found in phone numbers. This
  // excludes punctuation found as a leading character only. This consists of dash
  // characters, white space characters, full stops, slashes, square brackets,
  // parentheses and tildes. Full-width variants are also present.
  var VALID_PUNCTUATION = '' + DASHES + SLASHES + DOTS + WHITESPACE + BRACKETS + TILDES;

  var PLUS_CHARS = '+\uFF0B';
  // const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')

  // Checks whether the entire input sequence can be matched
  // against the regular expression.
  function matchesEntirely() {
  	var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  	var regular_expression = arguments[1];

  	return new RegExp('^(?:' + regular_expression + ')$').test(text);
  }

  /**
   * Merges two arrays.
   * @param  {*} a
   * @param  {*} b
   * @return {*}
   */
  function mergeArrays(a, b) {
  	var merged = a.slice();

  	for (var _iterator = b, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  		var _ref;

  		if (_isArray) {
  			if (_i >= _iterator.length) { break; }
  			_ref = _iterator[_i++];
  		} else {
  			_i = _iterator.next();
  			if (_i.done) { break; }
  			_ref = _i.value;
  		}

  		var element = _ref;

  		if (a.indexOf(element) < 0) {
  			merged.push(element);
  		}
  	}

  	return merged.sort(function (a, b) {
  		return a - b;
  	});

  	// ES6 version, requires Set polyfill.
  	// let merged = new Set(a)
  	// for (const element of b)
  	// {
  	// 	merged.add(i)
  	// }
  	// return Array.from(merged).sort((a, b) => a - b)
  }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  // https://stackoverflow.com/a/46971044/970769
  var ParseError = function ParseError(code) {
    _classCallCheck(this, ParseError);

    this.name = this.constructor.name;
    this.message = code;
    this.stack = new Error(code).stack;
  };


  ParseError.prototype = Object.create(Error.prototype);
  ParseError.prototype.constructor = ParseError;

  // Copy-pasted from:
  // https://github.com/substack/semver-compare/blob/master/index.js
  //
  // Inlining this function because some users reported issues with
  // importing from `semver-compare` in a browser with ES6 "native" modules.
  function cmp(a, b) {
      var pa = a.split('.');
      var pb = b.split('.');
      for (var i = 0; i < 3; i++) {
          var na = Number(pa[i]);
          var nb = Number(pb[i]);
          if (na > nb) { return 1; }
          if (nb > na) { return -1; }
          if (!isNaN(na) && isNaN(nb)) { return 1; }
          if (isNaN(na) && !isNaN(nb)) { return -1; }
      }
      return 0;
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

  function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  // Added "idd_prefix" and "default_idd_prefix".
  var V3 = '1.2.0';

  var DEFAULT_EXT_PREFIX = ' ext. ';

  var Metadata = function () {
  	function Metadata(metadata) {
  		_classCallCheck$1(this, Metadata);

  		validateMetadata(metadata);

  		this.metadata = metadata;

  		this.v1 = !metadata.version;
  		this.v2 = metadata.version !== undefined && cmp(metadata.version, V3) === -1;
  		this.v3 = metadata.version !== undefined; // && compare(metadata.version, V4) === -1
  	}

  	_createClass(Metadata, [{
  		key: 'hasCountry',
  		value: function hasCountry(country) {
  			return this.metadata.countries[country] !== undefined;
  		}
  	}, {
  		key: 'country',
  		value: function country(_country) {
  			if (!_country) {
  				this._country = undefined;
  				this.country_metadata = undefined;
  				return this;
  			}

  			if (!this.hasCountry(_country)) {
  				throw new Error('Unknown country: ' + _country);
  			}

  			this._country = _country;
  			this.country_metadata = this.metadata.countries[_country];
  			return this;
  		}
  	}, {
  		key: 'getDefaultCountryMetadataForRegion',
  		value: function getDefaultCountryMetadataForRegion() {
  			return this.metadata.countries[this.countryCallingCodes()[this.countryCallingCode()][0]];
  		}
  	}, {
  		key: 'countryCallingCode',
  		value: function countryCallingCode() {
  			return this.country_metadata[0];
  		}
  	}, {
  		key: 'IDDPrefix',
  		value: function IDDPrefix() {
  			if (this.v1 || this.v2) { return; }
  			return this.country_metadata[1];
  		}
  	}, {
  		key: 'defaultIDDPrefix',
  		value: function defaultIDDPrefix() {
  			if (this.v1 || this.v2) { return; }
  			return this.country_metadata[12];
  		}
  	}, {
  		key: 'nationalNumberPattern',
  		value: function nationalNumberPattern() {
  			if (this.v1 || this.v2) { return this.country_metadata[1]; }
  			return this.country_metadata[2];
  		}
  	}, {
  		key: 'possibleLengths',
  		value: function possibleLengths() {
  			if (this.v1) { return; }
  			return this.country_metadata[this.v2 ? 2 : 3];
  		}
  	}, {
  		key: '_getFormats',
  		value: function _getFormats(country_metadata) {
  			return country_metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
  		}

  		// For countries of the same region (e.g. NANPA)
  		// formats are all stored in the "main" country for that region.
  		// E.g. "RU" and "KZ", "US" and "CA".

  	}, {
  		key: 'formats',
  		value: function formats() {
  			var _this = this;

  			var formats = this._getFormats(this.country_metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
  			return formats.map(function (_) {
  				return new Format(_, _this);
  			});
  		}
  	}, {
  		key: 'nationalPrefix',
  		value: function nationalPrefix() {
  			return this.country_metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
  		}
  	}, {
  		key: '_getNationalPrefixFormattingRule',
  		value: function _getNationalPrefixFormattingRule(country_metadata) {
  			return country_metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
  		}

  		// For countries of the same region (e.g. NANPA)
  		// national prefix formatting rule is stored in the "main" country for that region.
  		// E.g. "RU" and "KZ", "US" and "CA".

  	}, {
  		key: 'nationalPrefixFormattingRule',
  		value: function nationalPrefixFormattingRule() {
  			return this._getNationalPrefixFormattingRule(this.country_metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
  		}
  	}, {
  		key: 'nationalPrefixForParsing',
  		value: function nationalPrefixForParsing() {
  			// If `national_prefix_for_parsing` is not set explicitly,
  			// then infer it from `national_prefix` (if any)
  			return this.country_metadata[this.v1 ? 5 : this.v2 ? 6 : 7] || this.nationalPrefix();
  		}
  	}, {
  		key: 'nationalPrefixTransformRule',
  		value: function nationalPrefixTransformRule() {
  			return this.country_metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
  		}
  	}, {
  		key: '_getNationalPrefixIsOptionalWhenFormatting',
  		value: function _getNationalPrefixIsOptionalWhenFormatting() {
  			return !!this.country_metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
  		}

  		// For countries of the same region (e.g. NANPA)
  		// "national prefix is optional when parsing" flag is
  		// stored in the "main" country for that region.
  		// E.g. "RU" and "KZ", "US" and "CA".

  	}, {
  		key: 'nationalPrefixIsOptionalWhenFormatting',
  		value: function nationalPrefixIsOptionalWhenFormatting() {
  			return this._getNationalPrefixIsOptionalWhenFormatting(this.country_metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
  		}
  	}, {
  		key: 'leadingDigits',
  		value: function leadingDigits() {
  			return this.country_metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
  		}
  	}, {
  		key: 'types',
  		value: function types() {
  			return this.country_metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
  		}
  	}, {
  		key: 'hasTypes',
  		value: function hasTypes() {
  			// Versions 1.2.0 - 1.2.4: can be `[]`.
  			/* istanbul ignore next */
  			if (this.types() && this.types().length === 0) {
  				return false;
  			}
  			// Versions <= 1.2.4: can be `undefined`.
  			// Version >= 1.2.5: can be `0`.
  			return !!this.types();
  		}
  	}, {
  		key: 'type',
  		value: function type(_type) {
  			if (this.hasTypes() && getType(this.types(), _type)) {
  				return new Type(getType(this.types(), _type), this);
  			}
  		}
  	}, {
  		key: 'ext',
  		value: function ext() {
  			if (this.v1 || this.v2) { return DEFAULT_EXT_PREFIX; }
  			return this.country_metadata[13] || DEFAULT_EXT_PREFIX;
  		}
  	}, {
  		key: 'countryCallingCodes',
  		value: function countryCallingCodes() {
  			if (this.v1) { return this.metadata.country_phone_code_to_countries; }
  			return this.metadata.country_calling_codes;
  		}

  		// Formatting information for regions which share
  		// a country calling code is contained by only one region
  		// for performance reasons. For example, for NANPA region
  		// ("North American Numbering Plan Administration",
  		//  which includes USA, Canada, Cayman Islands, Bahamas, etc)
  		// it will be contained in the metadata for `US`.
  		//
  		// `country_calling_code` is always valid.
  		// But the actual country may not necessarily be part of the metadata.
  		//

  	}, {
  		key: 'chooseCountryByCountryCallingCode',
  		value: function chooseCountryByCountryCallingCode(country_calling_code) {
  			var country = this.countryCallingCodes()[country_calling_code][0];

  			// Do not want to test this case.
  			// (custom metadata, not all countries).
  			/* istanbul ignore else */
  			if (this.hasCountry(country)) {
  				this.country(country);
  			}
  		}
  	}, {
  		key: 'selectedCountry',
  		value: function selectedCountry() {
  			return this._country;
  		}
  	}]);

  	return Metadata;
  }();

  var Format = function () {
  	function Format(format, metadata) {
  		_classCallCheck$1(this, Format);

  		this._format = format;
  		this.metadata = metadata;
  	}

  	_createClass(Format, [{
  		key: 'pattern',
  		value: function pattern() {
  			return this._format[0];
  		}
  	}, {
  		key: 'format',
  		value: function format() {
  			return this._format[1];
  		}
  	}, {
  		key: 'leadingDigitsPatterns',
  		value: function leadingDigitsPatterns() {
  			return this._format[2] || [];
  		}
  	}, {
  		key: 'nationalPrefixFormattingRule',
  		value: function nationalPrefixFormattingRule() {
  			return this._format[3] || this.metadata.nationalPrefixFormattingRule();
  		}
  	}, {
  		key: 'nationalPrefixIsOptionalWhenFormatting',
  		value: function nationalPrefixIsOptionalWhenFormatting() {
  			return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormatting();
  		}
  	}, {
  		key: 'nationalPrefixIsMandatoryWhenFormatting',
  		value: function nationalPrefixIsMandatoryWhenFormatting() {
  			// National prefix is omitted if there's no national prefix formatting rule
  			// set for this country, or when the national prefix formatting rule
  			// contains no national prefix itself, or when this rule is set but
  			// national prefix is optional for this phone number format
  			// (and it is not enforced explicitly)
  			return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormatting();
  		}

  		// Checks whether national prefix formatting rule contains national prefix.

  	}, {
  		key: 'usesNationalPrefix',
  		value: function usesNationalPrefix() {
  			return this.nationalPrefixFormattingRule() &&
  			// Check that national prefix formatting rule is not a dummy one.
  			this.nationalPrefixFormattingRule() !== '$1' &&
  			// Check that national prefix formatting rule actually has national prefix digit(s).
  			/\d/.test(this.nationalPrefixFormattingRule().replace('$1', ''));
  		}
  	}, {
  		key: 'internationalFormat',
  		value: function internationalFormat() {
  			return this._format[5] || this.format();
  		}
  	}]);

  	return Format;
  }();

  var Type = function () {
  	function Type(type, metadata) {
  		_classCallCheck$1(this, Type);

  		this.type = type;
  		this.metadata = metadata;
  	}

  	_createClass(Type, [{
  		key: 'pattern',
  		value: function pattern() {
  			if (this.metadata.v1) { return this.type; }
  			return this.type[0];
  		}
  	}, {
  		key: 'possibleLengths',
  		value: function possibleLengths() {
  			if (this.metadata.v1) { return; }
  			return this.type[1] || this.metadata.possibleLengths();
  		}
  	}]);

  	return Type;
  }();

  function getType(types, type) {
  	switch (type) {
  		case 'FIXED_LINE':
  			return types[0];
  		case 'MOBILE':
  			return types[1];
  		case 'TOLL_FREE':
  			return types[2];
  		case 'PREMIUM_RATE':
  			return types[3];
  		case 'PERSONAL_NUMBER':
  			return types[4];
  		case 'VOICEMAIL':
  			return types[5];
  		case 'UAN':
  			return types[6];
  		case 'PAGER':
  			return types[7];
  		case 'VOIP':
  			return types[8];
  		case 'SHARED_COST':
  			return types[9];
  	}
  }

  function validateMetadata(metadata) {
  	if (!metadata) {
  		throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');
  	}

  	// `country_phone_code_to_countries` was renamed to
  	// `country_calling_codes` in `1.0.18`.
  	if (!is_object(metadata) || !is_object(metadata.countries) || !is_object(metadata.country_calling_codes) && !is_object(metadata.country_phone_code_to_countries)) {
  		throw new Error('[libphonenumber-js] `metadata` argument was passed but it\'s not a valid metadata. Must be an object having `.countries` and `.country_calling_codes` child object properties. Got ' + (is_object(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + type_of(metadata) + ': ' + metadata) + '.');
  	}
  }

  // Babel transforms `typeof` into some "branches"
  // so istanbul will show this as "branch not covered".
  /* istanbul ignore next */
  var is_object = function is_object(_) {
  	return (typeof _ === 'undefined' ? 'undefined' : _typeof(_)) === 'object';
  };

  // Babel transforms `typeof` into some "branches"
  // so istanbul will show this as "branch not covered".
  /* istanbul ignore next */
  var type_of = function type_of(_) {
  	return typeof _ === 'undefined' ? 'undefined' : _typeof(_);
  };

  /**
   * Returns "country calling code" for a country.
   * Throws an error if the country doesn't exist or isn't supported by this library.
   * @param  {string} country
   * @param  {object} metadata
   * @return {string}
   * @example
   * // Returns "44"
   * getCountryCallingCode("GB")
   */
  function getCountryCallingCode(country, metadata) {
  	metadata = new Metadata(metadata);
  	if (metadata.hasCountry(country)) {
  		return metadata.country(country).countryCallingCode();
  	}
  	throw new Error('Unknown country: ' + country);
  }

  function isSupportedCountry(country, metadata) {
  	// metadata = new Metadata(metadata)
  	// return metadata.hasCountry(country)
  	return metadata.countries[country] !== undefined;
  }

  // The RFC 3966 format for extensions.
  var RFC3966_EXTN_PREFIX = ';ext=';

  // Pattern to capture digits used in an extension.
  // Places a maximum length of '7' for an extension.
  var CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})';

  /**
   * Regexp of all possible ways to write extensions, for use when parsing. This
   * will be run as a case-insensitive regexp match. Wide character versions are
   * also provided after each ASCII version. There are three regular expressions
   * here. The first covers RFC 3966 format, where the extension is added using
   * ';ext='. The second more generic one starts with optional white space and
   * ends with an optional full stop (.), followed by zero or more spaces/tabs
   * /commas and then the numbers themselves. The other one covers the special
   * case of American numbers where the extension is written with a hash at the
   * end, such as '- 503#'. Note that the only capturing groups should be around
   * the digits that you want to capture as part of the extension, or else parsing
   * will fail! We allow two options for representing the accented o - the
   * character itself, and one in the unicode decomposed form with the combining
   * acute accent.
   */
  function create_extension_pattern(purpose) {
  	// One-character symbols that can be used to indicate an extension.
  	var single_extension_characters = 'x\uFF58#\uFF03~\uFF5E';

  	switch (purpose) {
  		// For parsing, we are slightly more lenient in our interpretation than for matching. Here we
  		// allow "comma" and "semicolon" as possible extension indicators. When matching, these are
  		case 'parsing':
  			single_extension_characters = ',;' + single_extension_characters;
  	}

  	return RFC3966_EXTN_PREFIX + CAPTURING_EXTN_DIGITS + '|' + '[ \xA0\\t,]*' + '(?:e?xt(?:ensi(?:o\u0301?|\xF3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|' +
  	// "доб."
  	'\u0434\u043E\u0431|' + '[' + single_extension_characters + ']|int|anexo|\uFF49\uFF4E\uFF54)' + '[:\\.\uFF0E]?[ \xA0\\t,-]*' + CAPTURING_EXTN_DIGITS + '#?|' + '[- ]+([' + VALID_DIGITS + ']{1,5})#';
  }

  /**
   * Regexp of all possible ways to write extensions, for use when parsing. This
   * will be run as a case-insensitive regexp match. Wide character versions are
   * also provided after each ASCII version. There are three regular expressions
   * here. The first covers RFC 3966 format, where the extension is added using
   * ';ext='. The second more generic one starts with optional white space and
   * ends with an optional full stop (.), followed by zero or more spaces/tabs
   * /commas and then the numbers themselves. The other one covers the special
   * case of American numbers where the extension is written with a hash at the
   * end, such as '- 503#'. Note that the only capturing groups should be around
   * the digits that you want to capture as part of the extension, or else parsing
   * will fail! We allow two options for representing the accented o - the
   * character itself, and one in the unicode decomposed form with the combining
   * acute accent.
   */
  var EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing');

  var EXTN_PATTERNS_FOR_MATCHING = create_extension_pattern('matching');

  // Regexp of all known extension prefixes used by different regions followed by
  // 1 or more valid digits, for use when parsing.
  var EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i');

  // Strips any extension (as in, the part of the number dialled after the call is
  // connected, usually indicated with extn, ext, x or similar) from the end of
  // the number, and returns it.
  function extractExtension(number) {
  	var start = number.search(EXTN_PATTERN);
  	if (start < 0) {
  		return {};
  	}

  	// If we find a potential extension, and the number preceding this is a viable
  	// number, we assume it is an extension.
  	var number_without_extension = number.slice(0, start);

  	var matches = number.match(EXTN_PATTERN);
  	var i = 1;
  	while (i < matches.length) {
  		if (matches[i] != null && matches[i].length > 0) {
  			return {
  				number: number_without_extension,
  				ext: matches[i]
  			};
  		}
  		i++;
  	}
  }

  //  Regular expression of viable phone numbers. This is location independent.
  //  Checks we have at least three leading digits, and only valid punctuation,
  //  alpha characters and digits in the phone number. Does not include extension
  //  data. The symbol 'x' is allowed here as valid punctuation since it is often
  //  used as a placeholder for carrier codes, for example in Brazilian phone
  //  numbers. We also allow multiple '+' characters at the start.
  //
  //  Corresponds to the following:
  //  [digits]{minLengthNsn}|
  //  plus_sign*
  //  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*
  //
  //  The first reg-ex is to allow short numbers (two digits long) to be parsed if
  //  they are entered as "15" etc, but only if there is no punctuation in them.
  //  The second expression restricts the number of digits to three or more, but
  //  then allows them to be in international form, and to have alpha-characters
  //  and punctuation. We split up the two reg-exes here and combine them when
  //  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it
  //  with ^ and append $ to each branch.
  //
  //  "Note VALID_PUNCTUATION starts with a -,
  //   so must be the first in the range" (c) Google devs.
  //  (wtf did they mean by saying that; probably nothing)
  //
  var MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}';
  //
  // And this is the second reg-exp:
  // (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)
  //
  var VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';

  // The combined regular expression for valid phone numbers:
  //
  var VALID_PHONE_NUMBER_PATTERN = new RegExp(
  // Either a short two-digit-only phone number
  '^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' +
  // Or a longer fully parsed phone number (min 3 characters)
  '^' + VALID_PHONE_NUMBER +
  // Phone number extensions
  '(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' + '$', 'i');

  // Checks to see if the string of characters could possibly be a phone number at
  // all. At the moment, checks to see that the string begins with at least 2
  // digits, ignoring any punctuation commonly found in phone numbers. This method
  // does not require the number to be normalized in advance - but does assume
  // that leading non-number symbols have been removed, such as by the method
  // `extract_possible_number`.
  //
  function isViablePhoneNumber(number) {
  	return number.length >= MIN_LENGTH_FOR_NSN && VALID_PHONE_NUMBER_PATTERN.test(number);
  }

  // These mappings map a character (key) to a specific digit that should
  // replace it for normalization purposes. Non-European digits that
  // may be used in phone numbers are mapped to a European equivalent.
  //
  // E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.
  //
  var DIGITS = {
  	'0': '0',
  	'1': '1',
  	'2': '2',
  	'3': '3',
  	'4': '4',
  	'5': '5',
  	'6': '6',
  	'7': '7',
  	'8': '8',
  	'9': '9',
  	'\uFF10': '0', // Fullwidth digit 0
  	'\uFF11': '1', // Fullwidth digit 1
  	'\uFF12': '2', // Fullwidth digit 2
  	'\uFF13': '3', // Fullwidth digit 3
  	'\uFF14': '4', // Fullwidth digit 4
  	'\uFF15': '5', // Fullwidth digit 5
  	'\uFF16': '6', // Fullwidth digit 6
  	'\uFF17': '7', // Fullwidth digit 7
  	'\uFF18': '8', // Fullwidth digit 8
  	'\uFF19': '9', // Fullwidth digit 9
  	'\u0660': '0', // Arabic-indic digit 0
  	'\u0661': '1', // Arabic-indic digit 1
  	'\u0662': '2', // Arabic-indic digit 2
  	'\u0663': '3', // Arabic-indic digit 3
  	'\u0664': '4', // Arabic-indic digit 4
  	'\u0665': '5', // Arabic-indic digit 5
  	'\u0666': '6', // Arabic-indic digit 6
  	'\u0667': '7', // Arabic-indic digit 7
  	'\u0668': '8', // Arabic-indic digit 8
  	'\u0669': '9', // Arabic-indic digit 9
  	'\u06F0': '0', // Eastern-Arabic digit 0
  	'\u06F1': '1', // Eastern-Arabic digit 1
  	'\u06F2': '2', // Eastern-Arabic digit 2
  	'\u06F3': '3', // Eastern-Arabic digit 3
  	'\u06F4': '4', // Eastern-Arabic digit 4
  	'\u06F5': '5', // Eastern-Arabic digit 5
  	'\u06F6': '6', // Eastern-Arabic digit 6
  	'\u06F7': '7', // Eastern-Arabic digit 7
  	'\u06F8': '8', // Eastern-Arabic digit 8
  	'\u06F9': '9' // Eastern-Arabic digit 9
  };

  function parseDigit(character) {
  	return DIGITS[character];
  }

  /**
   * Parses phone number digits from a string.
   * Drops all punctuation leaving only digits.
   * Also converts wide-ascii and arabic-indic numerals to conventional numerals.
   * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.
   * @param  {string} string
   * @return {string}
   * @example
   * ```js
   * parseDigits('8 (800) 555')
   * // Outputs '8800555'.
   * ```
   */
  function parseDigits$1(string) {
  	var result = '';

  	// Using `.split('')` here instead of normal `for ... of`
  	// because the importing application doesn't neccessarily include an ES6 polyfill.
  	// The `.split('')` approach discards "exotic" UTF-8 characters
  	// (the ones consisting of four bytes) but digits
  	// (including non-European ones) don't fall into that range
  	// so such "exotic" characters would be discarded anyway.
  	for (var _iterator = string.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  		var _ref;

  		if (_isArray) {
  			if (_i >= _iterator.length) { break; }
  			_ref = _iterator[_i++];
  		} else {
  			_i = _iterator.next();
  			if (_i.done) { break; }
  			_ref = _i.value;
  		}

  		var character = _ref;

  		var digit = parseDigit(character);
  		if (digit) {
  			result += digit;
  		}
  	}

  	return result;
  }

  /**
   * Parses phone number characters from a string.
   * Drops all punctuation leaving only digits and the leading `+` sign (if any).
   * Also converts wide-ascii and arabic-indic numerals to conventional numerals.
   * E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.
   * @param  {string} string
   * @return {string}
   * @example
   * ```js
   * parseIncompletePhoneNumber('8 (800) 555')
   * // Outputs '8800555'.
   * parseIncompletePhoneNumber('+7 800 555')
   * // Outputs '+7800555'.
   * ```
   */
  function parseIncompletePhoneNumber(string) {
  	var result = '';

  	// Using `.split('')` here instead of normal `for ... of`
  	// because the importing application doesn't neccessarily include an ES6 polyfill.
  	// The `.split('')` approach discards "exotic" UTF-8 characters
  	// (the ones consisting of four bytes) but digits
  	// (including non-European ones) don't fall into that range
  	// so such "exotic" characters would be discarded anyway.
  	for (var _iterator = string.split(''), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  		var _ref;

  		if (_isArray) {
  			if (_i >= _iterator.length) { break; }
  			_ref = _iterator[_i++];
  		} else {
  			_i = _iterator.next();
  			if (_i.done) { break; }
  			_ref = _i.value;
  		}

  		var character = _ref;

  		result += parsePhoneNumberCharacter(character, result) || '';
  	}

  	return result;
  }

  /**
   * `input-format` `parse()` function.
   * https://github.com/catamphetamine/input-format
   * @param  {string} character - Yet another character from raw input string.
   * @param  {string} value - The value parsed so far.
   * @param  {object} meta - Optional custom use-case-specific metadata.
   * @return {string?} The parsed character.
   */
  function parsePhoneNumberCharacter(character, value) {
  	// Only allow a leading `+`.
  	if (character === '+') {
  		// If this `+` is not the first parsed character
  		// then discard it.
  		if (value) {
  			return;
  		}

  		return '+';
  	}

  	// Allow digits.
  	return parseDigit(character);
  }

  var NON_FIXED_LINE_PHONE_TYPES = ['MOBILE', 'PREMIUM_RATE', 'TOLL_FREE', 'SHARED_COST', 'VOIP', 'PERSONAL_NUMBER', 'PAGER', 'UAN', 'VOICEMAIL'];

  // Finds out national phone number type (fixed line, mobile, etc)
  function getNumberType(input) {
  	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	var metadata = arguments[2];

  	// When `parse()` returned `{}`
  	// meaning that the phone number is not a valid one.
  	if (!input.country) {
  		return;
  	}

  	metadata = new Metadata(metadata);

  	if (!metadata.hasCountry(input.country)) {
  		throw new Error('Unknown country: ' + input.country);
  	}

  	var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
  	metadata.country(input.country);

  	// The following is copy-pasted from the original function:
  	// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835

  	// Is this national number even valid for this country
  	if (!matchesEntirely(nationalNumber, metadata.nationalNumberPattern())) {
  		return;
  	}

  	// Is it fixed line number
  	if (is_of_type(nationalNumber, 'FIXED_LINE', metadata)) {
  		// Because duplicate regular expressions are removed
  		// to reduce metadata size, if "mobile" pattern is ""
  		// then it means it was removed due to being a duplicate of the fixed-line pattern.
  		//
  		if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') {
  			return 'FIXED_LINE_OR_MOBILE';
  		}

  		// v1 metadata.
  		// Legacy.
  		// Deprecated.
  		if (!metadata.type('MOBILE')) {
  			return 'FIXED_LINE_OR_MOBILE';
  		}

  		// Check if the number happens to qualify as both fixed line and mobile.
  		// (no such country in the minimal metadata set)
  		/* istanbul ignore if */
  		if (is_of_type(nationalNumber, 'MOBILE', metadata)) {
  			return 'FIXED_LINE_OR_MOBILE';
  		}

  		return 'FIXED_LINE';
  	}

  	for (var _iterator = NON_FIXED_LINE_PHONE_TYPES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  		var _ref;

  		if (_isArray) {
  			if (_i >= _iterator.length) { break; }
  			_ref = _iterator[_i++];
  		} else {
  			_i = _iterator.next();
  			if (_i.done) { break; }
  			_ref = _i.value;
  		}

  		var _type = _ref;

  		if (is_of_type(nationalNumber, _type, metadata)) {
  			return _type;
  		}
  	}
  }

  function is_of_type(nationalNumber, type, metadata) {
  	type = metadata.type(type);

  	if (!type || !type.pattern()) {
  		return false;
  	}

  	// Check if any possible number lengths are present;
  	// if so, we use them to avoid checking
  	// the validation pattern if they don't match.
  	// If they are absent, this means they match
  	// the general description, which we have
  	// already checked before a specific number type.
  	if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) {
  		return false;
  	}

  	return matchesEntirely(nationalNumber, type.pattern());
  }

  // Should only be called for the "new" metadata which has "possible lengths".
  function checkNumberLengthForType(nationalNumber, type, metadata) {
  	var type_info = metadata.type(type);

  	// There should always be "<possiblePengths/>" set for every type element.
  	// This is declared in the XML schema.
  	// For size efficiency, where a sub-description (e.g. fixed-line)
  	// has the same "<possiblePengths/>" as the "general description", this is missing,
  	// so we fall back to the "general description". Where no numbers of the type
  	// exist at all, there is one possible length (-1) which is guaranteed
  	// not to match the length of any real phone number.
  	var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths();
  	// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()

  	if (type === 'FIXED_LINE_OR_MOBILE') {
  		// No such country in metadata.
  		/* istanbul ignore next */
  		if (!metadata.type('FIXED_LINE')) {
  			// The rare case has been encountered where no fixedLine data is available
  			// (true for some non-geographical entities), so we just check mobile.
  			return checkNumberLengthForType(nationalNumber, 'MOBILE', metadata);
  		}

  		var mobile_type = metadata.type('MOBILE');

  		if (mobile_type) {
  			// Merge the mobile data in if there was any. "Concat" creates a new
  			// array, it doesn't edit possible_lengths in place, so we don't need a copy.
  			// Note that when adding the possible lengths from mobile, we have
  			// to again check they aren't empty since if they are this indicates
  			// they are the same as the general desc and should be obtained from there.
  			possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths());
  			// The current list is sorted; we need to merge in the new list and
  			// re-sort (duplicates are okay). Sorting isn't so expensive because
  			// the lists are very small.

  			// if (local_lengths)
  			// {
  			// 	local_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())
  			// }
  			// else
  			// {
  			// 	local_lengths = mobile_type.possibleLengthsLocal()
  			// }
  		}
  	}
  	// If the type doesn't exist then return 'INVALID_LENGTH'.
  	else if (type && !type_info) {
  			return 'INVALID_LENGTH';
  		}

  	var actual_length = nationalNumber.length;

  	// In `libphonenumber-js` all "local-only" formats are dropped for simplicity.
  	// // This is safe because there is never an overlap beween the possible lengths
  	// // and the local-only lengths; this is checked at build time.
  	// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)
  	// {
  	// 	return 'IS_POSSIBLE_LOCAL_ONLY'
  	// }

  	var minimum_length = possible_lengths[0];

  	if (minimum_length === actual_length) {
  		return 'IS_POSSIBLE';
  	}

  	if (minimum_length > actual_length) {
  		return 'TOO_SHORT';
  	}

  	if (possible_lengths[possible_lengths.length - 1] < actual_length) {
  		return 'TOO_LONG';
  	}

  	// We skip the first element since we've already checked it.
  	return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';
  }

  function isPossibleNumber(input, options, metadata) {
  	/* istanbul ignore if */
  	if (options === undefined) {
  		options = {};
  	}

  	metadata = new Metadata(metadata);

  	if (options.v2) {
  		if (!input.countryCallingCode) {
  			throw new Error('Invalid phone number object passed');
  		}
  		metadata.chooseCountryByCountryCallingCode(input.countryCallingCode);
  	} else {
  		if (!input.phone) {
  			return false;
  		}
  		if (input.country) {
  			if (!metadata.hasCountry(input.country)) {
  				throw new Error('Unknown country: ' + input.country);
  			}
  			metadata.country(input.country);
  		} else {
  			if (!input.countryCallingCode) {
  				throw new Error('Invalid phone number object passed');
  			}
  			metadata.chooseCountryByCountryCallingCode(input.countryCallingCode);
  		}
  	}

  	if (!metadata.possibleLengths()) {
  		throw new Error('Metadata too old');
  	}

  	return is_possible_number(input.phone || input.nationalNumber, undefined, metadata);
  }

  function is_possible_number(national_number, is_international, metadata) {
  	switch (checkNumberLengthForType(national_number, undefined, metadata)) {
  		case 'IS_POSSIBLE':
  			return true;
  		// case 'IS_POSSIBLE_LOCAL_ONLY':
  		// 	return !is_international
  		default:
  			return false;
  	}
  }

  var CAPTURING_DIGIT_PATTERN = new RegExp('([' + VALID_DIGITS + '])');

  /**
   * Pattern that makes it easy to distinguish whether a region has a single
   * international dialing prefix or not. If a region has a single international
   * prefix (e.g. 011 in USA), it will be represented as a string that contains
   * a sequence of ASCII digits, and possibly a tilde, which signals waiting for
   * the tone. If there are multiple available international prefixes in a
   * region, they will be represented as a regex string that always contains one
   * or more characters that are not ASCII digits or a tilde.
   */
  var SINGLE_IDD_PREFIX = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/;

  // For regions that have multiple IDD prefixes
  // a preferred IDD prefix is returned.
  function getIDDPrefix(country, metadata) {
  	var countryMetadata = new Metadata(metadata);
  	countryMetadata.country(country);

  	if (SINGLE_IDD_PREFIX.test(countryMetadata.IDDPrefix())) {
  		return countryMetadata.IDDPrefix();
  	}

  	return countryMetadata.defaultIDDPrefix();
  }

  function stripIDDPrefix(number, country, metadata) {
  	if (!country) {
  		return;
  	}

  	// Check if the number is IDD-prefixed.

  	var countryMetadata = new Metadata(metadata);
  	countryMetadata.country(country);

  	var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());

  	if (number.search(IDDPrefixPattern) !== 0) {
  		return;
  	}

  	// Strip IDD prefix.
  	number = number.slice(number.match(IDDPrefixPattern)[0].length);

  	// Some kind of a weird edge case.
  	// No explanation from Google given.
  	var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
  	/* istanbul ignore next */
  	if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
  		if (matchedGroups[1] === '0') {
  			return;
  		}
  	}

  	return number;
  }

  var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) { break; } } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) { _i["return"](); } } finally { if (_d) { throw _e; } } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  // https://www.ietf.org/rfc/rfc3966.txt

  /**
   * @param  {string} text - Phone URI (RFC 3966).
   * @return {object} `{ ?number, ?ext }`.
   */
  function parseRFC3966(text) {
  	var number = void 0;
  	var ext = void 0;

  	// Replace "tel:" with "tel=" for parsing convenience.
  	text = text.replace(/^tel:/, 'tel=');

  	for (var _iterator = text.split(';'), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  		var _ref;

  		if (_isArray) {
  			if (_i >= _iterator.length) { break; }
  			_ref = _iterator[_i++];
  		} else {
  			_i = _iterator.next();
  			if (_i.done) { break; }
  			_ref = _i.value;
  		}

  		var part = _ref;

  		var _part$split = part.split('='),
  		    _part$split2 = _slicedToArray(_part$split, 2),
  		    name = _part$split2[0],
  		    value = _part$split2[1];

  		switch (name) {
  			case 'tel':
  				number = value;
  				break;
  			case 'ext':
  				ext = value;
  				break;
  			case 'phone-context':
  				// Only "country contexts" are supported.
  				// "Domain contexts" are ignored.
  				if (value[0] === '+') {
  					number = value + number;
  				}
  				break;
  		}
  	}

  	// If the phone number is not viable, then abort.
  	if (!isViablePhoneNumber(number)) {
  		return {};
  	}

  	var result = { number: number };
  	if (ext) {
  		result.ext = ext;
  	}
  	return result;
  }

  /**
   * @param  {object} - `{ ?number, ?extension }`.
   * @return {string} Phone URI (RFC 3966).
   */
  function formatRFC3966(_ref2) {
  	var number = _ref2.number,
  	    ext = _ref2.ext;

  	if (!number) {
  		return '';
  	}

  	if (number[0] !== '+') {
  		throw new Error('"formatRFC3966()" expects "number" to be in E.164 format.');
  	}

  	return 'tel:' + number + (ext ? ';ext=' + ext : '');
  }

  /**
   * Checks if a given phone number is valid.
   *
   * If the `number` is a string, it will be parsed to an object,
   * but only if it contains only valid phone number characters (including punctuation).
   * If the `number` is an object, it is used as is.
   *
   * The optional `defaultCountry` argument is the default country.
   * I.e. it does not restrict to just that country,
   * e.g. in those cases where several countries share
   * the same phone numbering rules (NANPA, Britain, etc).
   * For example, even though the number `07624 369230`
   * belongs to the Isle of Man ("IM" country code)
   * calling `isValidNumber('07624369230', 'GB', metadata)`
   * still returns `true` because the country is not restricted to `GB`,
   * it's just that `GB` is the default one for the phone numbering rules.
   * For restricting the country see `isValidNumberForRegion()`
   * though restricting a country might not be a good idea.
   * https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion
   *
   * Examples:
   *
   * ```js
   * isValidNumber('+78005553535', metadata)
   * isValidNumber('8005553535', 'RU', metadata)
   * isValidNumber('88005553535', 'RU', metadata)
   * isValidNumber({ phone: '8005553535', country: 'RU' }, metadata)
   * ```
   */
  function isValidNumber(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var metadata = arguments[2];

    metadata = new Metadata(metadata);

    // This is just to support `isValidNumber({})`
    // for cases when `parseNumber()` returns `{}`.
    if (!input.country) {
      return false;
    }

    if (!metadata.hasCountry(input.country)) {
      throw new Error('Unknown country: ' + input.country);
    }

    metadata.country(input.country);

    // By default, countries only have type regexps when it's required for
    // distinguishing different countries having the same `countryCallingCode`.
    if (metadata.hasTypes()) {
      return getNumberType(input, options, metadata.metadata) !== undefined;
    }

    // If there are no type regexps for this country in metadata then use
    // `nationalNumberPattern` as a "better than nothing" replacement.
    var national_number = options.v2 ? input.nationalNumber : input.phone;
    return matchesEntirely(national_number, metadata.nationalNumberPattern());
  }

  var _extends = Object.assign || function (target) {
  var arguments$1 = arguments;
   for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var defaultOptions = {
  	formatExtension: function formatExtension(formattedNumber, extension, metadata) {
  		return '' + formattedNumber + metadata.ext() + extension;
  	}

  	// Formats a phone number
  	//
  	// Example use cases:
  	//
  	// ```js
  	// formatNumber('8005553535', 'RU', 'INTERNATIONAL')
  	// formatNumber('8005553535', 'RU', 'INTERNATIONAL', metadata)
  	// formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL')
  	// formatNumber({ phone: '8005553535', country: 'RU' }, 'INTERNATIONAL', metadata)
  	// formatNumber('+78005553535', 'NATIONAL')
  	// formatNumber('+78005553535', 'NATIONAL', metadata)
  	// ```
  	//
  };function formatNumber$1(input, format, options, metadata) {
  	// Apply default options.
  	if (options) {
  		options = _extends({}, defaultOptions, options);
  	} else {
  		options = defaultOptions;
  	}

  	metadata = new Metadata(metadata);

  	if (input.country) {
  		// Validate `input.country`.
  		if (!metadata.hasCountry(input.country)) {
  			throw new Error('Unknown country: ' + input.country);
  		}
  		metadata.country(input.country);
  	} else if (input.countryCallingCode) {
  		metadata.chooseCountryByCountryCallingCode(input.countryCallingCode);
  	} else { return input.phone || ''; }

  	var countryCallingCode = metadata.countryCallingCode();

  	var nationalNumber = options.v2 ? input.nationalNumber : input.phone;

  	// This variable should have been declared inside `case`s
  	// but Babel has a bug and it says "duplicate variable declaration".
  	var number = void 0;

  	switch (format) {
  		case 'NATIONAL':
  			// Legacy argument support.
  			// (`{ country: ..., phone: '' }`)
  			if (!nationalNumber) {
  				return '';
  			}
  			number = format_national_number(nationalNumber, 'NATIONAL', metadata);
  			return addExtension(number, input.ext, metadata, options.formatExtension);

  		case 'INTERNATIONAL':
  			// Legacy argument support.
  			// (`{ country: ..., phone: '' }`)
  			if (!nationalNumber) {
  				return '+' + countryCallingCode;
  			}
  			number = format_national_number(nationalNumber, 'INTERNATIONAL', metadata);
  			number = '+' + countryCallingCode + ' ' + number;
  			return addExtension(number, input.ext, metadata, options.formatExtension);

  		case 'E.164':
  			// `E.164` doesn't define "phone number extensions".
  			return '+' + countryCallingCode + nationalNumber;

  		case 'RFC3966':
  			return formatRFC3966({
  				number: '+' + countryCallingCode + nationalNumber,
  				ext: input.ext
  			});

  		case 'IDD':
  			if (!options.fromCountry) {
  				return;
  				// throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')
  			}
  			var IDDPrefix = getIDDPrefix(options.fromCountry, metadata.metadata);
  			if (!IDDPrefix) {
  				return;
  			}
  			if (options.humanReadable) {
  				var formattedForSameCountryCallingCode = countryCallingCode && formatIDDSameCountryCallingCodeNumber(nationalNumber, metadata.countryCallingCode(), options.fromCountry, metadata);
  				if (formattedForSameCountryCallingCode) {
  					number = formattedForSameCountryCallingCode;
  				} else {
  					number = IDDPrefix + ' ' + countryCallingCode + ' ' + format_national_number(nationalNumber, 'INTERNATIONAL', metadata);
  				}
  				return addExtension(number, input.ext, metadata, options.formatExtension);
  			}
  			return '' + IDDPrefix + countryCallingCode + nationalNumber;

  		default:
  			throw new Error('Unknown "format" argument passed to "formatNumber()": "' + format + '"');
  	}
  }

  // This was originally set to $1 but there are some countries for which the
  // first group is not used in the national pattern (e.g. Argentina) so the $1
  // group does not match correctly.  Therefore, we use \d, so that the first
  // group actually used in the pattern will be matched.
  var FIRST_GROUP_PATTERN = /(\$\d)/;

  function format_national_number_using_format(number, format, useInternationalFormat, includeNationalPrefixForNationalFormat, metadata) {
  	var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalFormat ? format.internationalFormat() : format.nationalPrefixFormattingRule() && (!format.nationalPrefixIsOptionalWhenFormatting() || includeNationalPrefixForNationalFormat) ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format());

  	if (useInternationalFormat) {
  		return changeInternationalFormatStyle(formattedNumber);
  	}

  	return formattedNumber;
  }

  function format_national_number(number, format_as, metadata) {
  	var format = choose_format_for_number(metadata.formats(), number);
  	if (!format) {
  		return number;
  	}
  	return format_national_number_using_format(number, format, format_as === 'INTERNATIONAL', true);
  }

  function choose_format_for_number(available_formats, national_number) {
  	for (var _iterator = available_formats, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  		var _ref;

  		if (_isArray) {
  			if (_i >= _iterator.length) { break; }
  			_ref = _iterator[_i++];
  		} else {
  			_i = _iterator.next();
  			if (_i.done) { break; }
  			_ref = _i.value;
  		}

  		var format = _ref;

  		// Validate leading digits
  		if (format.leadingDigitsPatterns().length > 0) {
  			// The last leading_digits_pattern is used here, as it is the most detailed
  			var last_leading_digits_pattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1];

  			// If leading digits don't match then move on to the next phone number format
  			if (national_number.search(last_leading_digits_pattern) !== 0) {
  				continue;
  			}
  		}

  		// Check that the national number matches the phone number format regular expression
  		if (matchesEntirely(national_number, format.pattern())) {
  			return format;
  		}
  	}
  }

  // Removes brackets and replaces dashes with spaces.
  //
  // E.g. "(999) 111-22-33" -> "999 111 22 33"
  //
  // For some reason Google's metadata contains `<intlFormat/>`s with brackets and dashes.
  // Meanwhile, there's no single opinion about using punctuation in international phone numbers.
  //
  // For example, Google's `<intlFormat/>` for USA is `+1 213-373-4253`.
  // And here's a quote from WikiPedia's "North American Numbering Plan" page:
  // https://en.wikipedia.org/wiki/North_American_Numbering_Plan
  //
  // "The country calling code for all countries participating in the NANP is 1.
  // In international format, an NANP number should be listed as +1 301 555 01 00,
  // where 301 is an area code (Maryland)."
  //
  // I personally prefer the international format without any punctuation.
  // For example, brackets are remnants of the old age, meaning that the
  // phone number part in brackets (so called "area code") can be omitted
  // if dialing within the same "area".
  // And hyphens were clearly introduced for splitting local numbers into memorizable groups.
  // For example, remembering "5553535" is difficult but "555-35-35" is much simpler.
  // Imagine a man taking a bus from home to work and seeing an ad with a phone number.
  // He has a couple of seconds to memorize that number until it passes by.
  // If it were spaces instead of hyphens the man wouldn't necessarily get it,
  // but with hyphens instead of spaces the grouping is more explicit.
  // I personally think that hyphens introduce visual clutter,
  // so I prefer replacing them with spaces in international numbers.
  // In the modern age all output is done on displays where spaces are clearly distinguishable
  // so hyphens can be safely replaced with spaces without losing any legibility.
  //
  function changeInternationalFormatStyle(local) {
  	return local.replace(new RegExp('[' + VALID_PUNCTUATION + ']+', 'g'), ' ').trim();
  }

  function addExtension(formattedNumber, ext, metadata, formatExtension) {
  	return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;
  }

  function formatIDDSameCountryCallingCodeNumber(number, toCountryCallingCode, fromCountry, toCountryMetadata) {
  	var fromCountryMetadata = new Metadata(toCountryMetadata.metadata);
  	fromCountryMetadata.country(fromCountry);

  	// If calling within the same country calling code.
  	if (toCountryCallingCode === fromCountryMetadata.countryCallingCode()) {
  		// For NANPA regions, return the national format for these regions
  		// but prefix it with the country calling code.
  		if (toCountryCallingCode === '1') {
  			return toCountryCallingCode + ' ' + format_national_number(number, 'NATIONAL', toCountryMetadata);
  		}

  		// If regions share a country calling code, the country calling code need
  		// not be dialled. This also applies when dialling within a region, so this
  		// if clause covers both these cases. Technically this is the case for
  		// dialling from La Reunion to other overseas departments of France (French
  		// Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover
  		// this edge case for now and for those cases return the version including
  		// country calling code. Details here:
  		// http://www.petitfute.com/voyage/225-info-pratiques-reunion
  		//
  		return format_national_number(number, 'NATIONAL', toCountryMetadata);
  	}
  }

  var _extends$1 = Object.assign || function (target) {
  var arguments$1 = arguments;
   for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

  function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var PhoneNumber = function () {
  	function PhoneNumber(countryCallingCode, nationalNumber, metadata) {
  		_classCallCheck$2(this, PhoneNumber);

  		if (!countryCallingCode) {
  			throw new TypeError('`countryCallingCode` not passed');
  		}
  		if (!nationalNumber) {
  			throw new TypeError('`nationalNumber` not passed');
  		}
  		// If country code is passed then derive `countryCallingCode` from it.
  		// Also store the country code as `.country`.
  		if (isCountryCode(countryCallingCode)) {
  			this.country = countryCallingCode;
  			var _metadata = new Metadata(metadata);
  			_metadata.country(countryCallingCode);
  			countryCallingCode = _metadata.countryCallingCode();
  		}
  		this.countryCallingCode = countryCallingCode;
  		this.nationalNumber = nationalNumber;
  		this.number = '+' + this.countryCallingCode + this.nationalNumber;
  		this.metadata = metadata;
  	}

  	_createClass$1(PhoneNumber, [{
  		key: 'isPossible',
  		value: function isPossible() {
  			return isPossibleNumber(this, { v2: true }, this.metadata);
  		}
  	}, {
  		key: 'isValid',
  		value: function isValid() {
  			return isValidNumber(this, { v2: true }, this.metadata);
  		}

  		// // Is just an alias for `this.isValid() && this.country === country`.
  		// // https://github.com/googlei18n/libphonenumber/blob/master/FAQ.md#when-should-i-use-isvalidnumberforregion
  		// isValidForRegion(country) {
  		// 	return isValidNumberForRegion(this, country, { v2: true }, this.metadata)
  		// }

  	}, {
  		key: 'getType',
  		value: function getType() {
  			return getNumberType(this, { v2: true }, this.metadata);
  		}
  	}, {
  		key: 'format',
  		value: function format(_format, options) {
  			return formatNumber$1(this, _format, options ? _extends$1({}, options, { v2: true }) : { v2: true }, this.metadata);
  		}
  	}, {
  		key: 'formatNational',
  		value: function formatNational(options) {
  			return this.format('NATIONAL', options);
  		}
  	}, {
  		key: 'formatInternational',
  		value: function formatInternational(options) {
  			return this.format('INTERNATIONAL', options);
  		}
  	}, {
  		key: 'getURI',
  		value: function getURI(options) {
  			return this.format('RFC3966', options);
  		}
  	}]);

  	return PhoneNumber;
  }();


  var isCountryCode = function isCountryCode(value) {
  	return (/^[A-Z]{2}$/.test(value)
  	);
  };

  // This is a port of Google Android `libphonenumber`'s

  // We don't allow input strings for parsing to be longer than 250 chars.
  // This prevents malicious input from consuming CPU.
  var MAX_INPUT_STRING_LENGTH = 250;

  // This consists of the plus symbol, digits, and arabic-indic digits.
  var PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']');

  // Regular expression of trailing characters that we want to remove.
  var AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$');

  // `options`:
  //  {
  //    country:
  //    {
  //      restrict - (a two-letter country code)
  //                 the phone number must be in this country
  //
  //      default - (a two-letter country code)
  //                default country to use for phone number parsing and validation
  //                (if no country code could be derived from the phone number)
  //    }
  //  }
  //
  // Returns `{ country, number }`
  //
  // Example use cases:
  //
  // ```js
  // parse('8 (800) 555-35-35', 'RU')
  // parse('8 (800) 555-35-35', 'RU', metadata)
  // parse('8 (800) 555-35-35', { country: { default: 'RU' } })
  // parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)
  // parse('+7 800 555 35 35')
  // parse('+7 800 555 35 35', metadata)
  // ```
  //
  function parse$2(text) {
  	var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	var metadata = arguments[2];

  	metadata = new Metadata(metadata);

  	// Validate `defaultCountry`.
  	if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {
  		if (options.v2) {
  			throw new ParseError('INVALID_COUNTRY');
  		}
  		throw new Error('Unknown country: ' + options.defaultCountry);
  	}

  	// Parse the phone number.

  	var _parse_input = parse_input(text, options.v2),
  	    formatted_phone_number = _parse_input.number,
  	    ext = _parse_input.ext;

  	// If the phone number is not viable then return nothing.


  	if (!formatted_phone_number) {
  		if (options.v2) {
  			throw new ParseError('NOT_A_NUMBER');
  		}
  		return {};
  	}

  	var _parse_phone_number = parse_phone_number(formatted_phone_number, options.defaultCountry, metadata),
  	    country = _parse_phone_number.country,
  	    nationalNumber = _parse_phone_number.national_number,
  	    countryCallingCode = _parse_phone_number.countryCallingCode,
  	    carrierCode = _parse_phone_number.carrierCode;

  	if (!metadata.selectedCountry()) {
  		if (options.v2) {
  			throw new ParseError('INVALID_COUNTRY');
  		}
  		return {};
  	}

  	// Validate national (significant) number length.
  	if (nationalNumber.length < MIN_LENGTH_FOR_NSN) {
  		// Won't throw here because the regexp already demands length > 1.
  		/* istanbul ignore if */
  		if (options.v2) {
  			throw new ParseError('TOO_SHORT');
  		}
  		// Google's demo just throws an error in this case.
  		return {};
  	}

  	// Validate national (significant) number length.
  	//
  	// A sidenote:
  	//
  	// They say that sometimes national (significant) numbers
  	// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).
  	// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36
  	// Such numbers will just be discarded.
  	//
  	if (nationalNumber.length > MAX_LENGTH_FOR_NSN) {
  		if (options.v2) {
  			throw new ParseError('TOO_LONG');
  		}
  		// Google's demo just throws an error in this case.
  		return {};
  	}

  	if (options.v2) {
  		var phoneNumber = new PhoneNumber(countryCallingCode, nationalNumber, metadata.metadata);

  		if (country) {
  			phoneNumber.country = country;
  		}
  		if (carrierCode) {
  			phoneNumber.carrierCode = carrierCode;
  		}
  		if (ext) {
  			phoneNumber.ext = ext;
  		}

  		return phoneNumber;
  	}

  	// Check if national phone number pattern matches the number.
  	// National number pattern is different for each country,
  	// even for those ones which are part of the "NANPA" group.
  	var valid = country && matchesEntirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false;

  	if (!options.extended) {
  		return valid ? result(country, nationalNumber, ext) : {};
  	}

  	return {
  		country: country,
  		countryCallingCode: countryCallingCode,
  		carrierCode: carrierCode,
  		valid: valid,
  		possible: valid ? true : options.extended === true && metadata.possibleLengths() && is_possible_number(nationalNumber, countryCallingCode !== undefined, metadata),
  		phone: nationalNumber,
  		ext: ext
  	};
  }

  /**
   * Extracts a parseable phone number.
   * @param  {string} text - Input.
   * @return {string}.
   */
  function extract_formatted_phone_number(text, v2) {
  	if (!text) {
  		return;
  	}

  	if (text.length > MAX_INPUT_STRING_LENGTH) {
  		if (v2) {
  			throw new ParseError('TOO_LONG');
  		}
  		return;
  	}

  	// Attempt to extract a possible number from the string passed in

  	var starts_at = text.search(PHONE_NUMBER_START_PATTERN);

  	if (starts_at < 0) {
  		return;
  	}

  	return text
  	// Trim everything to the left of the phone number
  	.slice(starts_at)
  	// Remove trailing non-numerical characters
  	.replace(AFTER_PHONE_NUMBER_END_PATTERN, '');
  }

  // Strips any national prefix (such as 0, 1) present in the number provided.
  // "Carrier codes" are only used  in Colombia and Brazil,
  // and only when dialing within those countries from a mobile phone to a fixed line number.
  function strip_national_prefix_and_carrier_code(number, metadata) {
  	if (!number || !metadata.nationalPrefixForParsing()) {
  		return { number: number };
  	}

  	// In many countries the national prefix
  	// is not just a constant digit (like `0` in UK)
  	// but can be different depending on the phone number
  	// (and can be also absent for some phone numbers).
  	//
  	// So `national_prefix_for_parsing` is used when parsing
  	// a national-prefixed (local) phone number
  	// into a national significant phone number
  	// extracting that possible national prefix out of it.
  	//
  	// Example `national_prefix_for_parsing` for Australia (AU) is `0|(183[12])`.
  	// Which means that in Australia the national prefix can be: `0`, `1831`, `1832`.

  	// Attempt to parse the first digits as a national prefix
  	var national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')');
  	var national_prefix_matcher = national_prefix_pattern.exec(number);

  	// If no national prefix is present in the phone number,
  	// but the national prefix is optional for this country,
  	// then consider this phone number valid.
  	//
  	// Google's reference `libphonenumber` implementation
  	// wouldn't recognize such phone numbers as valid,
  	// but I think it would perfectly make sense
  	// to consider such phone numbers as valid
  	// because if a national phone number was originally
  	// formatted without the national prefix
  	// then it must be parseable back into the original national number.
  	// In other words, `parse(format(number))`
  	// must always be equal to `number`.
  	//
  	if (!national_prefix_matcher) {
  		return { number: number };
  	}

  	var national_significant_number = void 0;

  	// In more complex cases just `national_prefix_for_parsing` regexp
  	// is not enough to extract the national number and then strip it
  	// like `number.slice(national_prefix.length)` because when parsing
  	// national numbers it's not always clear whether the first digits
  	// are a national prefix or part of the national significant number.
  	// For such cases `national_prefix_transform_rule` regexp is present
  	// which contains "capturing groups" that are later used in such
  	// `national_prefix_transform_rule` to transform the national number
  	// being parsed into the national significant number.
  	//
  	// Example.
  	// Country: U.S. Virgin Islands (VI).
  	// Country calling code: +1.
  	// Leading digits: 340.
  	// Phone number format: +1 (340) xxx-xxxx.
  	// National prefix: 1.
  	// National prefix for parsing: 1|([2-9]\d{6})$.
  	// National prefix transform rule: 340$1.
  	//
  	// So for input "13401234567" "national prefix for parsing" regexp
  	// will return "1" and the national significant number will be
  	// "13401234567".slice("1".length) === "(340) 123-4567".
  	//
  	// And for input "3401234567" "national prefix for parsing" regexp
  	// the "captured group" will be "3401234567" and the national significant
  	// number will be "3401234567".replace("340123", "340340123") === "(340) 3401234567".
  	//
  	// `national_prefix_matcher[captured_groups_count]` means that
  	// the corresponding "captured group" is not empty.
  	// It can be empty if the regexp either doesn't have any "capturing groups"
  	// or if the "capturing groups" are defined as optional.
  	// Example: "0?(?:...)?" for Argentina.
  	//
  	var captured_groups_count = national_prefix_matcher.length - 1;
  	if (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count]) {
  		national_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule());
  	}
  	// If it's a simple-enough case then just strip the national prefix from the number.
  	else {
  			// National prefix is the whole substring matched by
  			// the `national_prefix_for_parsing` regexp.
  			var national_prefix = national_prefix_matcher[0];
  			national_significant_number = number.slice(national_prefix.length);
  		}

  	var carrierCode = void 0;
  	if (captured_groups_count > 0) {
  		carrierCode = national_prefix_matcher[1];
  	}

  	// The following is done in `get_country_and_national_number_for_local_number()` instead.
  	//
  	// // Verify the parsed national (significant) number for this country
  	// const national_number_rule = new RegExp(metadata.nationalNumberPattern())
  	// //
  	// // If the original number (before stripping national prefix) was viable,
  	// // and the resultant number is not, then prefer the original phone number.
  	// // This is because for some countries (e.g. Russia) the same digit could be both
  	// // a national prefix and a leading digit of a valid national phone number,
  	// // like `8` is the national prefix for Russia and both
  	// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.
  	// if (matchesEntirely(number, national_number_rule) &&
  	// 		!matchesEntirely(national_significant_number, national_number_rule))
  	// {
  	// 	return number
  	// }

  	// Return the parsed national (significant) number
  	return {
  		number: national_significant_number,
  		carrierCode: carrierCode
  	};
  }

  function find_country_code(country_calling_code, national_phone_number, metadata) {
  	// Is always non-empty, because `country_calling_code` is always valid
  	var possible_countries = metadata.countryCallingCodes()[country_calling_code];

  	// If there's just one country corresponding to the country code,
  	// then just return it, without further phone number digits validation.
  	if (possible_countries.length === 1) {
  		return possible_countries[0];
  	}

  	return _find_country_code(possible_countries, national_phone_number, metadata.metadata);
  }

  // Changes `metadata` `country`.
  function _find_country_code(possible_countries, national_phone_number, metadata) {
  	metadata = new Metadata(metadata);

  	for (var _iterator = possible_countries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  		var _ref;

  		if (_isArray) {
  			if (_i >= _iterator.length) { break; }
  			_ref = _iterator[_i++];
  		} else {
  			_i = _iterator.next();
  			if (_i.done) { break; }
  			_ref = _i.value;
  		}

  		var country = _ref;

  		metadata.country(country);

  		// Leading digits check would be the simplest one
  		if (metadata.leadingDigits()) {
  			if (national_phone_number && national_phone_number.search(metadata.leadingDigits()) === 0) {
  				return country;
  			}
  		}
  		// Else perform full validation with all of those
  		// fixed-line/mobile/etc regular expressions.
  		else if (getNumberType({ phone: national_phone_number, country: country }, undefined, metadata.metadata)) {
  				return country;
  			}
  	}
  }

  /**
   * @param  {string} text - Input.
   * @return {object} `{ ?number, ?ext }`.
   */
  function parse_input(text, v2) {
  	// Parse RFC 3966 phone number URI.
  	if (text && text.indexOf('tel:') === 0) {
  		return parseRFC3966(text);
  	}

  	var number = extract_formatted_phone_number(text, v2);

  	// If the phone number is not viable, then abort.
  	if (!number || !isViablePhoneNumber(number)) {
  		return {};
  	}

  	// Attempt to parse extension first, since it doesn't require region-specific
  	// data and we want to have the non-normalised number here.
  	var with_extension_stripped = extractExtension(number);
  	if (with_extension_stripped.ext) {
  		return with_extension_stripped;
  	}

  	return { number: number };
  }

  /**
   * Creates `parse()` result object.
   */
  function result(country, national_number, ext) {
  	var result = {
  		country: country,
  		phone: national_number
  	};

  	if (ext) {
  		result.ext = ext;
  	}

  	return result;
  }

  /**
   * Parses a viable phone number.
   * Returns `{ country, countryCallingCode, national_number }`.
   */
  function parse_phone_number(formatted_phone_number, default_country, metadata) {
  	var _extractCountryCallin = extractCountryCallingCode(formatted_phone_number, default_country, metadata.metadata),
  	    countryCallingCode = _extractCountryCallin.countryCallingCode,
  	    number = _extractCountryCallin.number;

  	if (!number) {
  		return { countryCallingCode: countryCallingCode };
  	}

  	var country = void 0;

  	if (countryCallingCode) {
  		metadata.chooseCountryByCountryCallingCode(countryCallingCode);
  	} else if (default_country) {
  		metadata.country(default_country);
  		country = default_country;
  		countryCallingCode = getCountryCallingCode(default_country, metadata.metadata);
  	} else { return {}; }

  	var _parse_national_numbe = parse_national_number(number, metadata),
  	    national_number = _parse_national_numbe.national_number,
  	    carrier_code = _parse_national_numbe.carrier_code;

  	// Sometimes there are several countries
  	// corresponding to the same country phone code
  	// (e.g. NANPA countries all having `1` country phone code).
  	// Therefore, to reliably determine the exact country,
  	// national (significant) number should have been parsed first.
  	//
  	// When `metadata.json` is generated, all "ambiguous" country phone codes
  	// get their countries populated with the full set of
  	// "phone number type" regular expressions.
  	//


  	var exactCountry = find_country_code(countryCallingCode, national_number, metadata);
  	if (exactCountry) {
  		country = exactCountry;
  		metadata.country(country);
  	}

  	return {
  		country: country,
  		countryCallingCode: countryCallingCode,
  		national_number: national_number,
  		carrierCode: carrier_code
  	};
  }

  function parse_national_number(number, metadata) {
  	var national_number = parseIncompletePhoneNumber(number);
  	var carrier_code = void 0;

  	// Parsing national prefixes and carrier codes
  	// is only required for local phone numbers
  	// but some people don't understand that
  	// and sometimes write international phone numbers
  	// with national prefixes (or maybe even carrier codes).
  	// http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html
  	// Google's original library forgives such mistakes
  	// and so does this library, because it has been requested:
  	// https://github.com/catamphetamine/libphonenumber-js/issues/127

  	var _strip_national_prefi = strip_national_prefix_and_carrier_code(national_number, metadata),
  	    potential_national_number = _strip_national_prefi.number,
  	    carrierCode = _strip_national_prefi.carrierCode;

  	// If metadata has "possible lengths" then employ the new algorythm.


  	if (metadata.possibleLengths()) {
  		// We require that the NSN remaining after stripping the national prefix and
  		// carrier code be long enough to be a possible length for the region.
  		// Otherwise, we don't do the stripping, since the original number could be
  		// a valid short number.
  		switch (checkNumberLengthForType(potential_national_number, undefined, metadata)) {
  			case 'TOO_SHORT':
  			// case 'IS_POSSIBLE_LOCAL_ONLY':
  			case 'INVALID_LENGTH':
  				break;
  			default:
  				national_number = potential_national_number;
  				carrier_code = carrierCode;
  		}
  	} else {
  		// If the original number (before stripping national prefix) was viable,
  		// and the resultant number is not, then prefer the original phone number.
  		// This is because for some countries (e.g. Russia) the same digit could be both
  		// a national prefix and a leading digit of a valid national phone number,
  		// like `8` is the national prefix for Russia and both
  		// `8 800 555 35 35` and `800 555 35 35` are valid numbers.
  		if (matchesEntirely(national_number, metadata.nationalNumberPattern()) && !matchesEntirely(potential_national_number, metadata.nationalNumberPattern())) ; else {
  			national_number = potential_national_number;
  			carrier_code = carrierCode;
  		}
  	}

  	return {
  		national_number: national_number,
  		carrier_code: carrier_code
  	};
  }

  // Determines the country for a given (possibly incomplete) phone number.
  // export function get_country_from_phone_number(number, metadata)
  // {
  // 	return parse_phone_number(number, null, metadata).country
  // }

  // Parses a formatted phone number
  // and returns `{ countryCallingCode, number }`
  // where `number` is just the "number" part
  // which is left after extracting `countryCallingCode`
  // and is not necessarily a "national (significant) number"
  // and might as well contain national prefix.
  //
  function extractCountryCallingCode(number, country, metadata) {
  	number = parseIncompletePhoneNumber(number);

  	if (!number) {
  		return {};
  	}

  	// If this is not an international phone number,
  	// then don't extract country phone code.
  	if (number[0] !== '+') {
  		// Convert an "out-of-country" dialing phone number
  		// to a proper international phone number.
  		var numberWithoutIDD = stripIDDPrefix(number, country, metadata);

  		// If an IDD prefix was stripped then
  		// convert the number to international one
  		// for subsequent parsing.
  		if (numberWithoutIDD && numberWithoutIDD !== number) {
  			number = '+' + numberWithoutIDD;
  		} else {
  			return { number: number };
  		}
  	}

  	// Fast abortion: country codes do not begin with a '0'
  	if (number[1] === '0') {
  		return {};
  	}

  	metadata = new Metadata(metadata);

  	// The thing with country phone codes
  	// is that they are orthogonal to each other
  	// i.e. there's no such country phone code A
  	// for which country phone code B exists
  	// where B starts with A.
  	// Therefore, while scanning digits,
  	// if a valid country code is found,
  	// that means that it is the country code.
  	//
  	var i = 2;
  	while (i - 1 <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {
  		var countryCallingCode = number.slice(1, i);

  		if (metadata.countryCallingCodes()[countryCallingCode]) {
  			return {
  				countryCallingCode: countryCallingCode,
  				number: number.slice(i)
  			};
  		}

  		i++;
  	}

  	return {};
  }

  var _extends$2 = Object.assign || function (target) {
  var arguments$1 = arguments;
   for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function parsePhoneNumber(text, options, metadata) {
  	return parse$2(text, _extends$2({}, options, { v2: true }), metadata);
  }

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$3 = Object.assign || function (target) {
  var arguments$1 = arguments;
   for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _slicedToArray$1 = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) { break; } } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) { _i["return"](); } } finally { if (_d) { throw _e; } } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

  function parsePhoneNumber$1() {
  	var _normalizeArguments = normalizeArguments(arguments),
  	    text = _normalizeArguments.text,
  	    options = _normalizeArguments.options,
  	    metadata = _normalizeArguments.metadata;

  	return parsePhoneNumber(text, options, metadata);
  }

  function normalizeArguments(args) {
  	var _Array$prototype$slic = Array.prototype.slice.call(args),
  	    _Array$prototype$slic2 = _slicedToArray$1(_Array$prototype$slic, 4),
  	    arg_1 = _Array$prototype$slic2[0],
  	    arg_2 = _Array$prototype$slic2[1],
  	    arg_3 = _Array$prototype$slic2[2],
  	    arg_4 = _Array$prototype$slic2[3];

  	var text = void 0;
  	var options = void 0;
  	var metadata = void 0;

  	// If the phone number is passed as a string.
  	// `parsePhoneNumber('88005553535', ...)`.
  	if (typeof arg_1 === 'string') {
  		text = arg_1;
  	} else { throw new TypeError('A text for parsing must be a string.'); }

  	// If "default country" argument is being passed then move it to `options`.
  	// `parsePhoneNumber('88005553535', 'RU', [options], metadata)`.
  	if (!arg_2 || typeof arg_2 === 'string') {
  		if (arg_4) {
  			options = arg_3;
  			metadata = arg_4;
  		} else {
  			options = undefined;
  			metadata = arg_3;
  		}

  		if (arg_2) {
  			options = _extends$3({ defaultCountry: arg_2 }, options);
  		}
  	}
  	// `defaultCountry` is not passed.
  	// Example: `parsePhoneNumber('+78005553535', [options], metadata)`.
  	else if (isObject$5(arg_2)) {
  			if (arg_3) {
  				options = arg_2;
  				metadata = arg_3;
  			} else {
  				metadata = arg_2;
  			}
  		} else { throw new Error('Invalid second argument: ' + arg_2); }

  	return {
  		text: text,
  		options: options,
  		metadata: metadata
  	};
  }

  // Otherwise istanbul would show this as "branch not covered".
  /* istanbul ignore next */
  var isObject$5 = function isObject(_) {
  	return (typeof _ === 'undefined' ? 'undefined' : _typeof$1(_)) === 'object';
  };

  /** Returns a regular expression quantifier with an upper and lower limit. */
  function limit(lower, upper) {
  	if (lower < 0 || upper <= 0 || upper < lower) {
  		throw new TypeError();
  	}
  	return "{" + lower + "," + upper + "}";
  }

  /**
   * Trims away any characters after the first match of {@code pattern} in {@code candidate},
   * returning the trimmed version.
   */
  function trimAfterFirstMatch(regexp, string) {
  	var index = string.search(regexp);

  	if (index >= 0) {
  		return string.slice(0, index);
  	}

  	return string;
  }

  function startsWith(string, substring) {
  	return string.indexOf(substring) === 0;
  }

  function endsWith(string, substring) {
  	return string.indexOf(substring, string.length - substring.length) === string.length - substring.length;
  }

  // Regular expression of characters typically used to start a second phone number for the purposes
  // of parsing. This allows us to strip off parts of the number that are actually the start of
  // another number, such as for: (530) 583-6985 x302/x2303 -> the second extension here makes this
  // actually two phone numbers, (530) 583-6985 x302 and (530) 583-6985 x2303. We remove the second
  // extension so that the first number is parsed correctly.
  //
  // Matches a slash (\ or /) followed by a space followed by an `x`.
  //
  var SECOND_NUMBER_START_PATTERN = /[\\/] *x/;

  function parsePreCandidate(candidate) {
  	// Check for extra numbers at the end.
  	// TODO: This is the place to start when trying to support extraction of multiple phone number
  	// from split notations (+41 79 123 45 67 / 68).
  	return trimAfterFirstMatch(SECOND_NUMBER_START_PATTERN, candidate);
  }

  // Matches strings that look like dates using "/" as a separator.
  // Examples: 3/10/2011, 31/10/96 or 08/31/95.
  var SLASH_SEPARATED_DATES = /(?:(?:[0-3]?\d\/[01]?\d)|(?:[01]?\d\/[0-3]?\d))\/(?:[12]\d)?\d{2}/;

  // Matches timestamps.
  // Examples: "2012-01-02 08:00".
  // Note that the reg-ex does not include the
  // trailing ":\d\d" -- that is covered by TIME_STAMPS_SUFFIX.
  var TIME_STAMPS = /[12]\d{3}[-/]?[01]\d[-/]?[0-3]\d +[0-2]\d$/;
  var TIME_STAMPS_SUFFIX_LEADING = /^:[0-5]\d/;

  function isValidPreCandidate(candidate, offset, text) {
  	// Skip a match that is more likely to be a date.
  	if (SLASH_SEPARATED_DATES.test(candidate)) {
  		return false;
  	}

  	// Skip potential time-stamps.
  	if (TIME_STAMPS.test(candidate)) {
  		var followingText = text.slice(offset + candidate.length);
  		if (TIME_STAMPS_SUFFIX_LEADING.test(followingText)) {
  			return false;
  		}
  	}

  	return true;
  }

  // Javascript doesn't support UTF-8 regular expressions.
  // So mimicking them here.

  // Copy-pasted from `PhoneNumberMatcher.js`.

  /**
   * "\p{Z}" is any kind of whitespace or invisible separator ("Separator").
   * http://www.regular-expressions.info/unicode.html
   * "\P{Z}" is the reverse of "\p{Z}".
   * "\p{N}" is any kind of numeric character in any script ("Number").
   * "\p{Nd}" is a digit zero through nine in any script except "ideographic scripts" ("Decimal_Digit_Number").
   * "\p{Sc}" is a currency symbol ("Currency_Symbol").
   * "\p{L}" is any kind of letter from any language ("Letter").
   * "\p{Mn}" is "non-spacing mark".
   *
   * Javascript doesn't support Unicode Regular Expressions
   * so substituting it with this explicit set of characters.
   *
   * https://stackoverflow.com/questions/13210194/javascript-regex-equivalent-of-a-za-z-using-pl
   * https://github.com/danielberndt/babel-plugin-utf-8-regex/blob/master/src/transformer.js
   */

  var _pZ = ' \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000';
  var pZ = '[' + _pZ + ']';
  var PZ = '[^' + _pZ + ']';

  var _pN = '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19';
  // const pN = `[${_pN}]`

  var _pNd = '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19';
  var pNd = '[' + _pNd + ']';

  var _pL = 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC';
  var pL = '[' + _pL + ']';
  var pL_regexp = new RegExp(pL);

  var _pSc = '$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20B9\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6';
  var pSc = '[' + _pSc + ']';
  var pSc_regexp = new RegExp(pSc);

  var _pMn = '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26';
  var pMn = '[' + _pMn + ']';
  var pMn_regexp = new RegExp(pMn);

  var _InBasic_Latin = '\0-\x7F';
  var _InLatin_1_Supplement = '\x80-\xFF';
  var _InLatin_Extended_A = '\u0100-\u017F';
  var _InLatin_Extended_Additional = '\u1E00-\u1EFF';
  var _InLatin_Extended_B = '\u0180-\u024F';
  var _InCombining_Diacritical_Marks = '\u0300-\u036F';

  var latinLetterRegexp = new RegExp('[' + _InBasic_Latin + _InLatin_1_Supplement + _InLatin_Extended_A + _InLatin_Extended_Additional + _InLatin_Extended_B + _InCombining_Diacritical_Marks + ']');

  /**
   * Helper method to determine if a character is a Latin-script letter or not.
   * For our purposes, combining marks should also return true since we assume
   * they have been added to a preceding Latin character.
   */
  function isLatinLetter(letter) {
    // Combining marks are a subset of non-spacing-mark.
    if (!pL_regexp.test(letter) && !pMn_regexp.test(letter)) {
      return false;
    }

    return latinLetterRegexp.test(letter);
  }

  function isInvalidPunctuationSymbol(character) {
    return character === '%' || pSc_regexp.test(character);
  }

  // Copy-pasted from `PhoneNumberMatcher.js`.

  var OPENING_PARENS = '(\\[\uFF08\uFF3B';
  var CLOSING_PARENS = ')\\]\uFF09\uFF3D';
  var NON_PARENS = '[^' + OPENING_PARENS + CLOSING_PARENS + ']';

  var LEAD_CLASS = '[' + OPENING_PARENS + PLUS_CHARS + ']';

  // Punctuation that may be at the start of a phone number - brackets and plus signs.
  var LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS);

  // Limit on the number of pairs of brackets in a phone number.
  var BRACKET_PAIR_LIMIT = limit(0, 3);

  /**
   * Pattern to check that brackets match. Opening brackets should be closed within a phone number.
   * This also checks that there is something inside the brackets. Having no brackets at all is also
   * fine.
   *
   * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's
   * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a
   * closing bracket first. We limit the sets of brackets in a phone number to four.
   */
  var MATCHING_BRACKETS_ENTIRE = new RegExp('^' + "(?:[" + OPENING_PARENS + "])?" + "(?:" + NON_PARENS + "+" + "[" + CLOSING_PARENS + "])?" + NON_PARENS + "+" + "(?:[" + OPENING_PARENS + "]" + NON_PARENS + "+[" + CLOSING_PARENS + "])" + BRACKET_PAIR_LIMIT + NON_PARENS + "*" + '$');

  /**
   * Matches strings that look like publication pages. Example:
   * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.
   * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>
   *
   * The string "211-227 (2003)" is not a telephone number.
   */
  var PUB_PAGES = /\d{1,5}-+\d{1,5}\s{0,4}\(\d{1,4}/;

  function isValidCandidate(candidate, offset, text, leniency) {
  	// Check the candidate doesn't contain any formatting
  	// which would indicate that it really isn't a phone number.
  	if (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {
  		return;
  	}

  	// If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded
  	// by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.
  	if (leniency !== 'POSSIBLE') {
  		// If the candidate is not at the start of the text,
  		// and does not start with phone-number punctuation,
  		// check the previous character.
  		if (offset > 0 && !LEAD_CLASS_LEADING.test(candidate)) {
  			var previousChar = text[offset - 1];
  			// We return null if it is a latin letter or an invalid punctuation symbol.
  			if (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {
  				return false;
  			}
  		}

  		var lastCharIndex = offset + candidate.length;
  		if (lastCharIndex < text.length) {
  			var nextChar = text[lastCharIndex];
  			if (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {
  				return false;
  			}
  		}
  	}

  	return true;
  }

  var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

  function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  // Copy-pasted from `./parse.js`.
  var VALID_PHONE_NUMBER$1 = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';

  var WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+');
  var PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$');

  /**
   * Extracts a parseable phone number including any opening brackets, etc.
   * @param  {string} text - Input.
   * @return {object} `{ ?number, ?startsAt, ?endsAt }`.
   */
  var PhoneNumberSearch = function () {
  	function PhoneNumberSearch(text) {
  		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  		var metadata = arguments[2];

  		_classCallCheck$3(this, PhoneNumberSearch);

  		this.state = 'NOT_READY';

  		this.text = text;
  		this.options = options;
  		this.metadata = metadata;

  		this.regexp = new RegExp(VALID_PHONE_NUMBER$1 +
  		// Phone number extensions
  		'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?', 'ig');

  		// this.searching_from = 0
  	}
  	// Iteration tristate.


  	_createClass$2(PhoneNumberSearch, [{
  		key: 'find',
  		value: function find() {
  			var matches = this.regexp.exec(this.text);

  			if (!matches) {
  				return;
  			}

  			var number = matches[0];
  			var startsAt = matches.index;

  			number = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '');
  			startsAt += matches[0].length - number.length;
  			// Fixes not parsing numbers with whitespace in the end.
  			// Also fixes not parsing numbers with opening parentheses in the end.
  			// https://github.com/catamphetamine/libphonenumber-js/issues/252
  			number = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '');

  			number = parsePreCandidate(number);

  			var result = this.parseCandidate(number, startsAt);

  			if (result) {
  				return result;
  			}

  			// Tail recursion.
  			// Try the next one if this one is not a valid phone number.
  			return this.find();
  		}
  	}, {
  		key: 'parseCandidate',
  		value: function parseCandidate(number, startsAt) {
  			if (!isValidPreCandidate(number, startsAt, this.text)) {
  				return;
  			}

  			// Don't parse phone numbers which are non-phone numbers
  			// due to being part of something else (e.g. a UUID).
  			// https://github.com/catamphetamine/libphonenumber-js/issues/213
  			// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).
  			if (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {
  				return;
  			}

  			// // Prepend any opening brackets left behind by the
  			// // `PHONE_NUMBER_START_PATTERN` regexp.
  			// const text_before_number = text.slice(this.searching_from, startsAt)
  			// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)
  			// if (full_number_starts_at >= 0)
  			// {
  			// 	number   = text_before_number.slice(full_number_starts_at) + number
  			// 	startsAt = full_number_starts_at
  			// }
  			//
  			// this.searching_from = matches.lastIndex

  			var result = parse$2(number, this.options, this.metadata);

  			if (!result.phone) {
  				return;
  			}

  			result.startsAt = startsAt;
  			result.endsAt = startsAt + number.length;

  			return result;
  		}
  	}, {
  		key: 'hasNext',
  		value: function hasNext() {
  			if (this.state === 'NOT_READY') {
  				this.last_match = this.find();

  				if (this.last_match) {
  					this.state = 'READY';
  				} else {
  					this.state = 'DONE';
  				}
  			}

  			return this.state === 'READY';
  		}
  	}, {
  		key: 'next',
  		value: function next() {
  			// Check the state and find the next match as a side-effect if necessary.
  			if (!this.hasNext()) {
  				throw new Error('No next element');
  			}

  			// Don't retain that memory any longer than necessary.
  			var result = this.last_match;
  			this.last_match = null;
  			this.state = 'NOT_READY';
  			return result;
  		}
  	}]);

  	return PhoneNumberSearch;
  }();

  var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

  function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  // https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9

  var Node$2 = function Node(key, value) {
    var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var prev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck$4(this, Node);

    this.key = key;
    this.value = value;
    this.next = next;
    this.prev = prev;
  };

  var LRUCache = function () {
    //set default limit of 10 if limit is not passed.
    function LRUCache() {
      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

      _classCallCheck$4(this, LRUCache);

      this.size = 0;
      this.limit = limit;
      this.head = null;
      this.tail = null;
      this.cache = {};
    }

    // Write Node to head of LinkedList
    // update cache with Node key and Node reference


    _createClass$3(LRUCache, [{
      key: "put",
      value: function put(key, value) {
        this.ensureLimit();

        if (!this.head) {
          this.head = this.tail = new Node$2(key, value);
        } else {
          var node = new Node$2(key, value, this.head);
          this.head.prev = node;
          this.head = node;
        }

        //Update the cache map
        this.cache[key] = this.head;
        this.size++;
      }

      // Read from cache map and make that node as new Head of LinkedList

    }, {
      key: "get",
      value: function get(key) {
        if (this.cache[key]) {
          var value = this.cache[key].value;

          // node removed from it's position and cache
          this.remove(key);
          // write node again to the head of LinkedList to make it most recently used
          this.put(key, value);

          return value;
        }

        console.log("Item not available in cache for key " + key);
      }
    }, {
      key: "ensureLimit",
      value: function ensureLimit() {
        if (this.size === this.limit) {
          this.remove(this.tail.key);
        }
      }
    }, {
      key: "remove",
      value: function remove(key) {
        var node = this.cache[key];

        if (node.prev !== null) {
          node.prev.next = node.next;
        } else {
          this.head = node.next;
        }

        if (node.next !== null) {
          node.next.prev = node.prev;
        } else {
          this.tail = node.prev;
        }

        delete this.cache[key];
        this.size--;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = null;
        this.tail = null;
        this.size = 0;
        this.cache = {};
      }

      // // Invokes the callback function with every node of the chain and the index of the node.
      // forEach(fn) {
      //   let node = this.head;
      //   let counter = 0;
      //   while (node) {
      //     fn(node, counter);
      //     node = node.next;
      //     counter++;
      //   }
      // }

      // // To iterate over LRU with a 'for...of' loop
      // *[Symbol.iterator]() {
      //   let node = this.head;
      //   while (node) {
      //     yield node;
      //     node = node.next;
      //   }
      // }

    }]);

    return LRUCache;
  }();

  var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

  function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  // A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3
  // countries being used for the same doc with ~10 patterns for each country. Some pages will have
  // a lot more countries in use, but typically fewer numbers for each so expanding the cache for
  // that use-case won't have a lot of benefit.

  var RegExpCache = function () {
  	function RegExpCache(size) {
  		_classCallCheck$5(this, RegExpCache);

  		this.cache = new LRUCache(size);
  	}

  	_createClass$4(RegExpCache, [{
  		key: 'getPatternForRegExp',
  		value: function getPatternForRegExp(pattern) {
  			var regExp = this.cache.get(pattern);
  			if (!regExp) {
  				regExp = new RegExp('^' + pattern);
  				this.cache.put(pattern, regExp);
  			}
  			return regExp;
  		}
  	}]);

  	return RegExpCache;
  }();

  /**
   * Leniency when finding potential phone numbers in text segments
   * The levels here are ordered in increasing strictness.
   */
  var Leniency = {
    /**
     * Phone numbers accepted are "possible", but not necessarily "valid".
     */
    POSSIBLE: function POSSIBLE(number, candidate, metadata) {
      return true;
    },


    /**
     * Phone numbers accepted are "possible" and "valid".
     * Numbers written in national format must have their national-prefix
     * present if it is usually written for a number of this type.
     */
    VALID: function VALID(number, candidate, metadata) {
      if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidate.toString())) {
        return false;
      }

      // Skipped for simplicity.
      // return isNationalPrefixPresentIfRequired(number, metadata)
      return true;
    },


    /**
     * Phone numbers accepted are "valid" and
     * are grouped in a possible way for this locale. For example, a US number written as
     * "65 02 53 00 00" and "650253 0000" are not accepted at this leniency level, whereas
     * "650 253 0000", "650 2530000" or "6502530000" are.
     * Numbers with more than one '/' symbol in the national significant number
     * are also dropped at this level.
     *
     * Warning: This level might result in lower coverage especially for regions outside of
     * country code "+1". If you are not sure about which level to use,
     * email the discussion group libphonenumber-discuss@googlegroups.com.
     */
    STRICT_GROUPING: function STRICT_GROUPING(number, candidate, metadata, regExpCache) {
      var candidateString = candidate.toString();

      if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number)) {
        return false;
      }

      return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);
    },


    /**
     * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and
     * are grouped in the same way that we would have formatted it, or as a single block. For
     * example, a US number written as "650 2530000" is not accepted at this leniency level, whereas
     * "650 253 0000" or "6502530000" are.
     * Numbers with more than one '/' symbol are also dropped at this level.
     * <p>
     * Warning: This level might result in lower coverage especially for regions outside of country
     * code "+1". If you are not sure about which level to use, email the discussion group
     * libphonenumber-discuss@googlegroups.com.
     */
    EXACT_GROUPING: function EXACT_GROUPING(number, candidate, metadata, regExpCache) {
      var candidateString = candidate.toString();

      if (!isValidNumber(number, undefined, metadata) || !containsOnlyValidXChars(number, candidateString) || containsMoreThanOneSlashInNationalNumber(number, candidateString) || !isNationalPrefixPresentIfRequired(number)) {
        return false;
      }

      return checkNumberGroupingIsValid(number, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);
    }
  };

  function containsOnlyValidXChars(number, candidate, metadata) {
    // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the
    // national significant number or (2) an extension sign, in which case they always precede the
    // extension number. We assume a carrier code is more than 1 digit, so the first case has to
    // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'
    // or 'X'. We ignore the character if it appears as the last character of the string.
    for (var index = 0; index < candidate.length - 1; index++) {
      var charAtIndex = candidate.charAt(index);

      if (charAtIndex === 'x' || charAtIndex === 'X') {
        var charAtNextIndex = candidate.charAt(index + 1);

        if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {
          // This is the carrier code case, in which the 'X's always precede the national
          // significant number.
          index++;
          if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH) {
            return false;
          }
          // This is the extension sign case, in which the 'x' or 'X' should always precede the
          // extension number.
        } else if (parseDigits$1(candidate.substring(index)) !== number.ext) {
          return false;
        }
      }
    }

    return true;
  }

  function isNationalPrefixPresentIfRequired(number, _metadata) {
    // First, check how we deduced the country code. If it was written in international format, then
    // the national prefix is not required.
    if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY') {
      return true;
    }

    var phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode());

    var metadata = util.getMetadataForRegion(phoneNumberRegion);
    if (metadata == null) {
      return true;
    }

    // Check if a national prefix should be present when formatting this number.
    var nationalNumber = util.getNationalSignificantNumber(number);
    var formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber);

    // To do this, we check that a national prefix formatting rule was present
    // and that it wasn't just the first-group symbol ($1) with punctuation.
    if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0) {
      if (formatRule.getNationalPrefixOptionalWhenFormatting()) {
        // The national-prefix is optional in these cases, so we don't need to check if it was
        // present.
        return true;
      }

      if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(formatRule.getNationalPrefixFormattingRule())) {
        // National Prefix not needed for this number.
        return true;
      }

      // Normalize the remainder.
      var rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput());

      // Check if we found a national prefix and/or carrier code at the start of the raw input, and
      // return the result.
      return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null);
    }

    return true;
  }

  function containsMoreThanOneSlashInNationalNumber(number, candidate) {
    var firstSlashInBodyIndex = candidate.indexOf('/');
    if (firstSlashInBodyIndex < 0) {
      // No slashes, this is okay.
      return false;
    }

    // Now look for a second one.
    var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);
    if (secondSlashInBodyIndex < 0) {
      // Only one slash, this is okay.
      return false;
    }

    // If the first slash is after the country calling code, this is permitted.
    var candidateHasCountryCode = number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN;

    if (candidateHasCountryCode && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex)) === String(number.getCountryCode())) {
      // Any more slashes and this is illegal.
      return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;
    }

    return true;
  }

  function checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {
    var normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */);
    var formattedNumberGroups = getNationalNumberGroups(metadata, number, null);
    if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
      return true;
    }

    // If this didn't pass, see if there are any alternate formats that match, and try them instead.
    var alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode());
    var nationalSignificantNumber = util.getNationalSignificantNumber(number);

    if (alternateFormats) {
      for (var _iterator = alternateFormats.numberFormats(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) { break; }
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) { break; }
          _ref = _i.value;
        }

        var alternateFormat = _ref;

        if (alternateFormat.leadingDigitsPatterns().length > 0) {
          // There is only one leading digits pattern for alternate formats.
          var leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0]);
          if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {
            // Leading digits don't match; try another one.
            continue;
          }
        }
        formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat);
        if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Helper method to get the national-number part of a number, formatted without any national
   * prefix, and return it as a set of digit blocks that would be formatted together following
   * standard formatting rules.
   */
  function getNationalNumberGroups(metadata, number, formattingPattern) {
    if (formattingPattern) {
      // We format the NSN only, and split that according to the separator.
      var nationalSignificantNumber = util.getNationalSignificantNumber(number);
      return util.formatNsnUsingPattern(nationalSignificantNumber, formattingPattern, 'RFC3966', metadata).split('-');
    }

    // This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.
    var rfc3966Format = formatNumber(number, 'RFC3966', metadata);

    // We remove the extension part from the formatted string before splitting it into different
    // groups.
    var endIndex = rfc3966Format.indexOf(';');
    if (endIndex < 0) {
      endIndex = rfc3966Format.length;
    }

    // The country-code will have a '-' following it.
    var startIndex = rfc3966Format.indexOf('-') + 1;
    return rfc3966Format.slice(startIndex, endIndex).split('-');
  }

  function allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {
    var candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN);

    // Set this to the last group, skipping it if the number has an extension.
    var candidateNumberGroupIndex = number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1;

    // First we check if the national significant number is formatted as a block.
    // We use contains and not equals, since the national significant number may be present with
    // a prefix such as a national number prefix, or the country code itself.
    if (candidateGroups.length == 1 || candidateGroups[candidateNumberGroupIndex].contains(util.getNationalSignificantNumber(number))) {
      return true;
    }

    // Starting from the end, go through in reverse, excluding the first group, and check the
    // candidate and number groups are the same.
    var formattedNumberGroupIndex = formattedNumberGroups.length - 1;
    while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0) {
      if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex]) {
        return false;
      }
      formattedNumberGroupIndex--;
      candidateNumberGroupIndex--;
    }

    // Now check the first group. There may be a national prefix at the start, so we only check
    // that the candidate group ends with the formatted number group.
    return candidateNumberGroupIndex >= 0 && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]);
  }

  function allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {
    var fromIndex = 0;
    if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY) {
      // First skip the country code if the normalized candidate contained it.
      var countryCode = String(number.getCountryCode());
      fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length();
    }

    // Check each group of consecutive digits are not broken into separate groupings in the
    // {@code normalizedCandidate} string.
    for (var i = 0; i < formattedNumberGroups.length; i++) {
      // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}
      // doesn't contain the consecutive digits in formattedNumberGroups[i].
      fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex);
      if (fromIndex < 0) {
        return false;
      }
      // Moves {@code fromIndex} forward.
      fromIndex += formattedNumberGroups[i].length();
      if (i == 0 && fromIndex < normalizedCandidate.length()) {
        // We are at the position right after the NDC. We get the region used for formatting
        // information based on the country code in the phone number, rather than the number itself,
        // as we do not need to distinguish between different countries with the same country
        // calling code and this is faster.
        var region = util.getRegionCodeForCountryCode(number.getCountryCode());
        if (util.getNddPrefixForRegion(region, true) != null && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {
          // This means there is no formatting symbol after the NDC. In this case, we only
          // accept the number if there is no formatting symbol at all in the number, except
          // for extensions. This is only important for countries with national prefixes.
          var nationalSignificantNumber = util.getNationalSignificantNumber(number);
          return startsWith(normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length), nationalSignificantNumber);
        }
      }
    }

    // The check here makes sure that we haven't mistakenly already used the extension to
    // match the last group of the subscriber number. Note the extension cannot have
    // formatting in-between digits.
    return normalizedCandidate.slice(fromIndex).contains(number.getExtension());
  }

  var _extends$4 = Object.assign || function (target) {
  var arguments$1 = arguments;
   for (var i = 1; i < arguments.length; i++) { var source = arguments$1[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

  function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Patterns used to extract phone numbers from a larger phone-number-like pattern. These are
   * ordered according to specificity. For example, white-space is last since that is frequently
   * used in numbers, not just to separate two numbers. We have separate patterns since we don't
   * want to break up the phone-number-like text on more than one different kind of symbol at one
   * time, although symbols of the same type (e.g. space) can be safely grouped together.
   *
   * Note that if there is a match, we will always check any text found up to the first match as
   * well.
   */
  var INNER_MATCHES = [
  // Breaks on the slash - e.g. "651-234-2345/332-445-1234"
  '\\/+(.*)/',

  // Note that the bracket here is inside the capturing group, since we consider it part of the
  // phone number. Will match a pattern like "(650) 223 3345 (754) 223 3321".
  '(\\([^(]*)',

  // Breaks on a hyphen - e.g. "12345 - 332-445-1234 is my number."
  // We require a space on either side of the hyphen for it to be considered a separator.
  '(?:' + pZ + '-|-' + pZ + ')' + pZ + '*(.+)',

  // Various types of wide hyphens. Note we have decided not to enforce a space here, since it's
  // possible that it's supposed to be used to break two numbers without spaces, and we haven't
  // seen many instances of it used within a number.
  '[\u2012-\u2015\uFF0D]' + pZ + '*(.+)',

  // Breaks on a full stop - e.g. "12345. 332-445-1234 is my number."
  '\\.+' + pZ + '*([^.]+)',

  // Breaks on space - e.g. "3324451234 8002341234"
  pZ + '+(' + PZ + '+)'];

  // Limit on the number of leading (plus) characters.
  var leadLimit = limit(0, 2);

  // Limit on the number of consecutive punctuation characters.
  var punctuationLimit = limit(0, 4);

  /* The maximum number of digits allowed in a digit-separated block. As we allow all digits in a
   * single block, set high enough to accommodate the entire national number and the international
   * country code. */
  var digitBlockLimit = MAX_LENGTH_FOR_NSN + MAX_LENGTH_COUNTRY_CODE;

  // Limit on the number of blocks separated by punctuation.
  // Uses digitBlockLimit since some formats use spaces to separate each digit.
  var blockLimit = limit(0, digitBlockLimit);

  /* A punctuation sequence allowing white space. */
  var punctuation = '[' + VALID_PUNCTUATION + ']' + punctuationLimit;

  // A digits block without punctuation.
  var digitSequence = pNd + limit(1, digitBlockLimit);

  /**
   * Phone number pattern allowing optional punctuation.
   * The phone number pattern used by `find()`, similar to
   * VALID_PHONE_NUMBER, but with the following differences:
   * <ul>
   *   <li>All captures are limited in order to place an upper bound to the text matched by the
   *       pattern.
   * <ul>
   *   <li>Leading punctuation / plus signs are limited.
   *   <li>Consecutive occurrences of punctuation are limited.
   *   <li>Number of digits is limited.
   * </ul>
   *   <li>No whitespace is allowed at the start or end.
   *   <li>No alpha digits (vanity numbers such as 1-800-SIX-FLAGS) are currently supported.
   * </ul>
   */
  var PATTERN = '(?:' + LEAD_CLASS + punctuation + ')' + leadLimit + digitSequence + '(?:' + punctuation + digitSequence + ')' + blockLimit + '(?:' + EXTN_PATTERNS_FOR_MATCHING + ')?';

  // Regular expression of trailing characters that we want to remove.
  // We remove all characters that are not alpha or numerical characters.
  // The hash character is retained here, as it may signify
  // the previous block was an extension.
  //
  // // Don't know what does '&&' mean here.
  // const UNWANTED_END_CHAR_PATTERN = new RegExp(`[[\\P{N}&&\\P{L}]&&[^#]]+$`)
  //
  var UNWANTED_END_CHAR_PATTERN = new RegExp('[^' + _pN + _pL + '#]+$');

  var MAX_SAFE_INTEGER$7 = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

  /**
   * A stateful class that finds and extracts telephone numbers from {@linkplain CharSequence text}.
   * Instances can be created using the {@linkplain PhoneNumberUtil#findNumbers factory methods} in
   * {@link PhoneNumberUtil}.
   *
   * <p>Vanity numbers (phone numbers using alphabetic digits such as <tt>1-800-SIX-FLAGS</tt> are
   * not found.
   *
   * <p>This class is not thread-safe.
   */

  var PhoneNumberMatcher = function () {

    /**
     * Creates a new instance. See the factory methods in {@link PhoneNumberUtil} on how to obtain a
     * new instance.
     *
     * @param util  the phone number util to use
     * @param text  the character sequence that we will search, null for no text
     * @param country  the country to assume for phone numbers not written in international format
     *     (with a leading plus, or with the international dialing prefix of the specified region).
     *     May be null or "ZZ" if only numbers with a leading plus should be
     *     considered.
     * @param leniency  the leniency to use when evaluating candidate phone numbers
     * @param maxTries  the maximum number of invalid numbers to try before giving up on the text.
     *     This is to cover degenerate cases where the text has a lot of false positives in it. Must
     *     be {@code >= 0}.
     */


    /** The next index to start searching at. Undefined in {@link State#DONE}. */
    function PhoneNumberMatcher() {
      var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var metadata = arguments[2];

      _classCallCheck$6(this, PhoneNumberMatcher);

      this.state = 'NOT_READY';
      this.searchIndex = 0;
      this.regExpCache = new RegExpCache(32);

      options = _extends$4({}, options, {
        defaultCountry: options.defaultCountry && isSupportedCountry(options.defaultCountry, metadata) ? options.defaultCountry : undefined,
        leniency: options.leniency || options.extended ? 'POSSIBLE' : 'VALID',
        maxTries: options.maxTries || MAX_SAFE_INTEGER$7
      });

      if (!options.leniency) {
        throw new TypeError('`Leniency` not supplied');
      }

      if (options.maxTries < 0) {
        throw new TypeError('`maxTries` not supplied');
      }

      this.text = text;
      this.options = options;
      this.metadata = metadata;

      /** The degree of validation requested. */
      this.leniency = Leniency[options.leniency];

      if (!this.leniency) {
        throw new TypeError('Unknown leniency: ' + options.leniency + '.');
      }

      /** The maximum number of retries after matching an invalid number. */
      this.maxTries = options.maxTries;

      this.PATTERN = new RegExp(PATTERN, 'ig');
    }

    /**
     * Attempts to find the next subsequence in the searched sequence on or after {@code searchIndex}
     * that represents a phone number. Returns the next match, null if none was found.
     *
     * @param index  the search index to start searching at
     * @return  the phone number match found, null if none can be found
     */


    // A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3
    // countries being used for the same doc with ~10 patterns for each country. Some pages will have
    // a lot more countries in use, but typically fewer numbers for each so expanding the cache for
    // that use-case won't have a lot of benefit.

    /** The iteration tristate. */


    _createClass$5(PhoneNumberMatcher, [{
      key: 'find',
      value: function find() // (index)
      {
        // // Reset the regular expression.
        // this.PATTERN.lastIndex = index

        var matches = void 0;
        while (this.maxTries > 0 && (matches = this.PATTERN.exec(this.text)) !== null) {
          var candidate = matches[0];
          var offset = matches.index;

          candidate = parsePreCandidate(candidate);

          if (isValidPreCandidate(candidate, offset, this.text)) {
            var match =
            // Try to come up with a valid match given the entire candidate.
            this.parseAndVerify(candidate, offset, this.text)
            // If that failed, try to find an "inner match" -
            // there might be a phone number within this candidate.
            || this.extractInnerMatch(candidate, offset, this.text);

            if (match) {
              if (this.options.v2) {
                var phoneNumber = new PhoneNumber(match.country, match.phone, this.metadata);
                if (match.ext) {
                  phoneNumber.ext = match.ext;
                }
                return {
                  startsAt: match.startsAt,
                  endsAt: match.endsAt,
                  number: phoneNumber
                };
              }
              return match;
            }
          }

          this.maxTries--;
        }
      }

      /**
       * Attempts to extract a match from `candidate`
       * if the whole candidate does not qualify as a match.
       */

    }, {
      key: 'extractInnerMatch',
      value: function extractInnerMatch(candidate, offset, text) {
        for (var _iterator = INNER_MATCHES, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) { break; }
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) { break; }
            _ref = _i.value;
          }

          var innerMatchPattern = _ref;

          var isFirstMatch = true;
          var matches = void 0;
          var possibleInnerMatch = new RegExp(innerMatchPattern, 'g');
          while ((matches = possibleInnerMatch.exec(candidate)) !== null && this.maxTries > 0) {
            if (isFirstMatch) {
              // We should handle any group before this one too.
              var _group = trimAfterFirstMatch(UNWANTED_END_CHAR_PATTERN, candidate.slice(0, matches.index));

              var _match = this.parseAndVerify(_group, offset, text);
              if (_match) {
                return _match;
              }

              this.maxTries--;
              isFirstMatch = false;
            }

            var group = trimAfterFirstMatch(UNWANTED_END_CHAR_PATTERN, matches[1]);

            // Java code does `groupMatcher.start(1)` here,
            // but there's no way in javascript to get a group match start index,
            // therefore using the overall match start index `matches.index`.
            var match = this.parseAndVerify(group, offset + matches.index, text);
            if (match) {
              return match;
            }

            this.maxTries--;
          }
        }
      }

      /**
       * Parses a phone number from the `candidate` using `parseNumber` and
       * verifies it matches the requested `leniency`. If parsing and verification succeed,
       * a corresponding `PhoneNumberMatch` is returned, otherwise this method returns `null`.
       *
       * @param candidate  the candidate match
       * @param offset  the offset of {@code candidate} within {@link #text}
       * @return  the parsed and validated phone number match, or null
       */

    }, {
      key: 'parseAndVerify',
      value: function parseAndVerify(candidate, offset, text) {
        if (!isValidCandidate(candidate, offset, text, this.options.leniency)) {
          return;
        }

        var number = parse$2(candidate, {
          extended: true,
          defaultCountry: this.options.defaultCountry
        }, this.metadata);

        if (!number.possible) {
          return;
        }

        if (this.leniency(number, candidate, this.metadata, this.regExpCache)) {
          // // We used parseAndKeepRawInput to create this number,
          // // but for now we don't return the extra values parsed.
          // // TODO: stop clearing all values here and switch all users over
          // // to using rawInput() rather than the rawString() of PhoneNumberMatch.
          // number.clearCountryCodeSource()
          // number.clearRawInput()
          // number.clearPreferredDomesticCarrierCode()

          var result = {
            startsAt: offset,
            endsAt: offset + candidate.length,
            country: number.country,
            phone: number.phone
          };

          if (number.ext) {
            result.ext = number.ext;
          }

          return result;
        }
      }
    }, {
      key: 'hasNext',
      value: function hasNext() {
        if (this.state === 'NOT_READY') {
          this.lastMatch = this.find(); // (this.searchIndex)

          if (this.lastMatch) {
            // this.searchIndex = this.lastMatch.endsAt
            this.state = 'READY';
          } else {
            this.state = 'DONE';
          }
        }

        return this.state === 'READY';
      }
    }, {
      key: 'next',
      value: function next() {
        // Check the state and find the next match as a side-effect if necessary.
        if (!this.hasNext()) {
          throw new Error('No next element');
        }

        // Don't retain that memory any longer than necessary.
        var result = this.lastMatch;
        this.lastMatch = null;
        this.state = 'NOT_READY';
        return result;
      }
    }]);

    return PhoneNumberMatcher;
  }();

  var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) { descriptor.writable = true; } Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) { defineProperties(Constructor.prototype, protoProps); } if (staticProps) { defineProperties(Constructor, staticProps); } return Constructor; }; }();

  function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  // Used in phone number format template creation.
  // Could be any digit, I guess.
  var DUMMY_DIGIT = '9';
  // I don't know why is it exactly `15`
  var LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;
  // Create a phone number consisting only of the digit 9 that matches the
  // `number_pattern` by applying the pattern to the "longest phone number" string.
  var LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);

  // The digits that have not been entered yet will be represented by a \u2008,
  // the punctuation space.
  var DIGIT_PLACEHOLDER = 'x'; // '\u2008' (punctuation space)
  var DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);

  // A pattern that is used to match character classes in regular expressions.
  // An example of a character class is "[1-4]".
  var CREATE_CHARACTER_CLASS_PATTERN =  function () {
  	return (/\[([^\[\]])*\]/g
  	);
  };

  // Any digit in a regular expression that actually denotes a digit. For
  // example, in the regular expression "80[0-2]\d{6,10}", the first 2 digits
  // (8 and 0) are standalone digits, but the rest are not.
  // Two look-aheads are needed because the number following \\d could be a
  // two-digit number, since the phone number can be as long as 15 digits.
  var CREATE_STANDALONE_DIGIT_PATTERN =  function () {
  	return (/\d(?=[^,}][^,}])/g
  	);
  };

  // A pattern that is used to determine if a `format` is eligible
  // to be used by the "as you type formatter".
  // It is eligible when the `format` contains groups of the dollar sign
  // followed by a single digit, separated by valid phone number punctuation.
  // This prevents invalid punctuation (such as the star sign in Israeli star numbers)
  // getting into the output of the "as you type formatter".
  var ELIGIBLE_FORMAT_PATTERN = new RegExp('^' + '[' + VALID_PUNCTUATION + ']*' + '(\\$\\d[' + VALID_PUNCTUATION + ']*)+' + '$');

  // This is the minimum length of the leading digits of a phone number
  // to guarantee the first "leading digits pattern" for a phone number format
  // to be preemptive.
  var MIN_LEADING_DIGITS_LENGTH = 3;

  var VALID_INCOMPLETE_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';

  var VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i');

  var AsYouType = function () {

  	/**
    * @param {string?} [defaultCountry] - The default country used for parsing non-international phone numbers.
    * @param {Object} metadata
    */
  	function AsYouType(defaultCountry, metadata) {
  		_classCallCheck$7(this, AsYouType);

  		this.options = {};

  		this.metadata = new Metadata(metadata);

  		if (defaultCountry && this.metadata.hasCountry(defaultCountry)) {
  			this.defaultCountry = defaultCountry;
  		}

  		this.reset();
  	}
  	// Not setting `options` to a constructor argument
  	// not to break backwards compatibility
  	// for older versions of the library.


  	_createClass$6(AsYouType, [{
  		key: 'input',
  		value: function input(text) {
  			// Parse input

  			var extracted_number = extract_formatted_phone_number(text) || '';

  			// Special case for a lone '+' sign
  			// since it's not considered a possible phone number.
  			if (!extracted_number) {
  				if (text && text.indexOf('+') >= 0) {
  					extracted_number = '+';
  				}
  			}

  			// Validate possible first part of a phone number
  			if (!VALID_INCOMPLETE_PHONE_NUMBER_PATTERN.test(extracted_number)) {
  				return this.currentOutput;
  			}

  			return this.processInput(parseIncompletePhoneNumber(extracted_number));
  		}
  	}, {
  		key: 'processInput',
  		value: function processInput(input) {
  			// If an out of position '+' sign detected
  			// (or a second '+' sign),
  			// then just drop it from the input.
  			if (input[0] === '+') {
  				if (!this.parsedInput) {
  					this.parsedInput += '+';

  					// If a default country was set
  					// then reset it because an explicitly international
  					// phone number is being entered
  					this.resetCountriness();
  				}

  				input = input.slice(1);
  			}

  			// Raw phone number
  			this.parsedInput += input;

  			// // Reset phone number validation state
  			// this.valid = false

  			// Add digits to the national number
  			this.nationalNumber += input;

  			// TODO: Deprecated: rename `this.nationalNumber`
  			// to `this.nationalNumber` and remove `.getNationalNumber()`.

  			// Try to format the parsed input

  			if (this.isInternational()) {
  				if (!this.countryCallingCode) {
  					// Extract country calling code from the digits entered so far.

  					// There must be some digits in order to extract anything from them.
  					if (!this.nationalNumber) {
  						// Return raw phone number
  						return this.parsedInput;
  					}

  					// If one looks at country phone codes
  					// then he can notice that no one country phone code
  					// is ever a (leftmost) substring of another country phone code.
  					// So if a valid country code is extracted so far
  					// then it means that this is the country code.

  					// If no country phone code could be extracted so far,
  					// then just return the raw phone number,
  					// because it has no way of knowing
  					// how to format the phone number so far.
  					if (!this.extractCountryCallingCode()) {
  						// Return raw phone number
  						return this.parsedInput;
  					}

  					// Initialize country-specific data
  					this.initialize_phone_number_formats_for_this_country_calling_code();
  					this.resetFormat();
  					this.determineTheCountry();
  				}
  				// `this.country` could be `undefined`,
  				// for instance, when there is ambiguity
  				// in a form of several different countries
  				// each corresponding to the same country phone code
  				// (e.g. NANPA: USA, Canada, etc),
  				// and there's not enough digits entered
  				// to reliably determine the country
  				// the phone number belongs to.
  				// Therefore, in cases of such ambiguity,
  				// each time something is input,
  				// try to determine the country
  				// (if it's not determined yet).
  				else if (!this.country) {
  						this.determineTheCountry();
  					}
  			} else {
  				// Some national prefixes are substrings of other national prefixes
  				// (for the same country), therefore try to extract national prefix each time
  				// because a longer national prefix might be available at some point in time.

  				var previous_national_prefix = this.nationalPrefix;
  				this.nationalNumber = this.nationalPrefix + this.nationalNumber;

  				// Possibly extract a national prefix
  				this.extractNationalPrefix();

  				if (this.nationalPrefix !== previous_national_prefix) {
  					// National number has changed
  					// (due to another national prefix been extracted)
  					// therefore national number has changed
  					// therefore reset all previous formatting data.
  					// (and leading digits matching state)
  					this.matching_formats = undefined;
  					this.resetFormat();
  				}
  			}

  			// if (!this.shouldFormat())
  			// {
  			// 	return this.format_as_non_formatted_number()
  			// }

  			if (!this.nationalNumber) {
  				return this.format_as_non_formatted_number();
  			}

  			// Check the available phone number formats
  			// based on the currently available leading digits.
  			this.match_formats_by_leading_digits();

  			// Format the phone number (given the next digits)
  			var formatted_national_phone_number = this.formatNationalNumber(input);

  			// If the phone number could be formatted,
  			// then return it, possibly prepending with country phone code
  			// (for international phone numbers only)
  			if (formatted_national_phone_number) {
  				return this.formatFullNumber(formatted_national_phone_number);
  			}

  			// If the phone number couldn't be formatted,
  			// then just fall back to the raw phone number.
  			return this.format_as_non_formatted_number();
  		}
  	}, {
  		key: 'format_as_non_formatted_number',
  		value: function format_as_non_formatted_number() {
  			// Strip national prefix for incorrectly inputted international phones.
  			if (this.isInternational() && this.countryCallingCode) {
  				return '+' + this.countryCallingCode + this.nationalNumber;
  			}

  			return this.parsedInput;
  		}
  	}, {
  		key: 'formatNationalNumber',
  		value: function formatNationalNumber(next_digits) {
  			// Format the next phone number digits
  			// using the previously chosen phone number format.
  			//
  			// This is done here because if `attempt_to_format_complete_phone_number`
  			// was placed before this call then the `template`
  			// wouldn't reflect the situation correctly (and would therefore be inconsistent)
  			//
  			var national_number_formatted_with_previous_format = void 0;
  			if (this.chosenFormat) {
  				national_number_formatted_with_previous_format = this.formatNextNationalNumberDigits(next_digits);
  			}

  			// See if the input digits can be formatted properly already. If not,
  			// use the results from formatNextNationalNumberDigits(), which does formatting
  			// based on the formatting pattern chosen.

  			var formatted_number = this.attempt_to_format_complete_phone_number();

  			// Just because a phone number doesn't have a suitable format
  			// that doesn't mean that the phone is invalid
  			// because phone number formats only format phone numbers,
  			// they don't validate them and some (rare) phone numbers
  			// are meant to stay non-formatted.
  			if (formatted_number) {
  				return formatted_number;
  			}

  			// For some phone number formats national prefix

  			// If the previously chosen phone number format
  			// didn't match the next (current) digit being input
  			// (leading digits pattern didn't match).
  			if (this.chooseAnotherFormat()) {
  				// And a more appropriate phone number format
  				// has been chosen for these `leading digits`,
  				// then format the national phone number (so far)
  				// using the newly selected phone number pattern.

  				// Will return `undefined` if it couldn't format
  				// the supplied national number
  				// using the selected phone number pattern.

  				return this.reformatNationalNumber();
  			}

  			// If could format the next (current) digit
  			// using the previously chosen phone number format
  			// then return the formatted number so far.

  			// If no new phone number format could be chosen,
  			// and couldn't format the supplied national number
  			// using the selected phone number pattern,
  			// then it will return `undefined`.

  			return national_number_formatted_with_previous_format;
  		}
  	}, {
  		key: 'reset',
  		value: function reset() {
  			// Input stripped of non-phone-number characters.
  			// Can only contain a possible leading '+' sign and digits.
  			this.parsedInput = '';

  			this.currentOutput = '';

  			// This contains the national prefix that has been extracted. It contains only
  			// digits without formatting.
  			this.nationalPrefix = '';

  			this.nationalNumber = '';
  			this.carrierCode = '';

  			this.resetCountriness();

  			this.resetFormat();

  			return this;
  		}
  	}, {
  		key: 'resetCountry',
  		value: function resetCountry() {
  			if (this.isInternational()) {
  				this.country = undefined;
  			} else {
  				this.country = this.defaultCountry;
  			}
  		}
  	}, {
  		key: 'resetCountriness',
  		value: function resetCountriness() {
  			this.resetCountry();

  			if (this.defaultCountry && !this.isInternational()) {
  				this.metadata.country(this.defaultCountry);
  				this.countryCallingCode = this.metadata.countryCallingCode();

  				this.initialize_phone_number_formats_for_this_country_calling_code();
  			} else {
  				this.metadata.country(undefined);
  				this.countryCallingCode = undefined;

  				// "Available formats" are all formats available for the country.
  				// "Matching formats" are only formats eligible for the national number being entered.
  				this.available_formats = [];
  				this.matching_formats = undefined;
  			}
  		}
  	}, {
  		key: 'resetFormat',
  		value: function resetFormat() {
  			this.chosenFormat = undefined;
  			this.template = undefined;
  			this.partially_populated_template = undefined;
  			this.last_match_position = -1;
  		}

  		// Format each digit of national phone number (so far)
  		// using the newly selected phone number pattern.

  	}, {
  		key: 'reformatNationalNumber',
  		value: function reformatNationalNumber() {
  			// Format each digit of national phone number (so far)
  			// using the selected phone number pattern.
  			return this.formatNextNationalNumberDigits(this.nationalNumber);
  		}
  	}, {
  		key: 'initialize_phone_number_formats_for_this_country_calling_code',
  		value: function initialize_phone_number_formats_for_this_country_calling_code() {
  			// Get all "eligible" phone number formats for this country
  			this.available_formats = this.metadata.formats().filter(function (format) {
  				return ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat());
  			});

  			this.matching_formats = undefined;
  		}
  	}, {
  		key: 'match_formats_by_leading_digits',
  		value: function match_formats_by_leading_digits() {
  			var leading_digits = this.nationalNumber;

  			// "leading digits" pattern list starts with a
  			// "leading digits" pattern fitting a maximum of 3 leading digits.
  			// So, after a user inputs 3 digits of a national (significant) phone number
  			// this national (significant) number can already be formatted.
  			// The next "leading digits" pattern is for 4 leading digits max,
  			// and the "leading digits" pattern after it is for 5 leading digits max, etc.

  			// This implementation is different from Google's
  			// in that it searches for a fitting format
  			// even if the user has entered less than
  			// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.
  			// Because some leading digits patterns already match for a single first digit.
  			var index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH;
  			if (index_of_leading_digits_pattern < 0) {
  				index_of_leading_digits_pattern = 0;
  			}

  			// "Available formats" are all formats available for the country.
  			// "Matching formats" are only formats eligible for the national number being entered.

  			// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available
  			// then format matching starts narrowing down the list of possible formats
  			// (only previously matched formats are considered for next digits).
  			var available_formats = this.had_enough_leading_digits && this.matching_formats || this.available_formats;
  			this.had_enough_leading_digits = this.shouldFormat();

  			this.matching_formats = available_formats.filter(function (format) {
  				var leading_digits_patterns_count = format.leadingDigitsPatterns().length;

  				// If this format is not restricted to a certain
  				// leading digits pattern then it fits.
  				if (leading_digits_patterns_count === 0) {
  					return true;
  				}

  				var leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_patterns_count - 1);
  				var leading_digits_pattern = format.leadingDigitsPatterns()[leading_digits_pattern_index];

  				// Brackets are required for `^` to be applied to
  				// all or-ed (`|`) parts, not just the first one.
  				return new RegExp('^(' + leading_digits_pattern + ')').test(leading_digits);
  			});

  			// If there was a phone number format chosen
  			// and it no longer holds given the new leading digits then reset it.
  			// The test for this `if` condition is marked as:
  			// "Reset a chosen format when it no longer holds given the new leading digits".
  			// To construct a valid test case for this one can find a country
  			// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`
  			// and yielding another format for 4 `<leadingDigits>` (Australia in this case).
  			if (this.chosenFormat && this.matching_formats.indexOf(this.chosenFormat) === -1) {
  				this.resetFormat();
  			}
  		}
  	}, {
  		key: 'shouldFormat',
  		value: function shouldFormat() {
  			// Start matching any formats at all when the national number
  			// entered so far is at least 3 digits long,
  			// otherwise format matching would give false negatives
  			// like when the digits entered so far are `2`
  			// and the leading digits pattern is `21` –
  			// it's quite obvious in this case that the format could be the one
  			// but due to the absence of further digits it would give false negative.
  			//
  			// Presumably the limitation of "3 digits min"
  			// is imposed to exclude false matches,
  			// e.g. when there are two different formats
  			// each one fitting one or two leading digits being input.
  			// But for this case I would propose a specific `if/else` condition.
  			//
  			return this.nationalNumber.length >= MIN_LEADING_DIGITS_LENGTH;
  		}

  		// Check to see if there is an exact pattern match for these digits. If so, we
  		// should use this instead of any other formatting template whose
  		// `leadingDigitsPattern` also matches the input.

  	}, {
  		key: 'attempt_to_format_complete_phone_number',
  		value: function attempt_to_format_complete_phone_number() {
  			for (var _iterator = this.matching_formats, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
  				var _ref;

  				if (_isArray) {
  					if (_i >= _iterator.length) { break; }
  					_ref = _iterator[_i++];
  				} else {
  					_i = _iterator.next();
  					if (_i.done) { break; }
  					_ref = _i.value;
  				}

  				var format = _ref;

  				var matcher = new RegExp('^(?:' + format.pattern() + ')$');

  				if (!matcher.test(this.nationalNumber)) {
  					continue;
  				}

  				if (!this.isFormatApplicable(format)) {
  					continue;
  				}

  				// To leave the formatter in a consistent state
  				this.resetFormat();
  				this.chosenFormat = format;

  				var formatted_number = format_national_number_using_format(this.nationalNumber, format, this.isInternational(), this.nationalPrefix !== '', this.metadata);

  				// Special handling for NANPA countries for AsYouType formatter.
  				// Copied from Google's `libphonenumber`:
  				// https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573
  				if (this.nationalPrefix && this.countryCallingCode === '1') {
  					formatted_number = '1 ' + formatted_number;
  				}

  				// Set `this.template` and `this.partially_populated_template`.
  				//
  				// `else` case doesn't ever happen
  				// with the current metadata,
  				// but just in case.
  				//
  				/* istanbul ignore else */
  				if (this.createFormattingTemplate(format)) {
  					// Populate `this.partially_populated_template`
  					this.reformatNationalNumber();
  				} else {
  					// Prepend `+CountryCode` in case of an international phone number
  					var full_number = this.formatFullNumber(formatted_number);
  					this.template = full_number.replace(/[\d\+]/g, DIGIT_PLACEHOLDER);
  					this.partially_populated_template = full_number;
  				}

  				return formatted_number;
  			}
  		}

  		// Prepends `+CountryCode` in case of an international phone number

  	}, {
  		key: 'formatFullNumber',
  		value: function formatFullNumber(formattedNationalNumber) {
  			if (this.isInternational()) {
  				return '+' + this.countryCallingCode + ' ' + formattedNationalNumber;
  			}
  			return formattedNationalNumber;
  		}

  		// Extracts the country calling code from the beginning
  		// of the entered `national_number` (so far),
  		// and places the remaining input into the `national_number`.

  	}, {
  		key: 'extractCountryCallingCode',
  		value: function extractCountryCallingCode$1() {
  			var _extractCountryCallin = extractCountryCallingCode(this.parsedInput, this.defaultCountry, this.metadata.metadata),
  			    countryCallingCode = _extractCountryCallin.countryCallingCode,
  			    number = _extractCountryCallin.number;

  			if (!countryCallingCode) {
  				return;
  			}

  			this.countryCallingCode = countryCallingCode;

  			// Sometimes people erroneously write national prefix
  			// as part of an international number, e.g. +44 (0) ....
  			// This violates the standards for international phone numbers,
  			// so "As You Type" formatter assumes no national prefix
  			// when parsing a phone number starting from `+`.
  			// Even if it did attempt to filter-out that national prefix
  			// it would look weird for a user trying to enter a digit
  			// because from user's perspective the keyboard "wouldn't be working".
  			this.nationalNumber = number;

  			this.metadata.chooseCountryByCountryCallingCode(countryCallingCode);
  			return this.metadata.selectedCountry() !== undefined;
  		}
  	}, {
  		key: 'extractNationalPrefix',
  		value: function extractNationalPrefix() {
  			this.nationalPrefix = '';

  			if (!this.metadata.selectedCountry()) {
  				return;
  			}

  			// Only strip national prefixes for non-international phone numbers
  			// because national prefixes can't be present in international phone numbers.
  			// While `parseNumber()` is forgiving is such cases, `AsYouType` is not.

  			var _strip_national_prefi = strip_national_prefix_and_carrier_code(this.nationalNumber, this.metadata),
  			    potential_national_number = _strip_national_prefi.number,
  			    carrierCode = _strip_national_prefi.carrierCode;

  			if (carrierCode) {
  				this.carrierCode = carrierCode;
  			}

  			// We require that the NSN remaining after stripping the national prefix and
  			// carrier code be long enough to be a possible length for the region.
  			// Otherwise, we don't do the stripping, since the original number could be
  			// a valid short number.
  			if (!this.metadata.possibleLengths() || this.isPossibleNumber(this.nationalNumber) && !this.isPossibleNumber(potential_national_number)) {
  				// Verify the parsed national (significant) number for this country
  				//
  				// If the original number (before stripping national prefix) was viable,
  				// and the resultant number is not, then prefer the original phone number.
  				// This is because for some countries (e.g. Russia) the same digit could be both
  				// a national prefix and a leading digit of a valid national phone number,
  				// like `8` is the national prefix for Russia and both
  				// `8 800 555 35 35` and `800 555 35 35` are valid numbers.
  				if (matchesEntirely(this.nationalNumber, this.metadata.nationalNumberPattern()) && !matchesEntirely(potential_national_number, this.metadata.nationalNumberPattern())) {
  					return;
  				}
  			}

  			this.nationalPrefix = this.nationalNumber.slice(0, this.nationalNumber.length - potential_national_number.length);
  			this.nationalNumber = potential_national_number;

  			return this.nationalPrefix;
  		}
  	}, {
  		key: 'isPossibleNumber',
  		value: function isPossibleNumber(number) {
  			var validation_result = checkNumberLengthForType(number, undefined, this.metadata);
  			switch (validation_result) {
  				case 'IS_POSSIBLE':
  					return true;
  				// case 'IS_POSSIBLE_LOCAL_ONLY':
  				// 	return !this.isInternational()
  				default:
  					return false;
  			}
  		}
  	}, {
  		key: 'chooseAnotherFormat',
  		value: function chooseAnotherFormat() {
  			// When there are multiple available formats, the formatter uses the first
  			// format where a formatting template could be created.
  			for (var _iterator2 = this.matching_formats, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
  				var _ref2;

  				if (_isArray2) {
  					if (_i2 >= _iterator2.length) { break; }
  					_ref2 = _iterator2[_i2++];
  				} else {
  					_i2 = _iterator2.next();
  					if (_i2.done) { break; }
  					_ref2 = _i2.value;
  				}

  				var format = _ref2;

  				// If this format is currently being used
  				// and is still possible, then stick to it.
  				if (this.chosenFormat === format) {
  					return;
  				}

  				// If this `format` is suitable for "as you type",
  				// then extract the template from this format
  				// and use it to format the phone number being input.

  				if (!this.isFormatApplicable(format)) {
  					continue;
  				}

  				if (!this.createFormattingTemplate(format)) {
  					continue;
  				}

  				this.chosenFormat = format;

  				// With a new formatting template, the matched position
  				// using the old template needs to be reset.
  				this.last_match_position = -1;

  				return true;
  			}

  			// No format matches the phone number,
  			// therefore set `country` to `undefined`
  			// (or to the default country).
  			this.resetCountry();

  			// No format matches the national phone number entered
  			this.resetFormat();
  		}
  	}, {
  		key: 'isFormatApplicable',
  		value: function isFormatApplicable(format) {
  			// If national prefix is mandatory for this phone number format
  			// and the user didn't input the national prefix
  			// then this phone number format isn't suitable.
  			if (!this.isInternational() && !this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormatting()) {
  				return false;
  			}
  			// If this format doesn't use national prefix
  			// but the user did input national prefix
  			// then this phone number format isn't suitable.
  			if (this.nationalPrefix && !format.usesNationalPrefix() && !format.nationalPrefixIsOptionalWhenFormatting()) {
  				return false;
  			}
  			return true;
  		}
  	}, {
  		key: 'createFormattingTemplate',
  		value: function createFormattingTemplate(format) {
  			// The formatter doesn't format numbers when numberPattern contains '|', e.g.
  			// (20|3)\d{4}. In those cases we quickly return.
  			// (Though there's no such format in current metadata)
  			/* istanbul ignore if */
  			if ( format.pattern().indexOf('|') >= 0) {
  				return;
  			}

  			// Get formatting template for this phone number format
  			var template = this.getTemplateForNumberFormatPattern(format);

  			// If the national number entered is too long
  			// for any phone number format, then abort.
  			if (!template) {
  				return;
  			}

  			// This one is for national number only
  			this.partially_populated_template = template;

  			// For convenience, the public `.template` property
  			// contains the whole international number
  			// if the phone number being input is international:
  			// 'x' for the '+' sign, 'x'es for the country phone code,
  			// a spacebar and then the template for the formatted national number.
  			if (this.isInternational()) {
  				this.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) + ' ' + template;
  			}
  			// For local numbers, replace national prefix
  			// with a digit placeholder.
  			else {
  					this.template = template.replace(/\d/g, DIGIT_PLACEHOLDER);
  				}

  			// This one is for the full phone number
  			return this.template;
  		}

  		// Generates formatting template for a phone number format

  	}, {
  		key: 'getTemplateForNumberFormatPattern',
  		value: function getTemplateForNumberFormatPattern(format) {
  			// A very smart trick by the guys at Google
  			var number_pattern = format.pattern();

  			/* istanbul ignore else */
  			{
  				number_pattern = number_pattern
  				// Replace anything in the form of [..] with \d
  				.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\d')
  				// Replace any standalone digit (not the one in `{}`) with \d
  				.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\d');
  			}

  			// This match will always succeed,
  			// because the "longest dummy phone number"
  			// has enough length to accomodate any possible
  			// national phone number format pattern.
  			var dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0];

  			// If the national number entered is too long
  			// for any phone number format, then abort.
  			if (this.nationalNumber.length > dummy_phone_number_matching_format_pattern.length) {
  				return;
  			}

  			// Prepare the phone number format
  			var number_format = this.getFormatFormat(format);

  			// Get a formatting template which can be used to efficiently format
  			// a partial number where digits are added one by one.

  			// Below `strict_pattern` is used for the
  			// regular expression (with `^` and `$`).
  			// This wasn't originally in Google's `libphonenumber`
  			// and I guess they don't really need it
  			// because they're not using "templates" to format phone numbers
  			// but I added `strict_pattern` after encountering
  			// South Korean phone number formatting bug.
  			//
  			// Non-strict regular expression bug demonstration:
  			//
  			// this.nationalNumber : `111111111` (9 digits)
  			//
  			// number_pattern : (\d{2})(\d{3,4})(\d{4})
  			// number_format : `$1 $2 $3`
  			// dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)
  			//
  			// '9999999999'.replace(new RegExp(/(\d{2})(\d{3,4})(\d{4})/g), '$1 $2 $3') = "99 9999 9999"
  			//
  			// template : xx xxxx xxxx
  			//
  			// But the correct template in this case is `xx xxx xxxx`.
  			// The template was generated incorrectly because of the
  			// `{3,4}` variability in the `number_pattern`.
  			//
  			// The fix is, if `this.nationalNumber` has already sufficient length
  			// to satisfy the `number_pattern` completely then `this.nationalNumber` is used
  			// instead of `dummy_phone_number_matching_format_pattern`.

  			var strict_pattern = new RegExp('^' + number_pattern + '$');
  			var national_number_dummy_digits = this.nationalNumber.replace(/\d/g, DUMMY_DIGIT);

  			// If `this.nationalNumber` has already sufficient length
  			// to satisfy the `number_pattern` completely then use it
  			// instead of `dummy_phone_number_matching_format_pattern`.
  			if (strict_pattern.test(national_number_dummy_digits)) {
  				dummy_phone_number_matching_format_pattern = national_number_dummy_digits;
  			}

  			// Generate formatting template for this phone number format
  			return dummy_phone_number_matching_format_pattern
  			// Format the dummy phone number according to the format
  			.replace(new RegExp(number_pattern), number_format)
  			// Replace each dummy digit with a DIGIT_PLACEHOLDER
  			.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER);
  		}
  	}, {
  		key: 'formatNextNationalNumberDigits',
  		value: function formatNextNationalNumberDigits(digits) {
  			// Using `.split('')` to iterate through a string here
  			// to avoid requiring `Symbol.iterator` polyfill.
  			// `.split('')` is generally not safe for Unicode,
  			// but in this particular case for `digits` it is safe.
  			// for (const digit of digits)
  			for (var _iterator3 = digits.split(''), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
  				var _ref3;

  				if (_isArray3) {
  					if (_i3 >= _iterator3.length) { break; }
  					_ref3 = _iterator3[_i3++];
  				} else {
  					_i3 = _iterator3.next();
  					if (_i3.done) { break; }
  					_ref3 = _i3.value;
  				}

  				var digit = _ref3;

  				// If there is room for more digits in current `template`,
  				// then set the next digit in the `template`,
  				// and return the formatted digits so far.

  				// If more digits are entered than the current format could handle
  				if (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1) {
  					// Reset the current format,
  					// so that the new format will be chosen
  					// in a subsequent `this.chooseAnotherFormat()` call
  					// later in code.
  					this.chosenFormat = undefined;
  					this.template = undefined;
  					this.partially_populated_template = undefined;
  					return;
  				}

  				this.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER);
  				this.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);
  			}

  			// Return the formatted phone number so far.
  			return cut_stripping_dangling_braces(this.partially_populated_template, this.last_match_position + 1);

  			// The old way which was good for `input-format` but is not so good
  			// for `react-phone-number-input`'s default input (`InputBasic`).
  			// return close_dangling_braces(this.partially_populated_template, this.last_match_position + 1)
  			// 	.replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ')
  		}
  	}, {
  		key: 'isInternational',
  		value: function isInternational() {
  			return this.parsedInput && this.parsedInput[0] === '+';
  		}
  	}, {
  		key: 'getFormatFormat',
  		value: function getFormatFormat(format) {
  			if (this.isInternational()) {
  				return changeInternationalFormatStyle(format.internationalFormat());
  			}

  			// If national prefix formatting rule is set
  			// for this phone number format
  			if (format.nationalPrefixFormattingRule()) {
  				// If the user did input the national prefix
  				// (or if the national prefix formatting rule does not require national prefix)
  				// then maybe make it part of the phone number template
  				if (this.nationalPrefix || !format.usesNationalPrefix()) {
  					// Make the national prefix part of the phone number template
  					return format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule());
  				}
  			}
  			// Special handling for NANPA countries for AsYouType formatter.
  			// Copied from Google's `libphonenumber`:
  			// https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573
  			else if (this.countryCallingCode === '1' && this.nationalPrefix === '1') {
  					return '1 ' + format.format();
  				}

  			return format.format();
  		}

  		// Determines the country of the phone number
  		// entered so far based on the country phone code
  		// and the national phone number.

  	}, {
  		key: 'determineTheCountry',
  		value: function determineTheCountry() {
  			this.country = find_country_code(this.countryCallingCode, this.nationalNumber, this.metadata);
  		}

  		/**
     * Returns an instance of `PhoneNumber` class.
     * Will return `undefined` if no national (significant) number
     * digits have been entered so far, or if no `defaultCountry` has been
     * set and the user enters a phone number not in international format.
     */

  	}, {
  		key: 'getNumber',
  		value: function getNumber() {
  			if (!this.countryCallingCode || !this.nationalNumber) {
  				return undefined;
  			}
  			var phoneNumber = new PhoneNumber(this.country || this.countryCallingCode, this.nationalNumber, this.metadata.metadata);
  			if (this.carrierCode) {
  				phoneNumber.carrierCode = this.carrierCode;
  			}
  			// Phone number extensions are not supported by "As You Type" formatter.
  			return phoneNumber;
  		}
  	}, {
  		key: 'getNationalNumber',
  		value: function getNationalNumber() {
  			return this.nationalNumber;
  		}
  	}, {
  		key: 'getTemplate',
  		value: function getTemplate() {
  			if (!this.template) {
  				return;
  			}

  			var index = -1;

  			var i = 0;
  			while (i < this.parsedInput.length) {
  				index = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1);
  				i++;
  			}

  			return cut_stripping_dangling_braces(this.template, index + 1);
  		}
  	}]);

  	return AsYouType;
  }();


  function strip_dangling_braces(string) {
  	var dangling_braces = [];
  	var i = 0;
  	while (i < string.length) {
  		if (string[i] === '(') {
  			dangling_braces.push(i);
  		} else if (string[i] === ')') {
  			dangling_braces.pop();
  		}
  		i++;
  	}

  	var start = 0;
  	var cleared_string = '';
  	dangling_braces.push(string.length);
  	for (var _iterator4 = dangling_braces, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
  		var _ref4;

  		if (_isArray4) {
  			if (_i4 >= _iterator4.length) { break; }
  			_ref4 = _iterator4[_i4++];
  		} else {
  			_i4 = _iterator4.next();
  			if (_i4.done) { break; }
  			_ref4 = _i4.value;
  		}

  		var index = _ref4;

  		cleared_string += string.slice(start, index);
  		start = index + 1;
  	}

  	return cleared_string;
  }

  function cut_stripping_dangling_braces(string, cut_before_index) {
  	if (string[cut_before_index] === ')') {
  		cut_before_index++;
  	}
  	return strip_dangling_braces(string.slice(0, cut_before_index));
  }

  // Repeats a string (or a symbol) N times.
  // http://stackoverflow.com/questions/202605/repeat-string-javascript
  function repeat(string, times) {
  	if (times < 1) {
  		return '';
  	}

  	var result = '';

  	while (times > 1) {
  		if (times & 1) {
  			result += string;
  		}

  		times >>= 1;
  		string += string;
  	}

  	return result + string;
  }

  // Deprecated.

  function parsePhoneNumber$2()
  {
  	var parameters = Array.prototype.slice.call(arguments);
  	parameters.push(metadata);
  	return parsePhoneNumber$1.apply(this, parameters)
  }

  // Deprecated.
  function PhoneNumberSearch$1(text, options)
  {
  	PhoneNumberSearch.call(this, text, options, metadata);
  }

  // Deprecated.
  PhoneNumberSearch$1.prototype = Object.create(PhoneNumberSearch.prototype, {});
  PhoneNumberSearch$1.prototype.constructor = PhoneNumberSearch$1;

  function PhoneNumberMatcher$1(text, options)
  {
  	PhoneNumberMatcher.call(this, text, options, metadata);
  }

  PhoneNumberMatcher$1.prototype = Object.create(PhoneNumberMatcher.prototype, {});
  PhoneNumberMatcher$1.prototype.constructor = PhoneNumberMatcher$1;

  function AsYouType$1(country)
  {
  	AsYouType.call(this, country, metadata);
  }

  AsYouType$1.prototype = Object.create(AsYouType.prototype, {});
  AsYouType$1.prototype.constructor = AsYouType$1;

  var Tel = /*@__PURE__*/(function (Input) {
    function Tel(options) {
      if ( options === void 0 ) options = {};

      Input.call(this, options);

      this._country = null;
      this._format = null;

      this.setCountry(options.country);
      this.setFormat(options.format);

      this.attributes({
        type: 'tel'
      });
    }

    if ( Input ) Tel.__proto__ = Input;
    Tel.prototype = Object.create( Input && Input.prototype );
    Tel.prototype.constructor = Tel;

    Tel.prototype.getOptions = function getOptions () {
      return Object.assign(Input.prototype.getOptions.call(this), {
        country: this._country,
        format: this._format
      });
    };

    Tel.prototype.getFormat = function getFormat () {
      return this._format;
    };

    Tel.prototype.setFormat = function setFormat (value) {
      if ( value === void 0 ) value = 'E.164';

      this._format = value;
      return this;
    };

    Tel.prototype.getCountry = function getCountry () {
      return this._country;
    };

    Tel.prototype.setCountry = function setCountry (value) {
      if ( value === void 0 ) value = 'NL';

      this._country = value;
      return this;
    };

    Tel.prototype.format = function format (value) {
      return this.setFormat(value);
    };

    Tel.prototype.country = function country (value) {
      return this.setCountry(value);
    };

    Tel.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).trim());
    };

    Tel.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      var country = this.resolveValue(box, data, this._country);
      var number = null;

      try {
        number = parsePhoneNumber$2(value, country);
      } catch (err) {
        return this.setError(error, name, value, 'type');
      }

      if (number.isValid() === false) {
        return this.setError(error, name, value, 'type');
      }

      var format = this.resolveValue(box, data, this._format);

      this.setValue(data, name, number.format(format));

      return null;
    };

    return Tel;
  }(Input));

  var Text = /*@__PURE__*/(function (Input) {
    function Text(options) {
      Input.call(this, options);

      this.attributes({
        type: 'text'
      });
    }

    if ( Input ) Text.__proto__ = Input;
    Text.prototype = Object.create( Input && Input.prototype );
    Text.prototype.constructor = Text;

    Text.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).trim());
    };

    return Text;
  }(Input));

  var Textarea = /*@__PURE__*/(function (Input) {
    function Textarea(options) {
      if ( options === void 0 ) options = {};

      Input.call(this, options);

      this._grow = null;
      this.setGrow(options.grow);

      this.name('textarea');
    }

    if ( Input ) Textarea.__proto__ = Input;
    Textarea.prototype = Object.create( Input && Input.prototype );
    Textarea.prototype.constructor = Textarea;

    Textarea.prototype.getGrow = function getGrow () {
      return this._grow;
    };

    Textarea.prototype.setGrow = function setGrow (value) {
      if ( value === void 0 ) value = true;

      this._grow = value;
      return this;
    };

    Textarea.prototype.grow = function grow (value) {
      return this.setGrow(value);
    };

    Textarea.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).trim());
    };

    Textarea.prototype.removeBefore = function removeBefore () {
      if (this._grow) {
        this._node.on('.scola-textarea', null);
      }

      this.removeOuter();
    };

    Textarea.prototype.resolveAfter = function resolveAfter () {
      if (this._grow) {
        this.resolveGrow();
      }

      return this._node;
    };

    Textarea.prototype.resolveGrow = function resolveGrow () {
      var this$1 = this;

      var wrapper = this
        .wrapNode('div')
        .classed('input', true);

      var pre = wrapper.append('pre');
      var span = pre.append('span');

      pre.append('br');

      var style = window
        .getComputedStyle(this._node.node());

      wrapper
        .style('display', 'flex');

      pre
        .style('border', '1px solid black')
        .style('box-sizing', 'content-box')
        .style('position', 'absolute')
        .style('top', '-100%')
        .style('visibility', 'hidden')
        .style('white-space', 'pre-wrap')
        .style('word-wrap', 'break-word');

      this._node
        .style('box-sizing', 'content-box')
        .style('height', '100%')
        .style('margin', 0)
        .style('overflow', 'hidden')
        .style('resize', 'none')
        .style('width', '100%');

      [
        'border-bottom-width',
        'border-left-width',
        'border-right-width',
        'border-top-width',
        'min-height',
        'padding',
        'padding-bottom',
        'padding-left',
        'padding-right',
        'padding-top',
        'width'
      ].forEach(function (name) {
        pre.style(name, style[name]);
      });

      this._node.on('input.scola-textarea', function () {
        span.text(this$1._node.property('value'));
        this$1._node.style('height', pre.style('height'));
      });
    };

    return Textarea;
  }(Input));

  var Time = /*@__PURE__*/(function (DateTime) {
    function Time(options) {
      DateTime.call(this, options);

      this
        .attributes({
          type: 'time'
        })
        .format('HH:mm');
    }

    if ( DateTime ) Time.__proto__ = DateTime;
    Time.prototype = Object.create( DateTime && DateTime.prototype );
    Time.prototype.constructor = Time;

    return Time;
  }(DateTime$1));

  var Zip = /*@__PURE__*/(function (Input) {
    function Zip(options) {
      if ( options === void 0 ) options = {};

      Input.call(this, options);

      this._country = null;
      this.setCountry(options.country);

      this.attributes({
        type: 'zip'
      });
    }

    if ( Input ) Zip.__proto__ = Input;
    Zip.prototype = Object.create( Input && Input.prototype );
    Zip.prototype.constructor = Zip;

    Zip.prototype.getOptions = function getOptions () {
      return Object.assign(Input.prototype.getOptions.call(this), {
        country: this._country
      });
    };

    Zip.prototype.getCountry = function getCountry () {
      return this._country;
    };

    Zip.prototype.setCountry = function setCountry (value) {
      if ( value === void 0 ) value = 'NL';

      this._country = value;
      return this;
    };

    Zip.prototype.country = function country (value) {
      return this.setCountry(value);
    };

    Zip.prototype.cleanAfter = function cleanAfter (box, data, name, value) {
      this.setValue(data, name, String(value).replace(/[-\s]+/g, ''));
    };

    Zip.prototype.validateAfter = function validateAfter (box, data, error, name, value) {
      var country = this.resolveValue(box, data, this._country);

      if (postalcodes.validate(country, value) !== true) {
        return this.setError(error, name, value, 'type');
      }

      return null;
    };

    return Zip;
  }(Input));



  var input = /*#__PURE__*/Object.freeze({
    Password: Password,
    Checkbox: Checkbox,
    Date: Date$1,
    DateTime: DateTime$1,
    Email: Email,
    File: File$1,
    Iban: Iban,
    Month: Month,
    Number: Number$1,
    Color: Color$1,
    Range: Range,
    Radio: Radio,
    Select: Select,
    Tel: Tel,
    Text: Text,
    Textarea: Textarea,
    Time: Time,
    Zip: Zip
  });

  var Button = /*@__PURE__*/(function (Node) {
    function Button(options) {
      if ( options === void 0 ) options = {};

      Node.call(this, options);

      this._form = null;
      this._menu = null;

      this.setForm(options.form);
      this.setMenu(options.menu);

      this
        .attributes({
          type: 'button'
        })
        .name('button');
    }

    if ( Node ) Button.__proto__ = Node;
    Button.prototype = Object.create( Node && Node.prototype );
    Button.prototype.constructor = Button;

    Button.prototype.getForm = function getForm () {
      return this._form;
    };

    Button.prototype.setForm = function setForm (value) {
      if ( value === void 0 ) value = false;

      this._form = value;
      return this;
    };

    Button.prototype.getMenu = function getMenu () {
      return this._menu;
    };

    Button.prototype.setMenu = function setMenu (value) {
      if ( value === void 0 ) value = false;

      this._menu = value;
      return this;
    };

    Button.prototype.form = function form () {
      return this.setForm(true);
    };

    Button.prototype.menu = function menu () {
      return this.setMenu(true);
    };

    Button.prototype.removeBefore = function removeBefore () {
      this._node.on('.scola-button', null);
      this.removeOuter();
    };

    Button.prototype.resolveAfter = function resolveAfter (box, data) {
      if (this._form === true) {
        return this.resolveForm(box, data);
      }

      if (this._menu === true) {
        return this.resolveMenu(box);
      }

      return this._node;
    };

    Button.prototype.resolveForm = function resolveForm () {
      var form = this._node.attr('form');

      this._node.on('click.scola-button', function () {
        event$1.preventDefault();
        select('#' + form).dispatch('submit', {
          cancelable: true
        });
      });

      return this._node;
    };

    Button.prototype.resolveMenu = function resolveMenu (box) {
      if (box.options.mem === false && box.options.his === false) {
        this._node
          .attr('class', null)
          .classed('button icon show-menu ion-ios-menu', true)
          .text(null);
      }

      return this._node;
    };

    return Button;
  }(Node$1));

  var Anchor = /*@__PURE__*/(function (Button) {
  	function Anchor () {
  		Button.apply(this, arguments);
  	}if ( Button ) Anchor.__proto__ = Button;
  	Anchor.prototype = Object.create( Button && Button.prototype );
  	Anchor.prototype.constructor = Anchor;

  	

  	return Anchor;
  }(Button));

  var classes = ['right', 'center', 'left'];

  var Bar = /*@__PURE__*/(function (Node) {
    function Bar () {
      Node.apply(this, arguments);
    }

    if ( Node ) Bar.__proto__ = Node;
    Bar.prototype = Object.create( Node && Node.prototype );
    Bar.prototype.constructor = Bar;

    Bar.prototype.resolveAfter = function resolveAfter () {
      for (var i = 0; i < classes.length; i += 1) {
        this.checkChild(classes[i], classes[i - 1]);
      }

      return this._node;
    };

    Bar.prototype.checkChild = function checkChild (classed, before) {
      var size = this._node
        .select('.' + classed)
        .size();

      if (size > 0) {
        return;
      }

      this._node
        .insert('div', '.' + before)
        .classed(classed, true);
    };

    return Bar;
  }(Node$1));

  var Clip = /*@__PURE__*/(function (Node) {
    function Clip () {
      Node.apply(this, arguments);
    }

    if ( Node ) Clip.__proto__ = Node;
    Clip.prototype = Object.create( Node && Node.prototype );
    Clip.prototype.constructor = Clip;

    Clip.prototype.createNode = function createNode () {
      var this$1 = this;

      var fragment = document.createDocumentFragment();

      fragment.getAttribute = function () {};
      fragment.setAttribute = function () {};
      fragment.snippet = this;

      this.setNode(select(fragment));

      this._parent
        .node()
        .insert(function () { return this$1._node.node(); });
    };

    Clip.prototype.resolveInner = function resolveInner (box, data) {
      var this$1 = this;

      for (var i = 0; i < this._args.length; i += 1) {
        if (i === box.tab) {
          this.resolveValue(box, data, this._args[i]);
        } else {
          this._args[i].remove();
        }
      }

      this._parent
        .node()
        .insert(function () { return this$1._node.node(); });

      return this.resolveAfter(box, data);
    };

    return Clip;
  }(Node$1));

  var Form = /*@__PURE__*/(function (Node) {
    function Form(options) {
      Node.call(this, options);

      this
        .attributes({
          novalidate: 'novalidate'
        })
        .name('form');
    }

    if ( Node ) Form.__proto__ = Node;
    Form.prototype = Object.create( Node && Node.prototype );
    Form.prototype.constructor = Form;

    Form.prototype.resolveBefore = function resolveBefore (box, data) {
      if (box.busy === true) {
        delete box.busy;
        return this._node;
      }

      return this.resolveOuter(box, data);
    };

    return Form;
  }(Node$1));

  var Hint = /*@__PURE__*/(function (Node) {
    function Hint () {
      Node.apply(this, arguments);
    }

    if ( Node ) Hint.__proto__ = Node;
    Hint.prototype = Object.create( Node && Node.prototype );
    Hint.prototype.constructor = Hint;

    Hint.prototype.resolveAfter = function resolveAfter (box, data) {
      var assign;

      if (typeof data.data === 'undefined' || data.data === null) {
        return this._node;
      }

      var parent = this._node.node().parentNode;
      var input = parent.querySelector('input, select, textarea');

      if (input === null || typeof input.snippet === 'undefined') {
        return this._node;
      }

      input = input.snippet;

      var name = input.node().attr('name');
      var value = data.data[name];

      if (Array.isArray(value) === true) {
        (assign = this.resolveArray(box, data, input, name, value), name = assign[0], value = assign[1]);
      }

      var text = null;

      if (
        typeof value !== 'undefined' &&
        typeof value.reason !== 'undefined'
      ) {
        text = this._builder
          .format()
          .code(("input." + (value.type) + "." + (value.reason)))
          .values(value);
      }

      this._node.text(
        this.resolveValue(box, data, text)
      );

      return this._node;
    };

    Hint.prototype.resolveArray = function resolveArray (box, data, input, name, value) {
      var multiple = input
        .node()
        .attr('multiple');

      var all = this._builder
        .getView()
        .query(("input[name=\"" + name + "\"]"))
        .resolve();

      if (typeof multiple === 'undefined') {
        var index = all.indexOf(input);
        value = value[index];
      } else {
        value = value.reduce(function (a, v) { return v; }, {});
      }

      return [name, value];
    };

    return Hint;
  }(Node$1));

  var List = /*@__PURE__*/(function (Generator) {
    function List () {
      Generator.apply(this, arguments);
    }

    if ( Generator ) List.__proto__ = Generator;
    List.prototype = Object.create( Generator && Generator.prototype );
    List.prototype.constructor = List;

    List.prototype.prepareList = function prepareList (box, data) {
      if (box.list.clear) {
        delete box.list.clear;

        box.list.offset = 0;
        box.list.total = 0;

        this.removeChildren();
      }

      if (box.list.offset === 0 && box.list.count > 0) {
        this._node.node().parentNode.scrollTop = 0;
      }

      box.list.total += data.length;
    };

    List.prototype.removeInner = function removeInner () {
      this.removeChildren();
      this.removeAfter();
    };

    List.prototype.resolveInner = function resolveInner (box, data) {
      var hasData = Array.isArray(data.data);
      var listData = data.data || [];

      var ref = this._args;
      var item = ref[0];
      var empty = ref[1];

      if (box.busy === true) {
        delete box.busy;
      }

      if (box.list) {
        this.prepareList(box, listData);
      }

      for (var i = 0; i < listData.length; i += 1) {
        this.appendChild(box, listData[i], item);
      }

      var size = this._node
        .select('.item:not(.out)')
        .size();

      if (hasData === true && size === 0) {
        this.appendChild(box, [{}], empty);
      }

      return this.resolveAfter(box, data);
    };

    return List;
  }(Generator));

  var Loading = /*@__PURE__*/(function (Node) {
    function Loading () {
      Node.apply(this, arguments);
    }

    if ( Node ) Loading.__proto__ = Node;
    Loading.prototype = Object.create( Node && Node.prototype );
    Loading.prototype.constructor = Loading;

    Loading.prototype.resolveAfter = function resolveAfter (box, data) {
      if (data.lengthComputable !== true) {
        return this._node;
      }

      var fraction = data.loaded / data.total;

      this._node.classed('in', fraction < 1);

      return this._node;
    };

    return Loading;
  }(Node$1));

  var Message$1 = /*@__PURE__*/(function (Node) {
    function Message(options) {
      if ( options === void 0 ) options = {};

      Node.call(this, options);
      this.class('transition');
    }

    if ( Node ) Message.__proto__ = Node;
    Message.prototype = Object.create( Node && Node.prototype );
    Message.prototype.constructor = Message;

    Message.prototype.resolveAfter = function resolveAfter (box, data) {
      if (typeof data.status === 'undefined') {
        return this._node;
      }

      var code = "status." + (data.status);

      if (data.code) {
        code += '.' + data.code;
      }

      var text = this._builder
        .format()
        .code(code)
        .values(data);

      this._node.text(
        this.resolveValue(box, data, text)
      );

      this._node.classed('in', true);

      return this._node;
    };

    return Message;
  }(Node$1));

  var Panel = /*@__PURE__*/(function (Node) {
    function Panel(options) {
      if ( options === void 0 ) options = {};

      Node.call(this, options);
      this.class('transition');
    }

    if ( Node ) Panel.__proto__ = Node;
    Panel.prototype = Object.create( Node && Node.prototype );
    Panel.prototype.constructor = Panel;

    Panel.prototype.resolveBefore = function resolveBefore (box, data) {
      var this$1 = this;

      var effect = ['rtl', 'ltr', 'ins']
        .find(function (name) { return box.options[name] === true; }) || 'none';

      var old = box.base.snippet ? box.base.snippet.node()
        .classed('rtl ltr ins', false) : select();

      old
        .classed('old', true)
        .classed(effect, true)
        .on('transitionend.scola-panel', function () {
          old.on('.scola-panel', null);
          old.node().snippet.remove();
        });

      this._node
        .classed('new', true)
        .classed(effect, true)
        .on('transitionend.scola-panel', function () {
          this$1._node.on('.scola-panel', null);
          box.base.busy = false;
        });

      return this.resolveOuter(box, data);
    };

    Panel.prototype.resolveAfter = function resolveAfter (box) {
      var effect = ['rtl', 'ltr', 'ins']
        .find(function (name) { return box.options[name] === true; }) || 'none';

      var old = box.base.snippet ? box.base.snippet.node() : select();
      var duration = parseFloat(this._node.style('transition-duration'));

      old.classed('in', false);
      this._node.classed('in', true);

      if (effect === 'none' || duration === 0) {
        old.dispatch('transitionend');
        this._node.dispatch('transitionend');
      }

      box.base.snippet = this;

      return this._node;
    };

    return Panel;
  }(Node$1));

  var Progress = /*@__PURE__*/(function (Node) {
    function Progress(options) {
      if ( options === void 0 ) options = {};

      Node.call(this, options);
      this.class('transition');
    }

    if ( Node ) Progress.__proto__ = Node;
    Progress.prototype = Object.create( Node && Node.prototype );
    Progress.prototype.constructor = Progress;

    Progress.prototype.resolveAfter = function resolveAfter (box, data) {
      var this$1 = this;

      if (data.lengthComputable !== true) {
        return this._node;
      }

      var fraction = data.loaded / data.total;

      this._node
        .style('transition-duration', null)
        .style('width', (fraction * 100) + '%')
        .on('transitionend.scola-progress', function () {
          if (fraction < 1) {
            return;
          }

          this$1._node
            .style('transition-duration', '0s')
            .style('width', null)
            .on('.scola-progress', null);
        });

      var duration = parseFloat(
        this._node.style('transition-duration')
      );

      if (duration === 0) {
        this._node.dispatch('transitionend');
      }

      return this._node;
    };

    return Progress;
  }(Node$1));

  var Search$1 = /*@__PURE__*/(function (Node) {
    function Search(options) {
      if ( options === void 0 ) options = {};

      Node.call(this, options);

      this._placeholder = null;
      this._storage = null;
      this._wildcard = null;

      this.setPlaceholder(options.placeholder);
      this.setStorage(options.storage);
      this.setWildcard(options.wildcard);

      this.class('transition');
    }

    if ( Node ) Search.__proto__ = Node;
    Search.prototype = Object.create( Node && Node.prototype );
    Search.prototype.constructor = Search;

    Search.prototype.getOptions = function getOptions () {
      return Object.assign(Node.prototype.getOptions.call(this), {
        storage: this._storage,
        wildcard: this._wildcard
      });
    };

    Search.prototype.getPlaceholder = function getPlaceholder () {
      return this._placeholder;
    };

    Search.prototype.setPlaceholder = function setPlaceholder (value) {
      if ( value === void 0 ) value = null;

      this._placeholder = value;
      return this;
    };

    Search.prototype.getStorage = function getStorage () {
      return this._storage;
    };

    Search.prototype.setStorage = function setStorage (value) {
      if ( value === void 0 ) value = localStorage;

      this._storage = value;
      return this;
    };

    Search.prototype.getWildcard = function getWildcard () {
      return this._wildcard;
    };

    Search.prototype.setWildcard = function setWildcard (value) {
      if ( value === void 0 ) value = '*';

      this._wildcard = value;
      return this;
    };

    Search.prototype.placeholder = function placeholder (value) {
      return this.setPlaceholder(value);
    };

    Search.prototype.storage = function storage (value) {
      return this.setStorage(value);
    };

    Search.prototype.wildcard = function wildcard (value) {
      return this.setWildcard(value);
    };

    Search.prototype.formatSearch = function formatSearch (value) {
      var parts = value.match(/[^"\s]+|"[^"]+"/g) || [];

      var match = null;
      var part = null;

      for (var i = 0; i < parts.length; i += 1) {
        part = parts[i];
        match = part.match(/".+"/);

        if (match === null) {
          parts[i] = this._wildcard + part + this._wildcard;
        }
      }

      if (parts.length > 0) {
        return parts.join(' ').trim();
      }

      return void 0;
    };

    Search.prototype.resolveBefore = function resolveBefore (box, data) {
      if (typeof box.input !== 'undefined') {
        return this.resolveInput(box, data);
      }

      if (typeof box.toggle !== 'undefined') {
        return this.resolveToggle(box, data);
      }

      return this.resolveSearch(box, data);
    };

    Search.prototype.resolveInput = function resolveInput (box) {
      this._storage.setItem('search-' + this._id, box.input);

      box.list.clear = true;
      box.list.search = this.formatSearch(box.input);

      delete box.input;
      return this._node;
    };

    Search.prototype.resolveSearch = function resolveSearch (box, data) {
      var placeholder = this.resolveValue(box, data, this._placeholder);

      var input = this._node
        .append('input')
        .attr('autocomplete', 'on')
        .attr('name', 'search')
        .attr('type', 'search')
        .attr('placeholder', placeholder);

      var value = this._storage.getItem('search-' + this._id);

      if (value) {
        this._node.classed('in', true);
        input.attr('value', value);

        defaultsDeep(box, {
          list: {
            search: this.formatSearch(value)
          }
        });
      }

      return this.resolveOuter(box, data);
    };

    Search.prototype.resolveToggle = function resolveToggle (box) {
      var mustIn = !this._node.classed('in');

      if (mustIn) {
        this._node
          .select('input')
          .node()
          .focus();
      }

      this._node.classed('in', mustIn);

      delete box.toggle;
      return this._node;
    };

    return Search;
  }(Node$1));

  var Tip = /*@__PURE__*/(function (Node) {
    function Tip(options) {
      if ( options === void 0 ) options = {};

      Node.call(this, options);
      this.class('transition');
    }

    if ( Node ) Tip.__proto__ = Node;
    Tip.prototype = Object.create( Node && Node.prototype );
    Tip.prototype.constructor = Tip;

    Tip.prototype.removeOuter = function removeOuter () {
      var this$1 = this;

      this._node
        .classed('out', true)
        .on('transitionend.scola-tip', function () {
          this$1._node.on('.scola-tip', null);
          this$1.removeNode();
          this$1.removeInner();
        });

      var duration = parseFloat(
        this._node.style('transition-duration')
      );

      if (duration === 0) {
        this._node.dispatch('transitionend');
      }
    };

    Tip.prototype.resolveAfter = function resolveAfter (box, data) {
      var this$1 = this;

      select('body').insert(function () { return this$1._node.node(); });

      var targetRect = data.target.getBoundingClientRect();
      var tipRect = this._node.node().getBoundingClientRect();

      var left = targetRect.left +
        (targetRect.width / 2) -
        (tipRect.width / 2);

      var top = targetRect.top -
        tipRect.height;

      this._node
        .style('top', top + 'px')
        .style('left', left + 'px')
        .style('width', tipRect.width + 'px')
        .style('height', tipRect.height + 'px');

      this._node.classed('in', true);
    };

    Tip.prototype.resolveBefore = function resolveBefore (box, data) {
      if (this._node.classed('out')) {
        this.removeNode();
        this.createNode();
      }

      return this.resolveOuter(box, data);
    };

    return Tip;
  }(Node$1));



  var node = /*#__PURE__*/Object.freeze({
    List: List,
    Anchor: Anchor,
    Button: Button,
    Clip: Clip,
    Form: Form,
    Hint: Hint,
    Bar: Bar,
    Loading: Loading,
    Message: Message$1,
    Panel: Panel,
    Progress: Progress,
    Search: Search$1,
    Tip: Tip
  });

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet$1(object, path) {
    path = castPath$1(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey$2(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get$3(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet$1(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */
  var merge$1 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });

  var locale$2 = 'nl_NL';
  var strings = {};

  var Format$1 = /*@__PURE__*/(function (Snippet) {
    function Format(options) {
      if ( options === void 0 ) options = {};

      Snippet.call(this, options);

      this._code = null;
      this._locale = null;
      this._values = null;

      this.setCode(options.code);
      this.setLocale(options.locale);
      this.setValues(options.values);
    }

    if ( Snippet ) Format.__proto__ = Snippet;
    Format.prototype = Object.create( Snippet && Snippet.prototype );
    Format.prototype.constructor = Format;

    Format.getLocale = function getLocale () {
      return locale$2;
    };

    Format.setLocale = function setLocale (value) {
      locale$2 = value;
    };

    Format.getNumbers = function getNumbers () {
      return vsprintf.n.definitions;
    };

    Format.setNumbers = function setNumbers (value) {
      vsprintf.n.definitions = value;
    };

    Format.addNumbers = function addNumbers (value) {
      merge$1(vsprintf.n.definitions, value);
    };

    Format.getStrings = function getStrings () {
      return strings;
    };

    Format.setStrings = function setStrings (value) {
      strings = value;
    };

    Format.addStrings = function addStrings (value) {
      merge$1(strings, value);
    };

    Format.prototype.getOptions = function getOptions () {
      return Object.assign(Snippet.prototype.getOptions.call(this), {
        code: this._code,
        locale: this._locale,
        values: this._values
      });
    };

    Format.prototype.getCode = function getCode () {
      return this._code;
    };

    Format.prototype.setCode = function setCode (value) {
      if ( value === void 0 ) value = null;

      this._code = value;
      return this;
    };

    Format.prototype.getLocale = function getLocale () {
      return this._locale;
    };

    Format.prototype.setLocale = function setLocale (value) {
      if ( value === void 0 ) value = locale$2;

      this._locale = value;
      return this;
    };

    Format.prototype.getValues = function getValues () {
      return this._values;
    };

    Format.prototype.setValues = function setValues (value) {
      if ( value === void 0 ) value = null;

      this._values = value;
      return this;
    };

    Format.prototype.code = function code (value) {
      return this.setCode(value);
    };

    Format.prototype.locale = function locale (value) {
      return this.setLocale(value);
    };

    Format.prototype.values = function values (value) {
      return this.setValues(value);
    };

    Format.prototype.resolveAfter = function resolveAfter (box, data) {
      var string = '';

      var flocale = this.resolveValue(box, data, this._locale);
      var code = this.resolveValue(box, data, this._code);

      var values = this.resolveValue(box, data, this._values);
      values = Array.isArray(values) ? values : [values];

      string = get$3(strings, (flocale + "." + code));
      string = typeof string === 'undefined' ? code : string;

      try {
        string = vsprintf(string, values, flocale);
      } catch (error) {
        string = error.message;
      }

      return string;
    };

    return Format;
  }(Snippet$1));

  var Selector = /*@__PURE__*/(function (Snippet) {
    function Selector () {
      Snippet.apply(this, arguments);
    }

    if ( Snippet ) Selector.__proto__ = Snippet;
    Selector.prototype = Object.create( Snippet && Snippet.prototype );
    Selector.prototype.constructor = Selector;

    Selector.prototype.resolveAfter = function resolveAfter (box, data) {
      var ref = this._args;
      var query = ref[0];

      if (typeof query === 'function') {
        return this.resolveFunction(box, data, query);
      }

      return this.resolveString(box, data, query);
    };

    Selector.prototype.resolveFunction = function resolveFunction (box, data, query) {
      var result = [];

      var snippets = this._builder
        .getView()
        .find(query);

      for (var i = 0; i < snippets.length; i += 1) {
        result[result.length] = box ?
          this.resolveValue(box, data, snippets[i]) :
          snippets[i];
      }

      return result;
    };

    Selector.prototype.resolveString = function resolveString (box, data, query) {
      var this$1 = this;

      var result = [];

      this._builder
        .getView()
        .node()
        .selectAll(query)
        .each(function (datum, index, nodes) {
          result[result.length] = box ?
            this$1.resolveValue(box, data, nodes[index].snippet) :
            nodes[index].snippet;
        });

      return result;
    };

    return Selector;
  }(Snippet$1));

  var Throw = /*@__PURE__*/(function (Snippet) {
    function Throw () {
      Snippet.apply(this, arguments);
    }

    if ( Snippet ) Throw.__proto__ = Snippet;
    Throw.prototype = Object.create( Snippet && Snippet.prototype );
    Throw.prototype.constructor = Throw;

    Throw.prototype.resolveAfter = function resolveAfter (box, error) {
      throw error;
    };

    return Throw;
  }(Snippet$1));



  var snippet$2 = /*#__PURE__*/Object.freeze({
    Format: Format$1,
    Selector: Selector,
    Throw: Throw
  });

  var snippetBase$1 = {
    action: action,
    event: event$2,
    graph: graph,
    input: input,
    node: node,
    snippet: snippet$2
  };

  var cls = clsBase.reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase$1(name)] = {
        object: Node$1,
        options: {
          class: camelCase$1(name),
          name: 'div'
        }
      }, obj ));
  }, {});

  var dom = domBase.reduce(function (object, name) {
    var obj;

    return Object.assign(object, ( obj = {}, obj[camelCase$1(name)] = {
        object: Node$1,
        options: {
          name: name
        }
      }, obj ));
  }, {});

  var snippet$3 = Object.keys(snippetBase$1).reduce(function (master, group) {
    return Object.keys(snippetBase$1[group]).reduce(function (object, name) {
      var obj;

      return Object.assign(object, ( obj = {}, obj[camelCase$1(name)] = {
          object: snippetBase$1[group][name],
          options: {
            class: camelCase$1(name)
          }
        }, obj ));
    }, master);
  }, {});

  var map$5 = /*#__PURE__*/Object.freeze({
    snippet: snippet$3,
    cls: cls,
    dom: dom
  });

  var ViewBuilder = /*@__PURE__*/(function (Builder) {
    function ViewBuilder(options) {
      if ( options === void 0 ) options = {};

      Builder.call(this, options);

      this._view = null;
      this.setView(options.view);
    }

    if ( Builder ) ViewBuilder.__proto__ = Builder;
    ViewBuilder.prototype = Object.create( Builder && Builder.prototype );
    ViewBuilder.prototype.constructor = ViewBuilder;

    ViewBuilder.setup = function setup () {
      ViewBuilder.attachFactories(ViewBuilder, map$5);
    };

    ViewBuilder.prototype.getView = function getView () {
      return this._view;
    };

    ViewBuilder.prototype.setView = function setView (value) {
      if ( value === void 0 ) value = null;

      this._view = value;
      return this;
    };

    ViewBuilder.prototype.node = function node () {
      return select(this._parent.getBase());
    };

    ViewBuilder.prototype.act = function act (box, data, callback) {
      data = this.filter(box, data);
      this._view.resolve(box, data);
      this.pass(box, data, callback);
    };

    ViewBuilder.prototype.build = function build (view) {
      return this.setView(view.setParent(this));
    };

    return ViewBuilder;
  }(Builder));

  var maxlength = 'Deze waarde is te lang (max. %(maxlength)s tekens).';
  var required = 'Dit veld is verplicht.';
  var pattern = 'Deze waarde is niet goed (%(pattern)s).';

  var nl_NL = {
    button: {
      back: 'Terug'
    },
    input: {
      checkbox: {
        required: required
      },
      color: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Dit is geen kleur.'
      },
      date: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        max: 'Deze datum is te laat (max. %(max)l[D]).',
        min: 'Deze datum is te vroeg (min. %(min)l[D]).',
        type: 'Dit is geen datum.'
      },
      datetime: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        max: 'Deze datumtijd is te laat (max. %(max)l[f]).',
        min: 'Deze datumtijd is te vroeg (min. %(min)l[f]).',
        type: 'Dit is geen datumtijd.'
      },
      email: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        domain: 'Dit is geen e-mailadres.',
        local: 'Dit is geen e-mailadres.',
        space: 'Dit is geen e-mailadres.'
      },
      file: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        accept: 'Het bestandstype is niet juist $(accept)s',
        maxsize: 'Het bestand is te groot (max. %(maxsize)n[~s]B)'
      },
      iban: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Dit is een geen rekeningnummer.'
      },
      month: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        max: 'Deze maand is te laat (max. %(max)l[D]).',
        min: 'Deze maand is te vroeg (min. %(min)l[D]).',
        type: 'Dit is geen maand.'
      },
      num: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        max: 'Dit getal is te hoog (max. %(max)s).',
        min: 'Dit getal is te laag (min. %(min)s).',
        type: 'Dit is geen getal.'
      },
      password: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Dit is geen wachtwoord.'
      },
      radio: {
        required: required
      },
      range: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        max: 'Dit getal is te hoog (max. %(max)s).',
        min: 'Dit getal is te laag (min. %(min)s).',
        type: 'Dit is geen getal.'
      },
      select: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Deze waarde is niet goed.'
      },
      tel: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Dit is geen telefoonnummer.'
      },
      text: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Dit is geen tekst.'
      },
      textarea: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Dit is geen tekst.'
      },
      time: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        max: 'Deze tijd is te laat (max. %(max)l[t]).',
        min: 'Deze tijd is te vroeg (max. %(max)l[t]).',
        type: 'Dit is geen tijd.'
      },
      zip: {
        maxlength: maxlength,
        pattern: pattern,
        required: required,
        type: 'Dit is geen postcode.'
      }
    },
    message: {
      nodata: 'Geen gegevens gevonden'
    },
    search: {
      placeholder: 'Zoeken'
    },
    status: {
      400: 'De gegevens zijn niet juist.',
      404: 'Het pad is niet gevonden.',
      405: 'De bewerking is niet toegestaan.',
      409: 'Er is een conflict opgetreden.',
      413: 'De gegevens zijn te groot.',
      500: 'Er is een serverfout opgetreden.',
      502: 'Er is een verbindingsfout opgetreden.',
      504: 'Er is een verbindingsfout opgetreden.'
    }
  };

  var locale$3 = {
    nl_NL: nl_NL
  };

  function worker() {
    Worker.setLog(Worker.log);

    ViewBuilder.setup();
    Axis.setup();
    Plot.setup();

    Format$1.addStrings(locale$3);
  }

  function setup$1() {
    bind();
    shim$b();
    worker();
  }

  var sprintf$1 = createCommonjsModule(function (module, exports) {
  /* global window, exports, define */

  !function() {

      var re = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[+-]/
      };

      function sprintf(key) {
          // `arguments` is not an array, but should be fine for this call
          return sprintf_format(sprintf_parse(key), arguments)
      }

      function vsprintf(fmt, argv) {
          return sprintf.apply(null, [fmt].concat(argv || []))
      }

      function sprintf_format(parse_tree, argv) {
          var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;
          for (i = 0; i < tree_length; i++) {
              if (typeof parse_tree[i] === 'string') {
                  output += parse_tree[i];
              }
              else if (typeof parse_tree[i] === 'object') {
                  ph = parse_tree[i]; // convenience purposes only
                  if (ph.keys) { // keyword argument
                      arg = argv[cursor];
                      for (k = 0; k < ph.keys.length; k++) {
                          if (arg == undefined) {
                              throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                          }
                          arg = arg[ph.keys[k]];
                      }
                  }
                  else if (ph.param_no) { // positional argument (explicit)
                      arg = argv[ph.param_no];
                  }
                  else { // positional argument (implicit)
                      arg = argv[cursor++];
                  }

                  if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                      arg = arg();
                  }

                  if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                      throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                  }

                  if (re.number.test(ph.type)) {
                      is_positive = arg >= 0;
                  }

                  switch (ph.type) {
                      case 'b':
                          arg = parseInt(arg, 10).toString(2);
                          break
                      case 'c':
                          arg = String.fromCharCode(parseInt(arg, 10));
                          break
                      case 'd':
                      case 'i':
                          arg = parseInt(arg, 10);
                          break
                      case 'j':
                          arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                          break
                      case 'e':
                          arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                          break
                      case 'f':
                          arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                          break
                      case 'g':
                          arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                          break
                      case 'o':
                          arg = (parseInt(arg, 10) >>> 0).toString(8);
                          break
                      case 's':
                          arg = String(arg);
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 't':
                          arg = String(!!arg);
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 'T':
                          arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 'u':
                          arg = parseInt(arg, 10) >>> 0;
                          break
                      case 'v':
                          arg = arg.valueOf();
                          arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
                          break
                      case 'x':
                          arg = (parseInt(arg, 10) >>> 0).toString(16);
                          break
                      case 'X':
                          arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                          break
                  }
                  if (re.json.test(ph.type)) {
                      output += arg;
                  }
                  else {
                      if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                          sign = is_positive ? '+' : '-';
                          arg = arg.toString().replace(re.sign, '');
                      }
                      else {
                          sign = '';
                      }
                      pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
                      pad_length = ph.width - (sign + arg).length;
                      pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';
                      output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);
                  }
              }
          }
          return output
      }

      var sprintf_cache = Object.create(null);

      function sprintf_parse(fmt) {
          if (sprintf_cache[fmt]) {
              return sprintf_cache[fmt]
          }

          var _fmt = fmt, match, parse_tree = [], arg_names = 0;
          while (_fmt) {
              if ((match = re.text.exec(_fmt)) !== null) {
                  parse_tree.push(match[0]);
              }
              else if ((match = re.modulo.exec(_fmt)) !== null) {
                  parse_tree.push('%');
              }
              else if ((match = re.placeholder.exec(_fmt)) !== null) {
                  if (match[2]) {
                      arg_names |= 1;
                      var field_list = [], replacement_field = match[2], field_match = [];
                      if ((field_match = re.key.exec(replacement_field)) !== null) {
                          field_list.push(field_match[1]);
                          while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                              if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                  field_list.push(field_match[1]);
                              }
                              else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                  field_list.push(field_match[1]);
                              }
                              else {
                                  throw new SyntaxError('[sprintf] failed to parse named argument key')
                              }
                          }
                      }
                      else {
                          throw new SyntaxError('[sprintf] failed to parse named argument key')
                      }
                      match[2] = field_list;
                  }
                  else {
                      arg_names |= 2;
                  }
                  if (arg_names === 3) {
                      throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                  }

                  parse_tree.push(
                      {
                          placeholder: match[0],
                          param_no:    match[1],
                          keys:        match[2],
                          sign:        match[3],
                          pad_char:    match[4],
                          align:       match[5],
                          width:       match[6],
                          precision:   match[7],
                          type:        match[8]
                      }
                  );
              }
              else {
                  throw new SyntaxError('[sprintf] unexpected placeholder')
              }
              _fmt = _fmt.substring(match[0].length);
          }
          return sprintf_cache[fmt] = parse_tree
      }

      /**
       * export to either browser or node.js
       */
      /* eslint-disable quote-props */
      {
          exports['sprintf'] = sprintf;
          exports['vsprintf'] = vsprintf;
      }
      if (typeof window !== 'undefined') {
          window['sprintf'] = sprintf;
          window['vsprintf'] = vsprintf;
      }
      /* eslint-enable quote-props */
  }(); // eslint-disable-line
  });

  function luxon(value, options, locale) {
    if ( options === void 0 ) options = '';
    if ( locale === void 0 ) locale = 'nl_NL';

    locale = locale.replace('_', '-');
    options = options ? options.split(';') : [];

    var format = options[0]; if ( format === void 0 ) format = 'D';

    return DateTime
      .fromISO(value)
      .toFormat(format, { locale: locale });
  }

  function marked(value, options) {
    var assign;

    if ( options === void 0 ) options = '';
    options = options ? options.split(';') : [];

    var moptions = {
      breaks: true,
      sanitize: true
    };

    var key = null;
    var val = null;

    for (var i = 0; i < options.length; i += 1) {
      (assign = options[i].split('='), key = assign[0], val = assign[1]);
      moptions[key] = val === '0' ? false : true;
    }

    return marked$1(value, moptions);
  }

  var defaultFormat = {
    format: format,
    formatPrefix: formatPrefix
  };

  var definitions = {};

  function number(value, options, locale) {
    if ( options === void 0 ) options = '';
    if ( locale === void 0 ) locale = 'nl_NL';

    options = options ? options.split(';') : [];

    var specifier = options[0]; if ( specifier === void 0 ) specifier = 'f';
    var val = options[1]; if ( val === void 0 ) val = '';
    var separator = options[2]; if ( separator === void 0 ) separator = '';

    var definition = definitions[locale] ?
      formatLocale(definitions[locale]) :
      defaultFormat;

    var formatter = val === '' ?
      definition.format(specifier) :
      definition.formatPrefix(specifier, val);

    value = formatter(value);
    value = separator === '' ?
      value :
      value.slice(0, -1) + separator + value.slice(-1);

    return value;
  }

  number.definitions = definitions;

  var formatters = { l: luxon, m: marked, n: number };
  var regexpBase = '%((\\((\\w+)\\))?((\\d+)\\$)?)([b-gijostTuvxXlmn])(\\[(.+)\\])?';
  var regexpGlobal = new RegExp(regexpBase, 'g');
  var regexpSingle = new RegExp(regexpBase);
  var reductor = function (name) { return function (a, v) { return typeof v[name] === 'undefined' ? a : v[name]; }; };

  function vsprintf(format, args, locale) {
    var assign;

    var matches = format.match(regexpGlobal) || [];

    var match = null;
    var name = null;
    var position = null;
    var options = null;
    var type = null;
    var value = null;

    for (var i = 0; i < matches.length; i += 1) {
      (assign = matches[i].match(regexpSingle), match = assign[0], name = assign[3], position = assign[5], type = assign[6], options = assign[8]);

      value = position ?
        args[position - 1] :
        (name ?
          args.reduce(reductor(name), '') :
          args[i]);

      if (formatters[type]) {
        format = format.replace(
          match,
          formatters[type](value, options, locale)
        );
      }
    }

    return sprintf$1.vsprintf(format, args);
  }

  Object.assign(vsprintf, formatters);



  var index$3 = /*#__PURE__*/Object.freeze({
    setup: setup$1,
    vsprintf: vsprintf,
    locale: locale$3,
    ViewRouter: ViewRouter,
    PopRouter: PopRouter,
    ViewBuilder: ViewBuilder,
    action: action,
    event: event$2,
    graph: graph,
    input: input,
    node: node,
    snippet: snippet$2,
    Action: Action,
    Event: Event$1,
    Axis: Axis,
    Circle: Circle,
    Grid: Grid,
    Path: Path,
    Plot: Plot,
    Rect: Rect,
    Tick: Tick,
    Input: Input,
    Node: Node$1,
    Snippet: Snippet$1
  });

  exports.doc = index$1;
  exports.dom = index$3;
  exports.http = index$2;
  exports.worker = index;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
